// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['underscore'], factory);
    } else if (typeof exports === 'object') {
        var _ = require('underscore');
        module.exports = factory(_);
    } else {
        // change "myLib" to whatever your library is called
        root.Rete = factory(root._);
    }
}(this, function (_) {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('../libs/Rete.min',['underscore'], factory);
    } else if (typeof exports === 'object') {
        var _ = require('underscore');
        module.exports = factory(_);
    } else {
        // change "myLib" to whatever your library is called
        root.Rete = factory(root._);
    }
}(this, function (_) {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('ReteDataStructures',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteDataStructures
   @purpose to define the data structures required for rete
*/

var _ = require('underscore'),
    nextId = 0;


/**
   @data ProposedAction
   @purpose describes a queued, but not yet performed, action
   @note queue/invalidate time absolute,
   @note assertTime/retractTime relative to when action is enacted
*/
var ProposedAction = function(reteNet,type,payload,token,proposeTime,timingObj){
    this.id = nextId++;
    this.reteNet = reteNet;
    this.actionType = type;//ie: "assert","retract","perform"...
    this.payload = payload; //ie" : {a:3,b:4}...
    this.token = token; //Source Token that spawned this action
    this.timing = {
        proposeTime : proposeTime,//when PA is created
        invalidateTime : proposeTime+timingObj.invalidateOffset, //when it becomes invalid
        performOffset : timingObj.performOffset, //PerformTime+pO is when it happens
        unperformOffset : timingObj.unperformOffset //PerformTime+uPO when to remove
    };

    //todo: possibly include metrics for selection of actions?
    //todo: check for circular reference cleanup
    //update Token:
    this.token.proposedActions.push(this);
};


/**
   @data WME
   @purpose to store facts in the rete net
*/
var WME = function(data,assertTime){
    this.isWME = true;
    this.data = data;
    //The lifetime of the wme. Asserted at time lifeTime[0],
    //retracted at time lifeTime[1]:
    if(assertTime === undefined) { assertTime = 0; }
    this.lifeTime = [assertTime];
    //Alpha memories the wme is part of
    this.alphaMemoryItems = [];
    //Tokens the wme is part of
    this.tokens = [];
    //Tokens this wme is blocking
    this.negJoinResults = [];
    this.id = nextId;
    nextId++;
};

/**
   @data Token
   @purpose To combine intermediate results in the beta network
*/
//bindings are updated as the token progresses
var Token = function(parentToken,wme,owningNode,bindings){
    this.isToken = true;
    this.parentToken = parentToken; //ie:owner
    this.wme = wme;
    this.owningNode = owningNode;
    this.children = []; //list of nodes
    this.negJoinResults = [];//list of NegativeJoinResults
    this.nccResults = []; //list of Token
    this.proposedActions = []; //current proposed actions
    
    if(this.parentToken){
        this.parentToken.children.unshift(this);
    }
    if(this.wme && this.wme.tokens){
        this.wme.tokens.unshift(this);
    }

    //copy over bindings from parent,
    //then copy in new bindings
    this.bindings = {};

    if(this.parentToken && this.parentToken.bindings){
        _.keys(this.parentToken.bindings).forEach(function(d){
            this.bindings[d] = this.parentToken.bindings[d];
        },this);
    }
    _.keys(bindings).forEach(function(d){
        this.bindings[d] = bindings[d];
    },this);

    this.id = nextId;
    nextId++;        
};

//------------------------------

/**
   @data AlphaMemoryItem
   @purpose a Pairing of a wme with an alpha memory it resides in
*/
//Utility storage of wme and its alphaMemory together
//used in alphamemory and WME
var AlphaMemoryItem = function(wme,alphaMem){
    this.wme = wme;
    this.alphaMemory = alphaMem;
    this.id = nextId;
    nextId++;
};


/**
   @data AlphaNode
   @purpose a node to perform constant tests on newly asserted WMEs
*/
//A constant test node
//constantTest = {field:"",value:"",operator:""};
var AlphaNode = function(parent,constantTestSpec){
    this.id = nextId;
    this.isConstantTestNode = true;
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.children = [];
    this.outputMemory = undefined;
    if(constantTestSpec){
        this.testField = constantTestSpec.field;
        this.testValue = constantTestSpec.value;
        this.operator = constantTestSpec.operator;
    }else{
        this.passThrough = true;
    }
    nextId++;
};

/**
   @data AlphaMemory
   @purpose to store wmes that have passed through constant tests
*/
//Alpha Memory node
var AlphaMemory = function(parent){
    this.isAlphaMemory = true;
    this.items = [];
    this.parent = parent;
    //If adding to a node other than a test node,
    if(parent && parent.isConstantTestNode === undefined){
        //add to children
        this.parent.children.unshift(this);
    }else if(this.parent && this.parent.outputMemory === undefined){
        //if an alphanode, set the ouputmemory field
        this.parent.outputMemory = this;
    }else if(this.parent && this.parentOutputMemory !== undefined){
        throw new Error("trying to create an alpha memory for a node that already has one");
    }
    this.children = [];
    this.unlinkedChildren = [];
    this.referenceCount = 0;
    this.isMemoryNode = true;
    this.id = nextId;
    nextId++;
};

/**
   @data ReteNode
   @purpose provides a base definition of a node in the rete network
*/    
//Base node for the beta network
var ReteNode = function(parent){
    this.children = [];
    this.unlinkedChildren = [];
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.id = nextId;
    nextId++;
};

/**
   @data BetaMemory
   @inherits ReteNode
   @purpose A Node to store tokens in the rete network
*/
//Beta Memory Stores tokens
var BetaMemory = function(parent){
    ReteNode.call(this,parent);
    this.isBetaMemory = true;
    this.isMemoryNode = true;
    this.items = [];
    if(parent === undefined){
        this.dummy = true;
        this.items.push(new Token());
        this.items[0].owningNode = this;
    }

};

/**
   @data JoinNode
   @inherits ReteNode
   @purpose To combine tokens and wmes, according to binding tests
*/
//Join Node combines tokens with wmes
//tests are the binding tuples from a condition
var JoinNode = function(parent,alphaMemory,tests){
    ReteNode.call(this,parent);
    this.isJoinNode = true;
    this.alphaMemory = alphaMemory;
    if(tests){
        this.tests = tests;
    }else{
        this.tests = [];
    }
    if(this.alphaMemory && this.alphaMemory.children){
        this.alphaMemory.children.unshift(this);
        this.alphaMemory.referenceCount += 1;
    }
    this.nearestAncestor = null;
};

/**
   @data ActionNode
   @purpose A Node which, when activated, will cause the effects a rule describes
*/
//Container object for a general graphnode action description    
var ActionNode = function(parent,actionDescriptions,boundActions,ruleName,reteNet){
    ReteNode.call(this,parent);
    this.isActionNode = true;
    this.name = ruleName;
    this.actionDescriptions = actionDescriptions;
    this.boundActions = boundActions;
    //reference to retenet, to allow storage of results of firing:
    this.reteNet = reteNet;
};


/**
   @data NegativeJoinResult
   @purpose To Store the combination of a token and a wme that blocks it from progressing through the network
*/
//Storage for a token blocked by a wme
//Updates the owner token and wme as part of its construction
var NegativeJoinResult = function(owner,wme){
    this.owner = owner;
    if(this.owner){
        this.owner.negJoinResults.unshift(this);
    }
    this.wme = wme;
    if(this.wme){
        this.wme.negJoinResults.unshift(this);
    }
    this.id = nextId;
    nextId++;
};


/**
   @data NegativeNode
   @purpose A Node that tests for the abscence of particular wmes
*/
//Negative Node:The node that gates token progression
var NegativeNode = function(parent,alphaMemory,tests){
    if(tests.length === 0){
        throw new Error("Negative Node requires a binding");
    }
    ReteNode.call(this,parent);
    this.isNegativeNode = true;
    this.items = [];
    this.alphaMemory = alphaMemory;
    if(this.alphaMemory){
        this.alphaMemory.referenceCount++;
        this.alphaMemory.children.unshift(this);
    }
    this.tests = tests;
    this.nearestAncestor = null;
};

/**
   @data NCCNode
   @purpose The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork
*/
//NCC : gates token progression based on a subnetwork
//SEE ALSO: NCCCondition
//old: NegatedConjunctiveConditionNode
var NCCNode = function(parent){
    //don't pass parent in
    ReteNode.call(this);
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.push(this);
    }
    this.isAnNCCNode = true;
    this.items = [];
    this.partner = null;
};


/**
   @data NCCPartnerNode
   @purpose to store potential partial matches in the subnetwork for a NCCNode
*/
//The partner of the NCC, connects to the subnetwork
//old NegConjuConPartnerNode
//var NCCPartner
var NCCPartnerNode = function(parent,num){
    ReteNode.call(this,parent);
    this.isAnNCCPartnerNode = true;
    this.nccNode = null;
    this.numberOfConjuncts = num;
    this.newResultBuffer = [];
    this.id = nextId;
};



//--------------------
/**
   @interface ReteDataStructures
*/
var DataStructures = {
    "WME"              : WME,
    "Token"            : Token,
    "AlphaMemory"      : AlphaMemory,
    "AlphaMemoryItem"  : AlphaMemoryItem,
    "AlphaNode"        : AlphaNode,
    "ReteNode"         : ReteNode,
    "BetaMemory"       : BetaMemory,
    "JoinNode"         : JoinNode,
    "NegativeJoinResult":NegativeJoinResult,
    "NegativeNode"     : NegativeNode,
    "NCCNode"          : NCCNode,
    "NCCPartnerNode"   : NCCPartnerNode,
    "ActionNode"       : ActionNode,
    "ProposedAction"   : ProposedAction
};

module.exports = DataStructures;


});

define('ReteUtilities',['require','exports','module','underscore'],function (require, exports, module) {var _ = require('underscore');
    "use strict";

    /**
       @function relinkToAlphaMemory
       @utility
       @purpose reconnects a joinnode with its alpha memory, once the beta memory is populated
     */
    //reconnect an unlinked join node to its alpha memory when there are
    //wmes in said alpha memory
    var relinkToAlphaMemory = function(node){
        if(node.isJoinNode === undefined && node.isNegativeNode === undefined){
            throw new Error("trying to relink alpha on something other than a join node or negative node");
        }
        
        var ancestor = node.nearestAncestor;
        var indices = node.alphaMemory.children.map(d=>d.id);

        //While the ancestor is a child of the alpha memory
        while(ancestor && indices.indexOf(ancestor.id) === -1){
            //go up an ancestor if it is unlinked to
            ancestor = findNearestAncestorWithAlphaMemory(ancestor,node.alphaMemory.id);
        }
        
        //When finished, if the ancestor exists:
        if(ancestor !== null){
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(ancestor.id);
            //add the node into the child list in front of the ancestor
            node.alphaMemory.children.splice(index,0,node);
        }else{
            //otherwise just add at the end
            node.alphaMemory.children.push(node);
        }

        //remove from the unlinkedChildren Field
        var nodeIndex = node.alphaMemory.unlinkedChildren.map(d=>d.id).indexOf(node.id);
        node.alphaMemory.unlinkedChildren.splice(nodeIndex,1);
        
        
    };

    /**
       @function relinkToBetaMemory
       @utility
       @purpose reconnects a join node to its beta memory, once the alpha memory is populated
     */
    //relink an unlinked join node to its betamemory when there are tokens
    //in said memory
    var relinkToBetaMemory = function(node){
        //remove from the unlinked children list
        //and add it into the children
        var index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
        if(index > -1){
            node.parent.unlinkedChildren.splice(index,1);
            node.parent.children.unshift(node);
        }
    };


    /**
       @function unlinkAlphaMemory
       @purpose if an alpha memory becomes empty, displace all its children temporarily
     */
    var unlinkAlphaMemory = function(alphaMemory){
        //if the alphaMem has no items: UNLINK
        if(alphaMemory.items.length === 0){
            alphaMemory.children.forEach(function(amChild){
                if(amChild.isJoinNode){
                    var index = amChild.parent.children.map(d=>d.id).indexOf(amChild.id);
                    //splice out
                    var removed = amChild.parent.children.splice(index,1);
                    //and store
                    amChild.parent.unlinkedChildren.push(removed[0]);
                }
            });
        }
    };

    
    /**
       @function ifEmptyBetaMemoryUnlink
       @purpose if a beta memory becomes empty, displace all its children temporarily
     */
    //Now Essentially switch on: BetaMemory, NegativeNode,
    //NCCNode, and NCCPartnerNode
    var ifEmptyBetaMemoryUnlink = function(node){
        //BETAMEMORY
        if(node && node.isBetaMemory){
            //and that betaMemory has no other items
            if(node.items.length === 0){
                //for all the node's children
                node.children.forEach(function(jn){
                    if(jn.isJoinNode === undefined){return;}
                    var index = jn.alphaMemory.children.map(d=>d.id).indexOf(jn.id);
                    if(index !== -1){
                        var removed = jn.alphaMemory.children.splice(index,1);
                        //push it in the unlinked children list
                        jn.alphaMemory.unlinkedChildren.push(removed[0]);
                    }
                });
            }
            return true;
        }else{
            return false;
        }        
    };

    /**
       @function ifEmptyNegNodeUnlink
       @purpose if a negative node becomes empty, displace its alpha memory's children
     */
    var ifEmptyNegNodeUnlink = function(node){
        if(node && node.isNegativeNode){
            //with elements
            if(node.items.length === 0){
                //unlink alpha memory
                var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
                var removed = node.alphaMemory.children.splice(index,1);
                node.alphaMemory.unlinkedChildren.push(removed[0]);
            }
        }
    };

    

    /**
       @function compareConstantNodeToTest
       @purpose compare an existing constant test node to a constant test that wants to be built
     */
    //taking an alpha node and a ConstantTest
    var compareConstantNodeToTest = function(node,constantTestSpec){
        if(node.testField !== constantTestSpec.field
           || node.testValue !== constantTestSpec.value){
            return false;
        }
        if(node.operator !== constantTestSpec.operator){
            return false;
        }
        return true;
    };

    /**
       @function compareJoinTests
       @purpose Compare specified join tests, to see if a join node is the same as one needed
    */
    var compareJoinTests = function(firstTestSet,secondTestSet){
        if(!(secondTestSet instanceof Array)){
            secondTestSet = _.pairs(secondTestSet);
        }
        
        if(firstTestSet.length === 0 && secondTestSet.length === 0){
            return true;
        }
        var i = firstTestSet.length -1;
        var j = secondTestSet.length -1;
        while(i >= 0 && j >= 0){
            var ts1 = firstTestSet[i],
                ts2 = secondTestSet[j];
            //console.log("comparing",i,j,"|||",firstTestSet[i][0],secondTestSet[j][0],"|||",firstTestSet[i][1],secondTestSet[j][1]);
            if(firstTestSet[i][0] === secondTestSet[j][0]){
                if(firstTestSet[i][1] === secondTestSet[j][1]){
                    i--; j--;
                }else{
                    return false;
                }
            }else if(firstTestSet[i][0] > secondTestSet[j][0]){
                i--;
            }else if(firstTestSet[i][0] < secondTestSet[j][0]){
                j--;
            }else{
                return false;
            }
        }
        if(i === j && i === -1){
            return true;
        }
        return false;
    };


    var altCompareJoinTests = function(firstTestSet,secondTestSet){
        try{
            //compare lengths
            if(firstTestSet.length !== secondTestSet.length) { throw "unequal lengths"; }
            for(var i = 0; i < firstTestSet.length; i++){
                var fTest = firstTestSet[i],
                    sTest = secondTestSet[i];
                //compare the bound names
                if(fTest[0] !== sTest[0]) { throw "different bound names"; }
            
                //compare the source names
                if(fTest[1][0] !== sTest[1][0]) { throw "different source names"; }
            
                //compare the bind tests
                if(fTest[1][1].length !== sTest[1][1].length) { throw "different binding tests length"; }
                for(var j = 0; fTest[1][1].length; j++){
                    if(fTest[1][1][j][0] !== sTest[1][1][j][0]) { throw "different comp operator"; }
                    if(fTest[1][1][j][1] !== sTest[1][1][j][1]) { throw "different comp value"; }
                }
            }
        }catch(e){
            return false;
        }
        return true;
    };

    
    /**
       @function findNearestAncestorWithAlphaMemory
       @recursive
       @purpose To go up the network, to find appropriate beta network elements linked to the alphamemory
    */
    var findNearestAncestorWithAlphaMemory = function(node,alphaMemory){
        //base conditions:
        if(node.dummy){ return null;}
        if(node.isJoinNode || node.isNegativeNode){
            if(node.alphaMemory.id === alphaMemory.id){
                return node;
            }
        }
        //switch recursion into the partner clause
        if(node.isAnNCCNode){
            return findNearestAncestorWithAlphaMemory(node.partner.parent,alphaMemory);
        }
        //recurse:
        return findNearestAncestorWithAlphaMemory(node.parent,alphaMemory);        
    };

    //--------------------
    var retrieveWMEValueFromDotString = function(wme,dotString){
        //get from the node stored in wme.data the value
        //that the dotString address specifies
        var address = dotString.split("."),
            currLocation = wme.data;
        while(address.length > 0){
            var curr = address.shift();
            if(currLocation[curr] !== undefined){
                currLocation = currLocation[curr];
            }
        }

        //return the final location arrived at
        return currLocation;
    };

    //remove proposed actions from the retenet, and from their owning tokens
    var cleanupInvalidatedActions = function(invalidatedActions){
        if(invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined){
            return;
        }
        var reteNet = invalidatedActions[0].reteNet,
            proposedActions = reteNet.proposedActions,
            idList = invalidatedActions.map(d=>d.id);
        //console.log("Cleaning up:",[idList,invalidatedActions,proposedActions]);
        //filter out the ids from the proposedActions list
        //also removing them from the owning tokens
        proposedActions = _.reject(proposedActions,function(d){
            if(d === undefined) { return true; }
            return idList.indexOf(d.id) !== -1;
        });
        reteNet.proposedActions = proposedActions;
    };


    /**
       @function objDescToObject
       @purpose Take a single object that describes a more complex object,
       and convert it to that more complex object

       @note can work on arbitrary depths, will overwrite primitives if later an object is needed

       ie: {"values.a" : 5, "values.b" : 10,
       "tags.type" : "rule", "tags.character" : "bob"}
       --->
       {"values": {"a": 5, "b": 10},
       "tags" : {"type" : "rule", "character": "bob"}}

     */
    var objDescToObject = function(objDesc,baseObject){
        var newObj = baseObject || {},
            //take the starting object and for all keys
            finalObj = _.keys(objDesc).reduce(function(m,v){
                //split the keys apart
                var keys = v.split(/\./),
                    currObj = m,
                    currKey;
                //add an object for each key
                while(keys.length > 1){
                    currKey = keys.shift();
                    if(currObj[currKey] === undefined
                      || typeof currObj[currKey] !== 'object'){
                        currObj[currKey] = {};
                    }
                    currObj = currObj[currKey];
                }
                currKey = keys.shift();
                currObj[currKey] = objDesc[v];
                return m;
            },newObj);
        return finalObj;
    };

    
    
    //------------------------------
    var moduleInterface = {
        "unlinkAlphaMemory" : unlinkAlphaMemory,
        "relinkToAlphaMemory" : relinkToAlphaMemory,
        "ifEmptyBetaMemoryUnlink" : ifEmptyBetaMemoryUnlink,
        "ifEmptyNegNodeUnlink" : ifEmptyNegNodeUnlink,
        "relinkToBetaMemory" : relinkToBetaMemory,
        "compareJoinTests" : altCompareJoinTests,
        //"compareJoinTests" : compareJoinTests,
        "compareConstantNodeToTest" : compareConstantNodeToTest,
        "findNearestAncestorWithAlphaMemory" : findNearestAncestorWithAlphaMemory,
        "retrieveWMEValueFromDotString" : retrieveWMEValueFromDotString,
        "cleanupInvalidatedActions" : cleanupInvalidatedActions,
        "objDescToObject" : objDescToObject
    };
module.exports = moduleInterface;    


});

define('ReteComparisonOperators',['require','exports','module'],function (require, exports, module) {/**
   @file ReteComparisonOperators
   @purpose To define the possible operators available for constant test nodes
*/

//Define an object of comparisons able to
//be used in constant tests

//See general utils file for converting to string
//TODO: These can be changed to their actual representations, similar to reteArithActions
var ConstantTestOperators = {
    "EQ" : function(a,b){
        return a===b;
    },
    "LT" : function(a,b){
        return a < b;
    },
    "GT" : function(a,b){
        return a > b;
    },
    "LTE" : function(a,b){
        return a <= b;
    },
    "GTE": function(a,b){
        return a >= b;
    },
    "NE" : function(a,b){
        return a !== b;
    }
};

module.exports = ConstantTestOperators;

});

define('ReteTestExecution',['require','exports','module','./ReteDataStructures','underscore','./ReteUtilities','./ReteComparisonOperators'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    ReteComparisonOps = require('./ReteComparisonOperators');


/**
   @function performJoinTests
   @purpose compare a token and wme, using defined bindings from a joinNode
   @return False if no match, dict of all updated bindings otherwise
*/
var performJoinTests = function(joinNode,token,wme){
    var newBindings = {},
        successState = true,
        varRegex = new RegExp(/^\$/);
    //Populate with current bindings from token
    _.keys(token.bindings).forEach(function(key){
        newBindings[key] = token.bindings[key];
    });

    try{
        //add new bindings:
        joinNode.tests.forEach(function(test){
            var newValue = null;
            //retrieve the value
            if(test[1] === "#id" || test[1] === '$id'){
                newValue = wme.id;
            }else{
                newValue = ReteUtil.retrieveWMEValueFromDotString(wme,test[1][0]);
            }
            
            //compare the value for each specified binding test
            var bindingComparisons = test[1][1];
            
            //Compare using any defined binding tests
            bindingComparisons.forEach(function(d){
                var comparator = ReteComparisonOps[d[0]],
                    varName = d[1];
                //if it fails, fail the test
                //use the value in the test, minus the $ at the beginning:
                if(!varRegex.test(varName)) { throw new Error("Non-bound var name"); }
                
                if(!comparator(newValue,newBindings[varName.slice(1)])){
                    throw new Error("Test failed");
                }
            });
            
            if(newBindings[test[0]] === undefined){
                newBindings[test[0]] = newValue;
            }
            if(newBindings[test[0]] !== newValue){
                throw new Error("Test failed");
            }
        });
        
        if(successState){
            return newBindings;
        }else{
            throw new Error("Test failed");
        }
    }catch(e){
        return false;
    }
};


var moduleInterface = {
    "performJoinTests" : performJoinTests,
};
module.exports =  moduleInterface;

});

define('ReteArithmeticActions',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteArithmeticActions
   @purpose to define the arithmetic that an action can perform on a value
*/
var _ = require('underscore');

    "use strict";
    var ArithmeticActions = {
        "+" : function(a,b){
            return a + b;
        },
        "-" : function(a,b){
            return a - b;
        },
        "*" : function(a,b){
            return a * b;
        },
        "/" : function(a,b){
            return a / b;
        },
    };

module.exports = ArithmeticActions;
    


});

define('ReteActions',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {/**
   @file ReteActions
   @purpose Defines action proposals
*/
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');


if(ArithmeticActions === undefined){
    throw new Error("Arithmetic Actions missing");
}

//Action node possible actions:
//Stores both performance functions and proposal functions
//in the form: {name: "", performFunc : func, propseFunc : func }
var ActionInterface = {};

//Performance functions take a retenet, and a payload
//proposal functions are bound to an action description, and take a token and a retenet

//eg: the action asserts a new wme, with an arithmetic action of +2,
//the action has the information (+ 2), the incoming token as the base value to add to.

//Proposal functions return an object of the form:
//{ action: "", payload: {}, (timeData)? }


//** @action assert
ActionInterface.assert = {
    name : "assert",
    proposeFunc : null,
    performFunc : null
};

ActionInterface.assert.proposeFunc = function(token,reteNet){
    //create the data object:
    //initialise from the action's 'values' object
    var newWMEData = _.reduce(_.keys(this.values),function(memo,key){
        var v = this.values[key];
        //if the value starts with # or $, look it up in the token list
        memo[key] = v.match(/^[\$#]/) === null ? v : token.bindings[v.slice(1)];
        return memo;
    },{bindings: {} },this);

    //Then copy in the bindings:
    var newDataPlusBindings = _.reduce(_.keys(token.bindings),function(memo,key){
        memo.bindings[key] = token.bindings[key];            
        return memo;
    },newWMEData);
    
    //perform arithmetic:
    _.keys(this.arithmeticActions).forEach(function(key){
        var newVal = Number(newDataPlusBindings[key]);
        if(isNaN(newVal)) { throw new Error("Arithmetic value should be convertable to a number"); }
        //look up the function:
        //because the representation form is: a : ["+", 5]
        var action = ArithmeticActions[this.arithmeticActions[key][0]];
        newDataPlusBindings[key] = action(newVal,Number(this.arithmeticActions[key][1]));
    },this);

    //todo: allow for importing of other vars as the replacement values?
    _.keys(this.regexActions).forEach(function(key){
        var pair = this.regexActions[key],
            regex = new RegExp(pair[0],pair[1]),
            replaceValue = pair[2].match(/\$/) ? newDataPlusBindings[pair[2].slice(1)] : pair[2];
        newDataPlusBindings[key] = newDataPlusBindings[key].replace(regex,replaceValue);
    },this);
    
    //Expand out to object structure
    //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}
    var complexFormData = ReteUtil.objDescToObject(newWMEData);
    
    //DONT create the wme, just store the data for it
    //To be returned to activateActionNode
    var proposedAction = new RDS.ProposedAction(reteNet,"assert", complexFormData, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;        
};


ActionInterface.assert.performFunc = function(reteNet,proposedAction){
    //check the type matches
    if(proposedAction.actionType !== 'assert') { throw new Error("Expected Assert"); }
    //Perform the action:
    var newWMEID = reteNet.assertWME(proposedAction.payload,proposedAction.retractTime);

    //schedule the retraction:
    if(proposedAction.timing.unperformOffset > 0){
        //schedule a retract, with no invalidate time (its not being proposed)
        //and the perform time being the original actions unperformoffset
        reteNet.addToSchedule(new RDS.ProposedAction(reteNet,"retract",newWMEId,null,reteNet.currentTime,{
            invalidateOffset : null,
            performOffset : proposedAction.timing.unperformOffset,
            unperformOffset : null
        }));
    }
};



//----------------------------------------
//** @action retract
ActionInterface.retract = {
    name : "retract",
    proposeFunc : null,
    performFunc : null,

};

ActionInterface.retract.proposeFunc = function(token,reteNet){
    //get all wmes the token touches:
    var wmes = [];
    var currToken = token;
    while(currToken && currToken.wme !== undefined){
        wmes.push(currToken.wme);
        currToken = currToken.parentToken;
    }

    //get the wme ids to remove:
    var wmeIDs = _.values(token.bindings);

    //filter the wmeList by the wmeIDs:
    var toRetract = _.filter(wmes,function(wme){
        return _.contains(wmeIDs,wme.id);
    });

    //Propose the list of all wmes to retract 
    var proposedAction = new RDS.ProposedAction(reteNet,"retract", toRetract, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;
};

ActionInterface.retract.performFunc = function(reteNet,proposedAction){
    if(proposedAction.actionType !== 'retract') { throw new Error("Expected retract"); }
    if(proposedAction.payload instanceof Array){
        var retractedWMEs = proposedAction.payload.map(d=>reteNet.retractWME(d));
    }else{
        var retractedWME = reteNet.retractWME(proposedAction.payload);
    }
    //do anything with the retracted wme(s)?
};

//--------------------
ActionInterface.addRule = {
    name : "addRule",
    performFunc : null,
    proposeFunc : null
};

//propose takes the token, retrieves existing conditions/actions, or creates new ones
//perform takes the payload, as a rule object, and calls addRule on it

//--------------------
ActionInterface.removeRule = {
    name : "removeRule",
    performFunc : null,
    proposeFunc : null
};

//propose gets the rule id specified and packages it up
//perform calls removeRule on the retrieved rule

module.exports = ActionInterface;


});

define('ReteActivationAndDeletion',['require','exports','module','./ReteDataStructures','./ReteComparisonOperators','./ReteUtilities','./ReteTestExecution','./ReteActions','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ConstantTestOperators = require('./ReteComparisonOperators'),
    ReteUtil = require('./ReteUtilities'),
    ReteTestExecution = require('./ReteTestExecution'),
    PossibleActions = require('./ReteActions'),
    _ = require('underscore');




/**
   @function alphaMemoryActivation
   @purpose stores a wme in an alpha memory
   Trigger an alpha memory with a new wme to store
*/
var alphaMemoryActivation = function(alphaMem,wme){
    var newItem = new RDS.AlphaMemoryItem(wme,alphaMem);
    alphaMem.items.unshift(newItem);
    wme.alphaMemoryItems.unshift(newItem);
    //console.log("AlphaMemory activated:",alphaMem,wme);
    alphaMem.children.forEach(child=>rightActivate(child,wme));
};

/**
   @function constantTestNodeActivation
   @purpose tests a wme against the test in the given node
*/
//Trigger a constant test with a new wme
var constantTestNodeActivation = function(alphaNode,wme){
    //test the wme using the constant test in the node
    var testResult = false;
    if(alphaNode.passThrough){
        testResult = true;
    }else{
        var wmeFieldValue = ReteUtil.retrieveWMEValueFromDotString(wme,alphaNode.testField);
        var value = alphaNode.testValue;
        var operator = alphaNode.operator;
        if(ConstantTestOperators[operator]){
            if(operator !== 'EQ' && operator !== 'NE'){
                testResult = ConstantTestOperators[operator](Number(wmeFieldValue),Number(value));
            }else{
                //console.log("testing:",wmeFieldValue,operator,value,alphaNode,wme);
                testResult = ConstantTestOperators[operator](wmeFieldValue,value);
            }
            
        }
    }
    if(testResult){
        //console.log("successful constant test result",testResult,wme,alphaNode);
        if(alphaNode.outputMemory){
            alphaNodeActivation(alphaNode.outputMemory,wme);
        }
        alphaNode.children.forEach(child=>alphaNodeActivation(child,wme));
    }
    //console.log("ConstantTest Result:",alphaNode,wme,testResult);
    return testResult;
};

/**
   @function alphaNodeActivation
   @utility
   @purpose selects whether to store a wme, or test the wme
*/
//Switchable activation function for alpha network stuff
var alphaNodeActivation = function(alphaNode,wme){
    if(alphaNode.isAlphaMemory){
        alphaMemoryActivation(alphaNode,wme);
    }else if(alphaNode.isConstantTestNode){
        return constantTestNodeActivation(alphaNode,wme);
    }else{
        throw new Error("Unrecognised node:",alphaNode);
    }
};

/**
   @function betaMemoryActivation
   @purpose stores a token in the beta memory
*/
//trigger a beta memory to store a new token
//bindings are from the join node, holding results of the NEW binding tests
//old bindings are still in the token, the constructor of Token will combine the two
//sets of bindings
var betaMemoryActivation = function(betaMemory,token){
    var newToken = token;
    betaMemory.items.unshift(newToken);
    betaMemory.children.forEach(child=>leftActivate(child,newToken));
};


/**
   @function joinNodeLeftActivation
   @purpose given a new token, compares it to all wmes in the related alpha memory
*/
//Trigger a join node with a new token
//will pull all wmes needed from the linked alphaMemory
var joinNodeLeftActivation = function(node,token){
    //If necessary, relink or unlink the
    //parent betamemory or alphamemory
    if(node.parent.items && node.parent.items.length === 1){
        ReteUtil.relinkToAlphaMemory(node);
        if(node.alphaMemory.items.length === 0){
            //unlink beta memory if alphamemory is empty
            var index = node.parent.children.map(d=>d.id).indexOf(node.id);
            var unlinked = node.parent.children.splice(index,1);
            node.parent.unlinkedChildren.push(unlinked[0]);
        }
    }
    //for each wme in the alpha memory,
    //compare using join tests,
    //and pass on successful combinations
    //to beta memory /negative node children
    //to be combined into tokens
    node.alphaMemory.items.forEach(function(item){
        var currWME = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,token,currWME);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(child=>leftActivate(child,token,currWME,joinTestResult));
            
        }
    });//end of looping all wmes in alphamemory
};

/**
   @function joinNodeRightActivation
   @purpose given a new wme, compares it against all tokens in the related beta memory
*/
//Trigger a join node with a new wme
//pulling all necessary tokens from the parent as needed
var joinNodeRightActivation = function(node,wme){
    //relink or unlink as necessary
    if(node.alphaMemory.items.length === 1){
        ReteUtil.relinkToBetaMemory(node);
        if(node.parent.items.length === 0){
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
            var unlinked = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(unlinked[0]);
        }
    }

    //For all tokens, compare to the new wme,
    //pass on successful combinations to betamemory/negative node
    node.parent.items.forEach(function(currToken){
        //console.log("--------\nComparing: ",currToken.bindings,"\n To: ",wme.data,"\n using: ",node.tests);
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(currNode=>leftActivate(currNode,currToken,wme,joinTestResult));
        }
    });
};


/**
   @function activateActionNode
   @purpose given a new token, activates any stored actions necessary
*/
var activateActionNode = function(actionNode,token){
    //get the actions the node embodies:
    var boundActionFunctions = actionNode.boundActions,
        //apply the token to each of the actions
        newProposedActions = boundActionFunctions.map(d=>d(token,actionNode.reteNet)),
        newProposedActionIds = newProposedActions.map(d=>d.id);
    
    //store the proposed actions in the reteNet.potential actions
    //and also tie all the actions that fire together by their ids
    //ie: {action:"assert",payload:wme}
    //see RDS.ProposedAction for details
    newProposedActions.forEach(function(d){
        d.parallelActions = newProposedActionIds;
        actionNode.reteNet.proposedActions[d.id] = d;
    });
};


/**
   @function leftActivate
   @utility
   @purpose selects what node to activate as appropriate, for a new token
*/
//Utility leftActivation function to call
//whichever specific type is needed
var leftActivate = function(node,token,wme,joinTestResults){
    //Construct a new token if supplied the correct
    //parameters
    if(joinTestResults && wme){
        token = new RDS.Token(token,wme,node,joinTestResults);
        //owning node is the node going into, rather than coming out of
    }
    //Activate the node:
    //Essentially a switch of:
    //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode,
    //and Action
    if(node.__isDummy){
        //pass on, because this is a test
    }else if(node.isBetaMemory){
        betaMemoryActivation(node,token);
    }else if(node.isJoinNode){
        joinNodeLeftActivation(node,token);
    }else if(node.isNegativeNode){
        negativeNodeLeftActivation(node,token);
    }else if(node.isAnNCCNode){
        nccNodeLeftActivation(node,token);
    }else if(node.isAnNCCPartnerNode){
        nccPartnerNodeLeftActivation(node,token);
    }else if(node.isActionNode){
        activateActionNode(node,token);
    }else{
        throw new Error("Unknown node type leftActivated");
    }
    return token;
};

/**
   @function rightActivate
   @purpose selects what node to activate, given a new wme
*/
var rightActivate = function(node,wme){
    if(node.isJoinNode){
        joinNodeRightActivation(node,wme);
    }else if(node.isNegativeNode){
        negativeNodeRightActivation(node,wme);
    }else{
        throw new Error("Tried to rightActivate Unrecognised node");
    }
};

/**
   @function negativeNodeLeftActivation
*/
//Trigger a negative node from a new token
//brings in bindings, creates a new token as necessary,
//combining bindings to.
var negativeNodeLeftActivation = function(node,newToken){
    //Relink
    //console.log("Negative node left activation");
    if(node.items.length === 0){
        ReteUtil.relinkToAlphaMemory(node);
    }
    node.items.unshift(newToken);

    node.alphaMemory.items.forEach(function(item){
        var currWme = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,newToken,currWme);
        if(joinTestResult){
            //adds itself to the token and
            //wme as necessary to block the token
            var joinResult = new RDS.NegativeJoinResult(newToken,currWme);
        }
    });

    //if no wmes block the token, pass it on down the network
    if(newToken.negJoinResults.length === 0){
        node.children.forEach(child=>leftActivate(child,newToken));
    }
    
};

/**
   @function negativeNodeRightActivation
*/
//trigger a negative node from a new wme,
//getting all tokens stored, comparing to the wme.
//any that the wme blocks, gets an additional negative Join result
//any that don't get blocked should already have been activated
var negativeNodeRightActivation = function(node,wme){
    console.log("Negative node right activation");
    node.items.forEach(function(currToken){
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            if(currToken.negJoinResults.length === 0){
                //todo: fix this
                var invalidatedActions = deleteDescendentsOfToken(currToken);
                ReteUtil.cleanupInvalidatedActions(invalidatedActions);
            }
            //Adds itself to the currToken and wme as
            //necessary
            var negJoinResult = new RDS.NegativeJoinResult(currToken,wme);
        }
    });
};

/**
   @function nccNodeLeftActivation
*/
//from a new token, trigger the subnetwork?
var nccNodeLeftActivation = function(nccNode,token){
    //Create and store the incoming token from prior join node
    if(nccNode.isAnNCCNode === undefined){
        throw new Error("nccNodeLeftActivation should be on an NCCNode");
    }
    if(token.isToken === undefined){
        throw new Error("nccNodeLeftActivation should be on a token");
    }
    var newToken = token;
    nccNode.items.unshift(newToken);

    //the partner's network MUST fire before the nccnode
    //hence this. all the new results' in the partners new result buffer,
    //are from the same origin as token
    //if there are new results to process:
    while(nccNode.partner && nccNode.partner.newResultBuffer.length > 0){
        var newResult = nccNode.partner.newResultBuffer.pop();
        //add the subnetworks result as a blocking token
        newToken.nccResults.unshift(newResult);
        //set the subnetwork result to have its parent as the new token
        newResult.parentToken = newToken;
    }

    //if the new token has no blocking tokens,
    //continue on
    if(newToken.nccResults.length === 0){
        nccNode.children.forEach(child=>leftActivate(child,newToken));
    }
};

/**
   @function nccPartnerNodeLeftActivation
*/
//the nccPartnerNode is activated by a new token from the subnetwork
//figure out who owns this new token from the main (positive) network
var nccPartnerNodeLeftActivation = function(partner,token){
    //the partner's ncc
    var nccNode = partner.nccNode,
        //the token created in left activate, with partner as owner
        newToken = token,
        ownersToken = token.parentToken,//the prior token
        ownersWme = token.wme,//the prior wme
        owner;

    
    for(var i = 1; i < partner.numberOfConjuncts; i++){
        //go up the owner chain
        ownersToken = ownersToken.parentToken;
        ownersWme = ownersWme.wme;
    }

    //find an owner in the ncc node's memory to link to
    if(nccNode !== undefined){
        var possible_tokens = nccNode.items.map(function(d){
            if(d.parentToken.id === ownersToken.id && d.wme.id === ownersWme.id){
                return d;
            }}).filter(d=> d !== undefined);
        owner = possible_tokens[0];
    }

    //link the owner and the new token
    if(owner !== undefined){
        //the necessary owner exists in the nccNode,
        //so update it:
        owner.nccResults.unshift(newToken);
        newToken.parent = owner;
        var invalidatedActions = deleteDescendentsOfToken(owner);
        ReteUtil.cleanupInvalidatedActions(invalidatedActions); 
    }else{        
        //else no owner: add to temp buffer to wait for the ncc node to be activated
        partner.newResultBuffer.unshift(newToken);
    }
};


/**
   @function activateIfNegatedJRIsUnblocked
*/
var activateIfNegatedJRIsUnblocked = function(nJR){
    var currJoinResult = nJR;
    //if the negation clears, activate it
    if(currJoinResult.owner.negJoinResults.length === 0){
        currJoinResult.owner.owningNode.children.forEach(child=>leftActivate(child,currJoinResult.owner));
    }
};


/**
   @function removeAlphaMemoryItemsForWME
   @purpose to remove a wme from all alpha memories it is stored in
   @postCondition wme.alphaMemoryItems is empty
*/
var removeAlphaMemoryItemsForWME = function(wme){
    //remove alpha memory items
    wme.alphaMemoryItems.forEach(function(item){
        //unlink the alphamemory from the item
        var index = item.alphaMemory.items.map(d=>d.id).indexOf(item.id);
        if(index !== -1){ item.alphaMemory.items.splice(index,1);}
        //unlink the alphaMemory itself if it is now empty
        //will unlink if am.items.length === 0
        ReteUtil.unlinkAlphaMemory(item.alphaMemory);
        //clear the item's links
        item.alphaMemory = undefined;
        item.wme = undefined;
    });
    //completely clear am items:
    wme.alphaMemoryItems = [];
};

/**
   @function deleteAllTokensForWME
   @purpose to cleanup all tokens a wme is part of
*/
var deleteAllTokensForWME = function(wme){
    var invalidatedActions = [];
    //For all tokens
    while(wme.tokens.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(wme.tokens[0]));
    }

    return invalidatedActions;
    
};

/**
   @function deleteAllNegJoinResultsForWME
   @purpose For negative conditions, discount the wme as a block
*/
var deleteAllNegJoinResultsForWME = function(wme){
    //unlink the negative Join results in the owning token
    wme.negJoinResults.forEach(function(jr){
        var index = jr.owner.negJoinResults.map(j=>j.id).indexOf(jr.id);
        if(index !== -1){
            jr.owner.negJoinResults.splice(index,1);
        }
        activateIfNegatedJRIsUnblocked(jr);
        //remove internal references:
        jr.owner = undefined;
        jr.wme = undefined;
    });
    //completely clear negjoinresults
    wme.negJoinResults = [];
};


/**
   @function removeNegJoinResultsForToken
   @purpose to delete any blocked tokens in negative conditions
*/
var removeNegJoinResultsForToken = function(token){
    //remove Negative join results
    token.negJoinResults.forEach(function(jr){
        var index = jr.wme.negJoinResults.map(d=>d.id).indexOf(jr.id);
        if(index !== -1){
            jr.wme.negJoinResults.splice(index,1);
        }
        //clear the references
        jr.wme = undefined;
        jr.token = undefined;
    });
    token.negJoinResults = [];
};


/**
   @function removeTokenFromNode
   @purpose To remove a token from whatever node created it
*/
//Now the utility functions for deleteing token:
var removeTokenFromNode = function(token){
    //Deal with if the owning node is NOT an NCC
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode === undefined
       && token.owningNode.isMemoryNode){
        //by removing the token as an element in that node
        var index = token.owningNode.items.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.owningNode.items.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromWME
   @purpose to clean a token up, removing it from any WME references
*/
var removeTokenFromWME = function(token){
    //remove the token from the wme it is based on
    if(token.wme && token.wme.tokens){
        var index = token.wme.tokens.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.wme.tokens.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromParentToken
   @purpose cleanup the token from its parents list
*/
var removeTokenFromParentToken = function(token){
    //Remove the token from it's parent's child list
    if(token && token.parentToken){
        var index = token.parentToken.children.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.parentToken.children.splice(index,1);
        }
    }
};




/*
  Removes DOWNWARD links, but leaves UPWARD links intact
  Do a number of things:
  clean up tokens stored in a node
  remove any reference to the node from a connected alpha
  remove any reference to the node from a parent

  +: call recursively on any parent that has no children
*/

/**
   @function deleteNodeAndAnyUnusedAncestors
   @purpose cleanup an unused node and any parent nodes that are also unused once this node is gone.
*/
var deleteNodeAndAnyUnusedAncestors = function(node){
    var index,
        invalidatedActions = [];
    //if NCC, delete partner to
    if(node.isAnNCCNode){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.partner));
    }
    
    //clean up tokens
    if(node.isBetaMemory){
        while(node.items.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }
    if(node.isAnNCCPartnerNode){
        while(node.newResultBuffer.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }

    //clean up any associated alphamemory
    if(node.isJoinNode || node.isNegativeNode && node.alphaMemory){
        index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
        if(index > -1){
            node.alphaMemory.children.splice(index,1);
            node.alphaMemory.referenceCount--;
        }
        if(node.alphaMemory.referenceCount === 0){
            //TODO: write delete alpha memory
            //deleteAlphaMemory(node.alphaMemory);
        }
    }
    
    //remove the node from its parent
    if(node.parent){
        //check the child list:
        index = node.parent.children.map(d=>d.id).indexOf(node.id);
        if(index !== -1){                            
            node.parent.children.splice(index,1);
        }else{
            //check the unlinked children list:
            index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
            if(index !== -1){
                node.parent.unlinkedChildren.splice(index,1);
            }
        }
    }

    //delete parent node if its got no children
    if(node.parent && node.parent.children.length === 0
       && node.parent.unlinkedChildren
       && node.parent.unlinkedChildren.length === 0){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.parent));
    }
    //deallocate memory for none

    return invalidatedActions;
    
};


/**
   @function deleteDescendentsOfToken
   @purpose simplification of removing children of a token, but not the token itself
   @utility
*/
//utility function to delete all descendents without deleting the token
var deleteDescendentsOfToken = function(token){
    var invalidatedActions = [];
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    return invalidatedActions;
};


/**
   @function deleteTokenAndDescendents
   @purpose To remove a token and clean it 
   delete a token and all the tokens that rely on it
   a bit of a frankenstein. Deletes the token,
   deletes descendents, but also sets and cleans up 
   left unlinking of join nodes, AND
   activates NCC's that are no longer blocked
*/
var deleteTokenAndDescendents = function(token){
    var invalidatedActions = [];
    
    //Recursive call:
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }

    //Base Cases:
    //remove memory items
    removeTokenFromNode(token);
    removeTokenFromWME(token);
    removeTokenFromParentToken(token);
    
    ReteUtil.ifEmptyBetaMemoryUnlink(token.owningNode);
    ReteUtil.ifEmptyNegNodeUnlink(token.owningNode,token.id);

    removeNegJoinResultsForToken(token);

    cleanupNCCResultsInToken(token);
    cleanupNCCPartnerOwnedToken(token);
    
    if(token && token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken.nccResults.length === 0){
        //Activate newly unblocked Token
        //todo: should this be nccnode AND/OR negNode?
        token.owningNode.nccNode.children.forEach(d=>leftActivate(d,token.parentToken));
    }

    //get the queued actions linked with the token, and return them for cleanup
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    
    return invalidatedActions;
};

/**
   @function cleanupNCCResultsInToken
*/
var cleanupNCCResultsInToken = function(token){
    //NCCNODE
    if(token && token.owningNode && token.owningNode.isAnNCCNode){
        //for all the nccResult tokens, delete them
        token.nccResults.forEach(function(nccR){
            //remove the nccR token from its linked wme
            if(nccR.wme){
                var index = nccR.wme.tokens.map(d=>d.id).indexOf(nccR.id);
                if(index !== -1){
                    nccR.wme.tokens.splice(index,1);
                }
            }
            if(nccR.parent){
                //remove the token from it's parent
                var nccRindex = nccR.parent.children.map(d=>d.id).indexOf(nccR.id);
                if(nccRindex !== -1){
                    nccR.parent.children.splice(nccRindex,1);
                }
            }
        });
        //clear the nccResults
        token.nccResults = [];
        return true;
    }else{
        return false;
    }
};

/**
   @function cleanupNCCPartnerOwnedToken
*/
var cleanupNCCPartnerOwnedToken = function(token){
    //NCCPARTNERNODE
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken){
        //remove from owner.nccResults:
        var index = token.parentToken.nccResults.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.parentToken.nccResults.splice(index,1);
        }
        return true;
    }else{
        return false;
    }
};



var moduleInterface = {
    "deleteDescendentsOfToken" : deleteDescendentsOfToken,
    "removeAlphaMemoryItemsForWME" : removeAlphaMemoryItemsForWME,
    "deleteAllTokensForWME" : deleteAllTokensForWME,
    "deleteAllNegJoinResultsForWME" : deleteAllNegJoinResultsForWME,
    "deleteNodeAndAnyUnusedAncestors" : deleteNodeAndAnyUnusedAncestors,
    "leftActivate" : leftActivate,
    "rightActivate" : rightActivate,
    "alphaNodeActivation" : alphaNodeActivation,
    "activateIfNegatedJRIsUnblocked" : activateIfNegatedJRIsUnblocked,
};
module.exports = moduleInterface;

});

define('ReteNetworkBuilding',['require','exports','module','./ReteDataStructures','./ReteUtilities','./ReteActivationAndDeletion','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ReteUtil = require('./ReteUtilities'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    _ = require('underscore');


/**
   @function buildOrShareNetworkForConditions
   @purpose to add all given conditions to the network
*/
var buildOrShareNetworkForConditions = function(parent,conditions,rootAlpha,allNodes,reteNet){
    var currentNode = parent;
    var alphaMemory;
    //for each condition
    conditions.forEach(function(condition){
        if(condition.tags.type !== 'condition' && condition.tags.type !== 'negConjCondition'
           && condition.tags.type !== 'negCondition' && condition.tags.type !== 'rule'){
            throw new Error("Inappropriate condition format");
        }
        //get the binding tests for join nodes
        var tests = _.pairs(condition.bindings);
        
        if(condition.tags.isPositive !== undefined){
            //Build a positive condition:
            currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareJoinNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNegative !== undefined){
            //Build a negative condition:
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareNegativeNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNCCCondition !== undefined){
            //Build a Negated Conjunctive Condition
            currentNode = buildOrShareNCCNodes(currentNode,condition,rootAlpha,allNodes,reteNet);
        }else if(condition.tags.type === 'rule'){
            //for using other rules as composable conditions
            var ruleConditions = _.keys(condition.conditions).map(d=>allNodes[d]);
            currentNode = buildOrShareNetworkForConditions(currentNode,ruleConditions,rootAlpha,allNodes,reteNet);
        }else{
            console.error("Problematic Condition:",condition);
            throw new Error("Unrecognised condition type");
        }
    });
    
    //Everything is build, tack on a final memory and return that
    //to have action connected to.
    var finalBetaMemory = buildOrShareBetaMemoryNode(currentNode,reteNet);
    return finalBetaMemory;
};

/**
   @function buildOrShareConstantTestNode
   @purpose Reuse, or create a new, constant test node, for the given test
*/
var buildOrShareConstantTestNode = function(parent,constantTestSpec,reteNet){
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var node = children[i];
        if(ReteUtil.compareConstantNodeToTest(node,constantTestSpec)){
            return node;
        }
    }
    //No existing, create a new node:
    var newAlphaNode = new RDS.AlphaNode(parent,constantTestSpec);
    reteNet.storeNode(newAlphaNode);
    return newAlphaNode;
};


/**
   @function buildOrShareAlphaMemory
   @purpose Create alpha network as necessary, stick an alpha memory on the end
   @reminder Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}
*/
var buildOrShareAlphaMemory = function(condition,root,allNodes,reteNet){
    var currentNode = root,
        constantTests = condition.constantTests;//[{field:,op:,value:}]
    
    currentNode = constantTests.reduce(function(m,v){
        return buildOrShareConstantTestNode(m,v,reteNet);
    },currentNode);
    
    //see if there is an existing memory for this condition.
    //if so, return existing alphamemory
    if(currentNode.outputMemory !== undefined){
        return currentNode.outputMemory;
    }
    //else: create the alpha memory
    //ctor will update the current node's outputMemory field
    var newAlphaMemory = new RDS.AlphaMemory(currentNode);
    //run wmes in working memory against the alpha network
    reteNet.storeNode(newAlphaMemory);
    return newAlphaMemory;
};

/**
   @function buildOrShareBetaMemoryNode
   @purpose given a node (ie: join), stick a betamemory on it as a child
*/
var buildOrShareBetaMemoryNode = function(parent,reteNet){
    //if passed in the dummy top node, return it:
    if(parent.isBetaMemory === true){
        return parent;
    }
    
    //if theres an available beta memory to use,
    //return that
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var child = children[i];
        if(child.isBetaMemory){
            return child;
        }
    }
    //else: create a new beta memory
    //ctor should update  parent's children
    var newBetaMemory = new RDS.BetaMemory(parent);
    //update it with matches
    updateNewNodeWithMatchesFromAbove(newBetaMemory);
    reteNet.storeNode(newBetaMemory);
    //return new beta memory
    return newBetaMemory;
};




/**
   @function buildOrShareJonNode
   @purpose To reuse, or create a new, join node linking an alpha memory and betamemory
*/
var buildOrShareJoinNode = function(parent,alphaMemory,tests,reteNet){
    //convert tests if necessary:
    if(!(tests instanceof Array)){
        tests = _.pairs(tests);
    }
    
    //see if theres a join node to use already
    var allChildren = parent.children.concat(parent.unlinkedChildren);
    for(var i = 0; i < allChildren.length; i++){
        var child = allChildren[i];
        if(child.isJoinNode && child.alphaMemory.id === alphaMemory.id && ReteUtil.compareJoinTests(child.tests,tests)){
            //return it
            return child;
        }
    }
    //else: create a new join node
    //increment alphamemories reference count in the constructor
    var newJoinNode = new RDS.JoinNode(parent,alphaMemory,tests);
    //set the nearest ancestor
    newJoinNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);

    //if either parent memory is empty, unlink
    if(parent.items.length === 0){
        //BETA IS EMPTY: UNLINK RIGHT
        var index = alphaMemory.children.map(d=>d.id).indexOf(newJoinNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.unshift(removed[0]);
    }else if(alphaMemory.items.length === 0){
        //ALPHA IS EMPTY: UNLINK LEFT
        var newNodeIndex = parent.children.map(d=>d.id).indexOf(newJoinNode.id),
            removedNode = parent.children.splice(newNodeIndex,1);
        parent.unlinkedChildren.unshift(removedNode[0]);
    }
    //return new join node
    reteNet.storeNode(newJoinNode);
    
    return newJoinNode;
};

/**
   @function buildOrShareNegativeNode
   @purpose To reuse, or build a new, negative node
*/
var buildOrShareNegativeNode = function(parent,alphaMemory,tests,reteNet){
    if(!(tests instanceof Array)) { tests = _.pairs(tests); }
    //see if theres an existing negative node to use
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i ++){
        var child = children[i];
        if(child.isNegativeNode
           && child.alphaMemory.id === alphaMemory.id
           && ReteUtil.compareJoinTests(child.tests,tests)){
            return child;
        }
    }
    var newNegativeNode = new RDS.NegativeNode(parent,alphaMemory,tests);
    newNegativeNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);
    //update with matches
    updateNewNodeWithMatchesFromAbove(newNegativeNode);
    //unlink if it has no tokens
    if(newNegativeNode.items.length === 0){
        var index = alphaMemory.children.map(d=>d.id).indexOf(newNegativeNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.push(removed[0]);
    }
    //return new negative node

    reteNet.storeNode(newNegativeNode);
    return newNegativeNode;
};

/**
   @function buildOrShareNCCNodes
   @purpose construction of NCCConditions
*/
var buildOrShareNCCNodes = function(parent,condition,rootAlpha,allNodes,reteNet){
    if(condition.tags.isNCCCondition === undefined){
        throw new Error("BuildOrShareNCCNodes only takes NCCCondition");
    }
    //build a network for the conditions
    var conditions = _.keys(condition.conditions).map(d=>allNodes[d]),
        //build the subnetwork
        bottomOfSubNetwork = buildOrShareNetworkForConditions(parent,conditions,rootAlpha,allNodes,reteNet);
    //find an existing NCCNode with partner to use
    for(var i = 0; i < parent.children.length; i++){
        var child = parent.children[i];
        if(child.isAnNCCNode && child.partner.parent.id === bottomOfSubNetwork.id){
            return child;
        }
    }
    
    //else: build NCC and Partner nodes
    var newNCC = new RDS.NCCNode(parent),
        newNCCPartner = new RDS.NCCPartnerNode(bottomOfSubNetwork,condition.conditions.length);

    newNCC.partner = newNCCPartner;
    newNCCPartner.nccNode = newNCC;
    //update NCC
    updateNewNodeWithMatchesFromAbove(newNCC);
    //update partner
    updateNewNodeWithMatchesFromAbove(newNCCPartner);

    reteNet.storeNode(newNCC);
    reteNet.storeNode(newNCCPartner);
    
    return newNCC;
};


/**
   @function updateNewNodeWithMatchesFromAbove
   @purpose pulls tokens down from parent upon new creation
*/
//essentially a 4 state switch:
//betaMemory, joinNode, negativeNode, NCC
var updateNewNodeWithMatchesFromAbove = function(newNode){
    var i, token;
    var parent = newNode.parent;
    if(parent.isBetaMemory){
        for(i in parent.items){
            ReteActivationsAndDeletion.leftActivate(newNode,parent.items[i]);
        }
    }else if(parent.isJoinNode){
        var savedChildren = parent.children,
            items = _.values(parent.alphaMemory.items);
        parent.children = [newNode];
        for(i = 0; i < items.length; i++){
            var item = items[i];
            ReteActivationsAndDeletion.rightActivate(parent,item.wme);
        }
        parent.children = savedChildren;
    }else if(parent.isNegativeNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = items[i];
            if(token.negJoinResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }else if(parent.isAnNCCNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = parent.items[i];
            if(token.nccResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }
};



var moduleInterface = {
    "buildOrShareNetworkForConditions" : buildOrShareNetworkForConditions,
};
module.exports =  moduleInterface;


});

define('RuleCtors',['require','exports','module'],function (require, exports, module) {//Ctors for Rules

/**
   Rule Ctor. Holds conditions and actions
*/
var nextId = 0;

var Rule = function(name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { type : "rule" };
    this.conditions = {};
    this.actions = {};
};

//testsAndBindings = { tests : [ [var,op,val]...], bindings : [ [var,val,[op,var]]] }
Rule.prototype.newCondition = function(type,testsAndBindings){
    var newCondition = new Condition(type);
    //Add all tests
    testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    this.addCondition(newCondition);
    return this;
};

//valuesArithRegexsAndTiming = { values : [], arith : [], regexs : [], timing : [] }
Rule.prototype.newAction = function(type,name,valuesArithRegexsAndTiming){
    var newAction = new Action(type,name);
    valuesArithRegexsAndTiming.values.forEach(d=>newAction.addValue(...d));
    valuesArithRegexsAndTiming.arith.forEach(d=>newAction.addArithmetic(...d));
    valuesArithRegexsAndTiming.regexs.forEach(d=>newAction.addRegex(...d));
    newAction.addTiming(...valuesArithRegexsAndTiming.timing);
    this.addAction(newAction);
    return this;
};

Rule.prototype.addCondition = function(condition){
    this.conditions[condition.id] = condition;
    return this;
};

Rule.prototype.addAction = function(action){
    this.actions[action.id] = action;
    return this;
};

/**
   Condition Ctor. Holds tests, bindings, and other conditions
 */
var Condition = function(type){
    this.id = nextId++;
    type = type === undefined ? "condition" : type;
    switch(type){
    case "condition":
        this.tags = { type : "condition",
                      isPositive : true };
        break;
    case "negCondition":
        this.tags = { type : "condition",
                      isNegative : true };
        break;
    case "negConjCondition":
        this.tags = { isNCCCondition : true,
                      type : "negConjCondition" };
        break;
    default:
        throw new Error("Unrecognised condition");
    };
    this.constantTests = [];
    this.bindings = {};
    this.conditions = {};    
};

Condition.prototype.addTest = function(field,op,val){
    this.constantTests.push({
        field : field,
        operator : op,
        value : val
    });
    return this;
};

Condition.prototype.addBinding = function(boundName,dataName,tests){
    //tests as pairs of op and value/boundName
    this.bindings[boundName] = [dataName,tests];
};

Condition.prototype.newCondition = function(type,testsAndBindings){
    if(this.type !== 'negConjCondition') { throw new Error("Only NCC's can have sub conditions"); }
    var newCondition = new Condition(type);
    testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    this.conditions[newCondition.id] = newCondition;
}

/**
   Action constructor, defines data/values to put in a new wme,
   arithmetic and regex actions to apply to those values
 */
var Action = function(actionType,name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { actionType : actionType || "assert" };
    this.values = {};
    this.arithmeticActions = {};
    this.regexActions = {};
    //Specify the timing of the proposed action to create:
    this.timing = {
        invalidateOffset : 0,
        performOffset : 0,
        unperformOffset : 0
    }
};

Action.prototype.addValue = function(varName,value){
    this.values[varName] = value;
    return this;
};

Action.prototype.addArithmetic = function(varName,op,value){
    this.arithmeticActions[varName] = [op,value];
    return this;
}

Action.prototype.addRegex = function(varName,regex,options,replaceValue){
    this.regexActions[varName] = [regex,options,replaceValue];
    return this;
};

Action.prototype.addTiming = function(invalid,perform,unperform){
    this.timing = {
        invalidateOffset : invalid,
        performOffset : perform,
        unperformOffset : unperform
    };
    return this;
};

module.exports = {
    Rule : Rule,
    Condition : Condition,
    Action : Action
};

});

define('ReteClassInterface',['require','exports','module','underscore','./ReteDataStructures','./ReteNetworkBuilding','./ReteActivationAndDeletion','./ReteUtilities','./RuleCtors','./ReteActions','./ReteComparisonOperators','./ReteArithmeticActions'],function (require, exports, module) {/**
   @file ReteClassInterface
   @purpose Defines a class based ReteNet interface
 */

var _ = require('underscore'),
    RDS = require('./ReteDataStructures'),
    ReteNetworkBuilding = require('./ReteNetworkBuilding'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    ReteUtil = require('./ReteUtilities'),
    RuleCtors = require('./RuleCtors'),
    ReteActions = require('./ReteActions'),
    ComparisonOperators = require('./ReteComparisonOperators'),
    ArithmeticOperators = require('./ReteArithmeticActions');


/**
   @data ReteNet
   @purpose A Data structure to hold what you need to start a retenet.
*/
var ReteNet = function(){
    this.dummyBetaMemory = new RDS.BetaMemory();
    this.rootAlpha = new RDS.AlphaNode();

    //To store proposal functions and performance actions
    //Each element of form {name: "",performFunc : func, proposeFunc : func };
    this.actionFunctions = ReteActions;

    //RuleCtor storage
    this.RuleCtors = RuleCtors;
    //Comparison operators
    this.ComparisonOperators = ComparisonOperators;
    //Arithmetic Operators:
    this.ArithmeticOperators = ArithmeticOperators;
    
    //DataStructures
    this.DataStructures = RDS;
    
    
    //Actions indexed by rule node id:
    this.actions = [];
    //WMEs indexed by id:
    this.allWMEs = [];

    //Actions whose conditions are satisfied, indexed by id
    this.proposedActions = [];
    //Actions that were chosen to be performed
    this.enactedActions = [];

    //Storage of internal nodes:
    this.allReteNodes = {};
    this.allReteNodesByType = {
        "constantTests" : {},
        "alphaMemories" : {},
        "betaMemories" : {},
        "joinNodes" : {},
        "negativeNodes" : {},
        "nccNodes" : {},
        "nccPartnerNodes" : {},
        "actionNodes" : {},
    };
    

    this.currentTime = 1;
    //Schedule Actions:
    this.schedule = {
        assertions : [],
        retractions : [],
        modifications: []
    };

};

ReteNet.prototype.storeWME = function(wme){
    this.allWMEs[wme.id] = wme;
};


//Clear the record of actions that have been performed
ReteNet.prototype.clearHistory = function(){
    this.enactedActions = [];
};

//Clear the list of proposed actions
ReteNet.prototype.clearProposedActions = function(){
    this.proposedActions = [];
};

//Assert Immediately
ReteNet.prototype.assertWME = function(wme){
    //console.log("ASSERTING:",wme);
    if(wme.isWME === undefined || wme.id === undefined){
        wme = new RDS.WME(wme,this.currentTime);
        this.storeWME(wme);
    }
    //Actually push the wme into the net
    ReteActivationsAndDeletion.alphaNodeActivation(this.rootAlpha,wme);
    return wme.id;
};

//Retract Immediately
ReteNet.prototype.retractWME = function(wme){
    //console.log("retracting immediately:",wme);
    //if not given the wme directly
    if(wme.isWME === undefined){
        //if given a wme id
        if(Number.isInteger(wme) && this.allWMEs[wme] !== undefined){
            wme = this.allWMEs[wme];
            //if given a graph node with a related wme
        }else if(wme.wmeId !== undefined && this.allWMEs[wme.wmeId] !== undefined){
            console.log("Retrieving wme using wmeId:",wme.wmeId);
            wme = this.allWMEs[wme.wmeId];
        }else{
            console.log("Unknown:",wme);
            throw new Error("Unknown wme to retract");
        }
    }
    //console.log("Retracting:",wme);
    ReteActivationsAndDeletion.removeAlphaMemoryItemsForWME(wme);
    var invalidatedActions = ReteActivationsAndDeletion.deleteAllTokensForWME(wme);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
    ReteActivationsAndDeletion.deleteAllNegJoinResultsForWME(wme);
    //Record when the wme was retracted
    wme.lifeTime[1] = this.currentTime;
    return wme;
};


//Modify immediately
ReteNet.prototype.modifyWME = function(wme,modifyFunction){
    var retractedWME = this.retractWME(wme),
        data = retractedWME.data,
        modifiedData = modifyFunction(data);
    if(modifiedData === undefined || modifiedData === null) {
        throw new Error("Modify function must return the new data");
    }
    return this.assertWME(modifiedData);
    
};

//Schedule an action by it's ID, ALSO scheduling any parallel actions
ReteNet.prototype.scheduleAction = function(actionId){
    if(this.proposedActions[actionId] === undefined){
        throw new Error("Invalid action specified");
    }
    var action = this.proposedActions[actionId],
        parallelActions = action.parallelActions.map(d=>this.proposedActions[d]);

    this.addToSchedule(action);
    parallelActions.forEach(d=>this.addToSchedule(d));
    
};

//Utility method to add an action object
ReteNet.prototype.addToSchedule = function(action){
    if(action.actionType === undefined || action.payload === undefined || action.timing === undefined){
        throw new Error("Scheduling action failure");
    }
    if(this.schedule[action.actionType] === undefined){
        this.schedule[action.actionType] = [];
    }
    var performTime = this.currentTime + action.timing.performOffset;
    if(this.schedule[action.actionType][performTime] === undefined){
        this.schedule[action.actionType][performTime] = [];
    }
    this.schedule[action.actionType][performTime].push(action);
    //Action is no longer proposed, so remove it from the token
    action.token.proposedActions = _.reject(action.token.proposedActions,d=>d.id===action.id);
};

//Step Time forward
ReteNet.prototype.stepTime = function(){
    //get all actions scheduled at the current timepoint
    var actions = _.values(this.schedule),
        actionsForTimePoint = _.flatten(actions.map(d=>d[this.currentTime]).reject(d=>d===undefined));
    //perform those actions
    actionsForTimePoint.forEach(function(d){
        var performanceFunction = this.actionFunctions(d.actionType).performFunc;
        performanceFunction(this,d.payload);
        this.enactedActions.push(d);
    },this);

    //todo: remove performed actions from proposed action list
    
    //cleanup invalidated actions
    this.proposedActions = _.reject(this.proposedActions,d=>d.timing.invalidateTime === this.currentTime);
    
    this.currentTime++;
};

//Add a rule
ReteNet.prototype.addRule = function(ruleId,components){
    if(ruleId instanceof Array){
        return ruleId.map(d=>this.addRule(d,components));
    }
    if(ruleId instanceof this.RuleCtors.Rule){
        var convertedComponents = this.convertRulesToComponents(ruleId);
        return this.addRule(ruleId.id,convertedComponents);
    }
    //-----------
        //Add a single rule:
    if(!Number.isInteger(ruleId) || components[ruleId] === undefined){
        throw new Error("Unrecognised rule id specified");
    }
    var rule = components[ruleId],
        conditions = _.keys(rule.conditions).map(d=>components[d]),
        //build network with a dummy node for the parent
        finalBetaMemory = ReteNetworkBuilding.buildOrShareNetworkForConditions(this.dummyBetaMemory,conditions,this.rootAlpha,components,this),
        //Get the action descriptions that are triggered by the rule:
        actionDescriptions = _.keys(rule.actions).map(d=>components[d]),
        //Bind proposalFuncs with actionDescriptions
        boundActionDescriptions = actionDescriptions.map(function(d){
            if(this.actionFunctions[d.tags.actionType] === undefined){
                throw new Error("Unrecognised action type");
            }
            return _.bind(this.actionFunctions[d.tags.actionType].proposeFunc,d);
        },this),
        //Create the action, with the bound action functions
        ruleAction = new RDS.ActionNode(finalBetaMemory,actionDescriptions,boundActionDescriptions,rule.name,this);

    //Add the bound actions into the action node:
    ruleAction.boundActions = boundActionDescriptions;
    this.actions[rule.id] = ruleAction;
    return ruleAction;
};


//Remove rule
ReteNet.prototype.removeRule = function(rule){
    if(actionNode instanceof Array){
        actionNode.forEach(d=>this.removeRule(d));
        return;
    }
    //delete from bottom up
    var invalidatedActions = ReteActivationsAndDeletion.deleteNodeAndAnyUnusedAncestors(actionNode);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
};

//register a join action proposal and performance function
//as a single object of form : {name: "", propose:func, perform:func};
ReteNet.prototype.registerAction = function(actionObj){
    if(actionObj.name === undefined || actionObj.performFunc === undefined || actionObj.proposeFun === undefined){
        throw new Error("Action Registration Failure");
    }
    if(this.actionFunctions[actionObj.name] !== undefined){
        throw new Error("Registration Attempt for existing Action");
    }
    this.actionFunctions[actionObj.name] = actionObj;
};


//Utility method:
ReteNet.prototype.storeNode = function(node){
    this.allReteNodes[node.id] = node;
    var storeTarget = "unknown";
    if(node.isConstantTestNode){
        storeTarget = "constantTests";
    }else if(node.isAlphaMemory){
        storeTarget = "alphaMemories";
    }else if(node.isBetaMemory){
        storeTarget = "betaMemories";
    }else if(node.isJoinNode){
        storeTarget = "joinNodes";
    }else if(node.isActionNode){
        storeTarget = "actionNodes";
    }else if(node.isNegativeNode){
        storeTarget = "negativeNodes";
    }else if(node.isAnNCCNode){
        storeTarget = "nccNodes";
    }else if(node.isAnNCCPartnerNode){
        storeTarget = "nccPartnerNodes";
    }

    if(this.allReteNodesByType[storeTarget] !== undefined){
        this.allReteNodesByType[storeTarget][node.id] = node;
    }else{
        console.log(node);
        throw new Error("unrecognised type attempted to be stored");
    }
};

//convert a rule to a component list
//used to convert the jsRete Rule object to the standard form for loading
ReteNet.prototype.convertRulesToComponents = function(rules){
    if(!(rules instanceof Array)){
        rules = [rules];
    }
    var actions = _.flatten(rules.map(d=>_.values(d.actions))),
        conditions = _.flatten(rules.map(d=>_.values(d.conditions))),
        all = actions.concat(conditions).concat(rules),
        components = all.reduce(function(m,v){
            m[v.id] = v;
            return m;
        },{});
    return components;
};

module.exports = ReteNet;

});


require(["ReteClassInterface"]);
define('underscore',function() { return _; }); return require('ReteClassInterface'); }));
/**
   @file GraphNode
   @purpose To define the base data structure for the shell
*/


define('Node/GraphNode',['underscore'],function(_){
    "use strict";
    var nextId = 0;
    //The main node type of the graph:
    //Note: relationstoCreate = { children: [{name,children,parents}], parents : [{}] }
    var GraphNode = function(name,parent,type,relationsToCreate,overRideId){
        //Id and name for identification
        this.id = overRideId || nextId++;
        if(overRideId && overRideId > nextId){
            nextId = overRideId + 1;
        }
        
        this.name = name;

        //Parents and children created internally, ready to be sent to the shell for registration
        this.relatedObjects = [];

        //parents and children for links
        //storing by ID
        //Note: converted to *only* store id's, and not the objects
        //therefore no cycles, therefore json export
        this.children = {};
        this.parents = {};
        if(parent !== undefined){
            this._originalParent = parent.id;
            this.parents[parent.id] = parent.name;
        }

        //Data stored in the node
        this.values = {};
        this.tags = {};
        this.annotations = {};

        //Used to update the prototype on json-imported data
        this.tags.type = type || 'graphnode';

        //**Relations to rules:
        //Rules that consume this fact:
        this.expectedBy = {};
        //Rules that produce this fact:
        this.producedBy = {};


        //Create the relations passed in:
        //Each entry in the list: L = { name: "", children : [L], parents : [L] }
        if(relationsToCreate !== undefined && relationsToCreate.children !== undefined){
            relationsToCreate.children.forEach(function(d){
                var relations = {
                    children : d.children,
                    parents : d.parents,
                },
                    subName = d.name || d;
                this.addRelation('child',new GraphNode(subName,this,undefined,relations));
            },this);
        }

        if(relationsToCreate !== undefined && relationsToCreate.parents !== undefined){
            relationsToCreate.parents.forEach(function(d){
                var relations = {
                    children : d.children,
                    parents : d.parents,
                },
                    subName = d.name || d;
                this.addRelation('parent',new GraphNode(subName,this,undefined,relations));
            },this);

        }
        
    };
    GraphNode.constructor = GraphNode;

    /**
       @method toString
       @class GraphNode
     */
    GraphNode.prototype.toString = function(){
        return `(${this.id}) : ${this.name.slice(0,10)}`;
    };

    /**
       @method toStringList
       @class GraphNode
       @purpose returns a list of objects for visualisation
       @return [{name: "", values : [] }]
     */
    GraphNode.prototype.getDescriptionObjects = function(fieldNameList){
        //Get all fields
        var lists = fieldNameList.map(function(d){
            //as a simple { name : "key : value" } object
            if(typeof this[d] === "string" || typeof this[d] === 'number'){
                return { name : `${d} : ${this[d]}` };
            }
            //as a { name : key, values : ["$key : $value"] } object
            return {
                name: d,
                values : _.keys(this[d]).sort().map(e=>`${e} : ${this[d][e]}`)
            };
        },this);
        return lists;
    };


    GraphNode.prototype.getShortDescription = function(){
        return {name :`(${this.id}) ${this.name} : ${this.tags.type}` };
    };
    
    
    /**
       @method setValue
       @class GraphNode
       @purpose set a value in the node. as a scalar if no parameter is specified
     */
    GraphNode.prototype.setValue = function(value,field,parameter){
        //todo: add guards so you don't delete something important like 'id'
        if(parameter !== undefined){ //set this[field][parameter] -> value
            if(this[field] === undefined){ //create field if missing
                this[field] = {};//as an object because theres a parameter
            }
            if(value !== undefined){//if value exists set it
                this[field][parameter] = value;
            }else{//otherwise remove the memory location
                delete this[field][parameter];
            }
        }else{//parameter not specified, value is a scalar not object param
            if(value !== undefined){//if value exists, set it
                this[field] = value;
            }else{
                delete this[field];//value isnt specified, remove.
            }
        }
    };

    /**
       @method addRelation
       @class GraphNode
       @purpose register a NodeStyle object as a relation of this node. stores id+name
       @purpose and adds to the relatedObjects map;
     */
    GraphNode.prototype.addRelation = function(target,object){
        if(!(object instanceof GraphNode)){
            throw new Error("Trying to add a non-GraphNode relation");
        }
        this.relatedObjects.push(object);
        if(target === 'child'){
            this.children[object.id] = object.name;
        }else if(target === 'parent'){
            this.parents[object.id] = object.name;
        }else{
            throw new Error(`Unrecognised target for relation: ${target}`);
        }
        return object;
    };

    /**
       @method getRelationObjects
       @class GraphNode
       @purpose Returns the objects needing to be added to the shell, as the node shouldnt store them for json compatibility
     */
    GraphNode.prototype.getRelationObjects = function(){
        var tempList = this.relatedObjects;
        this.relatedObjects = [];
        return tempList;
    };

    
    return GraphNode;
});



define('Node/Rule',['underscore','./GraphNode'],function(_,GraphNode){
    "use strict";
    var Rule = function(name,parent,type,relations,overRideId){
        GraphNode.call(this,name,parent,"rule",{},overRideId);
        //id -> name of condition objects
        this.conditions = {};
        //id -> name of action objects
        this.actions = {};
    };
    Rule.prototype = Object.create(GraphNode.prototype);
    Rule.constructor = Rule;


    
    return Rule;
});

/**
   @file utils
   @purpose defines general utilities to use across projects
*/


define('utils',['underscore'],function(_){
    "use strict";
    var util = {};
    
    util.randomChoice = function(array){
        var randIndex = Math.floor(Math.random() * array.length);
        return array[randIndex];
    };

    
    // util.textAlignPairs = function(arrayOfPairs){
    //     console.log("Aligning:",arrayOfPairs);
    //     //Get the largest strings on each side
    //     var maxStringLengthLHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //         return d[0].length;
    //     })),
    //         maxStringLengthRHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //             return d[1].length;
    //         })),
    //         totalStringLength = Math.max(maxStringLengthLHS,maxStringLengthRHS),
    //     //Align each side
    //         alignedPairs = arrayOfPairs.map(function(d){
    //             var lhsDifference = d[1].length - d[0].length,
    //                 rhsDifference = d[0].length - d[1].length,
    //                 lhs = "",
    //                 rhs = "";
                
    //             if(lhsDifference > 0){
    //                 lhs = new Array(lhsDifference).join("_") + d[0];
    //             }else{
    //                 lhs = d[0];
    //             }
    //             if(rhsDifference > 0){
    //                 rhs = new Array(rhsDifference).join("_") + d[1];
    //             }else{
    //                 rhs = d[1];
    //             }
    //             return [lhs,rhs];
    //         });
        
    //     return alignedPairs;
    // };


    // //Generic draw group function, modes will typically create their own version
    // util.drawGroup = function(globalData,container,className,data,xLocation,groupWidth){
    //     console.log("drawing:",data);
    //     var heightOfNode = util.calculateNodeHeight((globalData.usableHeight - 100),
    //                                                 20,
    //                                                 data.length),
    //         animationLength = 100,
    //         boundGroup = container.selectAll("."+className)
    //         .data(data,function(d,i){ return d.id; });

    //     //exit selection
    //     boundGroup.exit().selectAll("rect")
    //         .transition()
    //         .duration(animationLength)
    //         .style("fill","red");

    //     boundGroup.exit().selectAll("text").transition()
    //         .style("opacity",0);
        
    //     boundGroup.exit().transition().delay(animationLength).remove();

    //     //entry selection
    //     var entryGroup = boundGroup.enter().append("g")
    //         .classed(className, true)
    //         .attr("transform","translate(" + xLocation + ",100)");


    //     //create
    //     entryGroup.append("rect")
    //         .attr("width",0)
    //         .attr("height",0)
    //         .style("fill",globalData.colours.lightBlue)
    //         .style("opacity",0)
    //         .attr("rx",0)
    //         .attr("ry",0);
        

    //     entryGroup.append("text")
    //         .style("text-anchor","middle")
    //         .style("fill","white")
    //         .style("opacity",0);


    //     //update selection
    //     //transition to updated sizes etc
    //     boundGroup.transition().delay(animationLength).attr("transform",function(d,i){
    //         return "translate(" + xLocation + "," + (100 + (i * (heightOfNode + 20))) + ")";
    //     })
    //         .selectAll("text")
    //         .attr("transform","translate(" + (groupWidth * 0.5) + "," +
    //               (heightOfNode * 0.5) + ")");

        
    //     boundGroup.selectAll("rect")
    //         .transition().delay(animationLength*3).duration(animationLength)
    //         .attr("width",groupWidth)
    //         .attr("height",heightOfNode)
    //         .attr("rx",10)
    //         .attr("ry",10)
    //         .style("opacity",1);

    //     boundGroup.selectAll("text").transition().delay(animationLength*3).duration(animationLength)
    //         .text(function(d){ return d.id + " : " + d.name; })
    //         .style("opacity",1);
        
    //     return boundGroup;
    // };

    //calculate, given an size of an area, how far apart node are,
    // and the number of items: the size of each individual node
    // util.calculateNodeHeight = function(amtOfSpace,separatorSpace,dataLength){
    //     if(dataLength > 0){
    //         return (amtOfSpace - (dataLength * separatorSpace)) / dataLength;
    //     }else{
    //         return (amtOfSpace - separatorSpace);
    //     }
    // };

    util.operatorToString = function(operatorName){
        var conversion = {
            "EQ" : "==",
            "LT" : "<",
            "GT" : ">",
            "LTE" : "<=",
            "GTE" : ">=",
            "NE" : "!=="
        };

        if(conversion[operatorName]){
            return conversion[operatorName];
        }else{
            console.warn("No conversion for operator:",operatorName);
            return operatorName;
        }
    };

    //Take a selection, append a wrapping classname,
    //offset by a global, and invidual amount, set a colour,
    //and use a passed in function to fill the texts
    //returning the resulting texts
    util.annotate = function(boundDom,className,
                             verticalOffset,nodeHeight,verticalSeparator,
                             horizontalOffset,nodeWidth,colour,textFunction,textColour){

        //Exit Selection:
        boundDom.exit().remove();

        //enter selection:
        var enter = boundDom.enter().append("g").classed(className,true);

        //create new
        enter.append("rect")
            .classed(className + "rect", true);
        enter.append("text")
            .classed(className + "text", true)
            .attr("dy","1.4em");
        

        //update:
        boundDom.attr("transform",function(e,i){
            return "translate(" + horizontalOffset + ","
                + ((verticalOffset + (i * (nodeHeight + verticalSeparator)))) + ")";
        });
        boundDom.selectAll("."+className+"rect")
            .attr("width",nodeWidth - (horizontalOffset * 2))
            .attr("height",nodeHeight)
            .style("fill",colour)
            .attr("rx",10).attr("ry",10);

        
        var texts = boundDom.selectAll("."+className+"text")
            .attr("transform","translate(" + horizontalOffset + "," + (nodeHeight * 0.2) + ")")
            .text(textFunction)
        //todo: parameterise this:
            .style("fill",textColour || "white");

        return texts;
    };

    //repeatedly truncate text until it fits in a certain amount of space;
    //TODO: customise
    util.truncateDrawnText = function(d){
        var bbox = this.getBBox();
        var maxLength = d.name.length - 4;
        while( bbox.wdith > 10 && maxLength > 10){
            d.shortName = d.name.slice(0,maxLength) + "...";
            //d3.select(this).text(d.shortName);
            bbox = this.getBBox();
            maxLength -= 2;
        }
    };

    // //Take a text, and wrap it onto multiple 'lines'
    // util.wrapText = function(textSelection,width,d3){
    //     //console.log("Wrapping selection:",textSelection);
    //     //TODO: check that the selection IS of texts?
    //     textSelection.each(function(){
    //             var text = d3.select(this),
    //                 words = text.text().split(/\s+/),
    //                 word,//current word
    //                 line = [],//current line
    //                 y = text.attr("y"),
    //                 dy = parseFloat(text.attr("dy")) || parseFloat("1.4em"),
    //                 tspan = text.text(null).append("tspan")
    //                 .attr("x",0)
    //                 .attr("y",y)
    //                 .attr("dy",dy);

    //         //console.log("Wrapping:",text,text.text());
    //         while(!_.isEmpty(words)){
    //             word = words.shift();
    //             line.push(word);
    //             tspan.text(line.join(" "));
    //             if(tspan.node().getComputedTextLength() > width){
    //                 line.pop();
    //                 tspan.text(line.join(" "));
    //                 line = [word];
    //                 tspan = text.append("tspan").attr("x",20)
    //                     .attr("dy",dy +"em").text(word);
    //             }
    //         }
    //     });
    // };
    
    return util;
});



define('Node/Condition',['underscore','./GraphNode','../utils'],function(_,GraphNode,util){
    "use strict";
    
    var Condition = function(name,parent,type,relations,overRideId){
        GraphNode.call(this,name,parent,"condition",{},overRideId);
        this.tags.isPositive = true;
        this.tags.isNegative = false;

        //Test objects of form: { field: "", operator: "", value : "" }
        this.constantTests = [];
        //Bindings object: { boundVar : [sourceVar, [tests]] }
        this.bindings = {};
        //Source node
        this.expectationNode = null;
    };
    Condition.prototype = Object.create(GraphNode.prototype);
    Condition.constructor = Condition;

    //Modify a constant test in the condition
    Condition.prototype.setTest = function(testId,testField,op,val){
        if(arguments < 2){
            this.constantTests.splice(testId,1);
        }else if(testId !== undefined && this.constantTests[testId] !== undefined){
            this.constantTests[testId] = {
                field : testField,
                operator : op,
                value : val
            };
        }else{
            this.constantTests.push({
                field : testField,
                operator : op,
                value : val
            });
        }
    };

    Condition.prototype.setBinding = function(toVar,fromVar,testPairs){
        if(arguments < 2){
            delete this.bindings[toVar];
        }else{
            this.bindings[toVar] = [fromVar,testPairs];
        }
    };


    Condition.prototype.getDescriptionObjects = function(){
        var lists = [];
        lists.push({
            name: this.toString()
        });
        
        //Add the constant tests
        lists.push({
            name: "IF:",
            values : this.constantTests.map((d,i)=>`(${i}): wme.data.${d.field} ${util.operatorToString(d.operator)} ${d.value}`)
        });

        //Add the bindings:
        lists.push({
            name: "BIND:",
            values : _.keys(this.bindings).map(d=>`${d} <-- wme.data.${this.bindings[d][0]} :: ${_.flatten(this.bindings[d][1]).join(" ")}`)
        });

        lists.push({
            name : "SOURCE:",
            values : [this.expectationNode]
        });
        
        return lists;
    };
    
    return Condition;
});



define('Node/Action',['underscore','./GraphNode'],function(_,GraphNode){
    "use strict";
    var Action = function(name,parent,actionType,values,overRideId){
        GraphNode.call(this,name,parent,"action",{},overRideId);
        this.tags.actionType = actionType || "assert";
        while(values && values.length >= 2){
            this.values[values.shift()] = values.shift();
        }

        //{keyVal : [op,mod]
        this.arithmeticActions = {};
        //{keyVal : [regex,options,replaceVal]
        this.regexActions = {};
        //Fact link that this action produces
        this.expectationNode = null;

        //Specify timing of proposed action to create,
        //As offsets from the time the action fires
        this.timing = {
            invalidateOffset : 0,
            performOffset : 0,
            unperformOffset: 0
        };
        
    };
    Action.prototype = Object.create(GraphNode.prototype);
    Action.constructor = Action;

    //Set or remove an arithmetic action
    Action.prototype.setArith = function(val,operator,modifier){
        if(arguments.length < 1){ throw new Error("setArith needs at least a value"); }
        if(arguments.length !== 3){
            delete this.arithmeticActions[val];
        }else{
            this.arithmeticActions[val] = [operator,modifier];
        }
    };
    //set or remove a regex action
    var regexSplitRegex = /\/(.+)\/(.+)\/(.*)/;
    Action.prototype.setRegex = function(val,regex){
        if(regex === undefined){
            delete this.regexActions[val];
        }else{
            var splitRegex = regex.match(regexSplitRegex);
            if(splitRegex === null || splitRegex.length !== 4){
                throw new Error("Invalid regex");
            }
            this.regexActions[val] = [splitRegex[1],splitRegex[3],splitRegex[2]];
        }
    };

    Action.prototype.setTiming = function(timeVar,value){
        if(this.timing[timeVar] !== undefined){
            this.timing[timeVar] = Number(value);
        }
    };

    
    Action.prototype.getDescriptionObjects = function(){
        var lists = [];
        lists.push({
            name : this.toString(),
        });

        lists.push({
            name : "Tags",
            values : _.pairs(this.tags).map(d=>d.join(" : "))
        });

        lists.push({
            name : "Data",
            values : _.pairs(this.values).map(d=>d.join(" : "))
        });
        
        lists.push({
            name : "Arithmetic Actions",
            values : _.keys(this.arithmeticActions).map(d=>`${d} ${this.arithmeticActions[d][0]} ${this.arithmeticActions[d][1]}`)
        });

        lists.push({
            name: "Regex Actions",
            values : _.keys(this.regexActions).map(d=>`${d} ~= /${this.regexActions[d][0]}/${this.regexActions[d][2]}/${this.regexActions[d][1]}`)
        });

        lists.push({
            name: "Timing",
            values : _.keys(this.timing).map(d=>`${d} : ${this.timing[d]}`)
        });

        lists.push({
            name : "Produces:",
            values : [this.expectationNode]
        });
        
        return lists;
    };
    
    
    return Action;
});

/**
   @file Institution
   @purpose To define the base data structure for the shell
*/


define('Node/Institution',['underscore','./GraphNode'],function(_,GraphNode){
    "use strict";
    var Institution = function(name,parent,dummyType,dummyRelations,overRideId){
        var relations = {
            children : [
                {name: "roles", children : "incumbent challenger controlled exempt".split(" ")},
                {name: "activities", children : "physical symbolic communicative unbound".split(" ")},
                "IGU",
                {name: "FactGrammar", children : "physical symbolic communicative unbound".split(" ")},
                "valueHierarchy",
                {name: "norms", children : "empiricallyExpected normativelyExpected sanctionable".split(" ")}
            ],
            parents : ["externalEffectors"]
        };
        GraphNode.call(this,name,parent,"Institution",relations,overRideId);
    };
    Institution.constructor = Institution;
    Institution.prototype = Object.create(GraphNode.prototype);
    
    
    return Institution;
});

define('Node/Bookmark',['underscore','./GraphNode'],function(_,GraphNode){
    "use strict";
    var Bookmark = function(name,parent,type,url,overRideId){
        GraphNode.call(this,name.slice(0,10),parent,"bookmark",{},overRideId);
        this.longName = name;
        this.url = [url];
    };
    Bookmark.prototype = Object.create(GraphNode.prototype);
    Bookmark.constructor = Bookmark;

    return Bookmark;
});



define('Node/Constructors',['underscore','./GraphNode','./Rule','./Condition','./Action','./Institution','./Bookmark'],function(_,GraphNode,Rule,Condition,Action,Institution,Bookmark){
    "use strict";
    var ctors = {
        "graphnode" : GraphNode,
        "rule"      : Rule,
        "condition" : Condition,
        "action"    : Action,
        "institution" : Institution,
        "bookmark" : Bookmark
    };

    var getCtor = function(name){
        if(ctors[name.toLowerCase()] !== undefined){
            return ctors[name.toLowerCase()];
        }
        return ctors.graphnode;
    };
    
    return getCtor;
});

/**
   @purpose Defines methods related to importing or exporting json from the shell
*/



define('ShellModules/shell_json',['underscore'],function(_){
    "use strict";
    //Object that will be copied into the shell's prototype:
    var ShellPrototype = {};

        /**
       @class CompleteShell
       @method exportJson
       @purpose Converts all defined nodes to a json array of objects
       @return A JSON string

       @note As nodes only store ID numbers, the information does not contain cycles
     */
    ShellPrototype.exportJson = function(){
        //todo: ensure that all nodes have been cleared of relation objects prir to export
        
        var graphJson = JSON.stringify(_.values(this.allNodes),undefined,4);
        console.log("Converted to JSON:",graphJson);
        return graphJson;
    };

    /**
       @class CompleteShell
       @method importJson
       @purpose To create a graph based on an incoming array of objects
       @param allNodes an array or object of key:object pairs describing all nodes to load
     */
    ShellPrototype.importJson = function(importNodes){
        //console.log("importing type:", typeof allNodes,allNodes.length);
        //clear the shell:
        this.allNodes = [];
        
        if(importNodes instanceof Array){
            importNodes.forEach(function(d){
                this.addNodeFromJson(d);
            },this);
        }else{
            _.values(importNodes).forEach(function(d){
                this.addNodeFromJson(d);
            },this);
        }
        this.cwd = this.allNodes[0];
    };

    /**
       @class CompleteShell
       @method addNodeFromJson
       @purpose create a node from loaded json data, forcing a specific ID number
       @param obj The object data to use for the node
       @return a new node object
     */
    ShellPrototype.addNodeFromJson = function(obj){
        //console.log("Loading Object:",obj);
        
        //get the constructor appropriate for the object
        //and apply it to the object
        //console.log("Using get ctor:",this.getCtor);
        //console.log("Importing:",obj);
        var ctor = this.getCtor(obj.tags.type),
            loadedNode = _.create(ctor.prototype,obj);
        //console.log("Loaded:",loadedNode);
        
        if(this.allNodes[loadedNode.id] !== undefined){
            console.warn("Json loading into existing node:",loadedNode,this.allNodes[loadedNode.id]);
        }
        this.allNodes[loadedNode.id] = loadedNode;

        return loadedNode;
    };

    /**
       @class CompleteShell
       @method convertObject
       @purpose convert old style links of name->id to new style id->name
       @param object The object to switch around
       @return an output object of value:key pairs
       @deprecated
    */
    ShellPrototype.convertObject = function(object){
        var keys = _.keys(object),
            values = _.values(object),
            newObject = {};
        _.zip(values,keys).forEach(function(d){
            newObject[d[0]] = d[1];
        });

        return newObject;
    };


    return ShellPrototype;
});

// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('Rete',['underscore'], factory);
    } else if (typeof exports === 'object') {
        var _ = require('underscore');
        module.exports = factory(_);
    } else {
        // change "myLib" to whatever your library is called
        root.Rete = factory(root._);
    }
}(this, function (_) {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('ReteDataStructures',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteDataStructures
   @purpose to define the data structures required for rete
*/

var _ = require('underscore'),
    nextId = 0;


/**
   @data ProposedAction
   @purpose describes a queued, but not yet performed, action
   @note queue/invalidate time absolute,
   @note assertTime/retractTime relative to when action is enacted
*/
var ProposedAction = function(reteNet,type,payload,token,proposeTime,timingObj){
    this.id = nextId++;
    this.reteNet = reteNet;
    this.actionType = type;//ie: "assert","retract","perform"...
    this.payload = payload; //ie" : {a:3,b:4}...
    this.token = token; //Source Token that spawned this action
    this.timing = {
        proposeTime : proposeTime,//when PA is created
        invalidateTime : proposeTime+timingObj.invalidateOffset, //when it becomes invalid
        performOffset : timingObj.performOffset, //PerformTime+pO is when it happens
        unperformOffset : timingObj.unperformOffset //PerformTime+uPO when to remove
    };

    //todo: possibly include metrics for selection of actions?
    //todo: check for circular reference cleanup
    //update Token:
    this.token.proposedActions.push(this);
};


/**
   @data WME
   @purpose to store facts in the rete net
*/
var WME = function(data,assertTime){
    this.isWME = true;
    this.data = data;
    //The lifetime of the wme. Asserted at time lifeTime[0],
    //retracted at time lifeTime[1]:
    if(assertTime === undefined) { assertTime = 0; }
    this.lifeTime = [assertTime];
    //Alpha memories the wme is part of
    this.alphaMemoryItems = [];
    //Tokens the wme is part of
    this.tokens = [];
    //Tokens this wme is blocking
    this.negJoinResults = [];
    this.id = nextId;
    nextId++;
};

/**
   @data Token
   @purpose To combine intermediate results in the beta network
*/
//bindings are updated as the token progresses
var Token = function(parentToken,wme,owningNode,bindings){
    this.isToken = true;
    this.parentToken = parentToken; //ie:owner
    this.wme = wme;
    this.owningNode = owningNode;
    this.children = []; //list of nodes
    this.negJoinResults = [];//list of NegativeJoinResults
    this.nccResults = []; //list of Token
    this.proposedActions = []; //current proposed actions
    
    if(this.parentToken){
        this.parentToken.children.unshift(this);
    }
    if(this.wme && this.wme.tokens){
        this.wme.tokens.unshift(this);
    }

    //copy over bindings from parent,
    //then copy in new bindings
    this.bindings = {};

    if(this.parentToken && this.parentToken.bindings){
        _.keys(this.parentToken.bindings).forEach(function(d){
            this.bindings[d] = this.parentToken.bindings[d];
        },this);
    }
    _.keys(bindings).forEach(function(d){
        this.bindings[d] = bindings[d];
    },this);

    this.id = nextId;
    nextId++;        
};

//------------------------------

/**
   @data AlphaMemoryItem
   @purpose a Pairing of a wme with an alpha memory it resides in
*/
//Utility storage of wme and its alphaMemory together
//used in alphamemory and WME
var AlphaMemoryItem = function(wme,alphaMem){
    this.wme = wme;
    this.alphaMemory = alphaMem;
    this.id = nextId;
    nextId++;
};


/**
   @data AlphaNode
   @purpose a node to perform constant tests on newly asserted WMEs
*/
//A constant test node
//constantTest = {field:"",value:"",operator:""};
var AlphaNode = function(parent,constantTestSpec){
    this.id = nextId;
    this.isConstantTestNode = true;
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.children = [];
    this.outputMemory = undefined;
    if(constantTestSpec){
        this.testField = constantTestSpec.field;
        this.testValue = constantTestSpec.value;
        this.operator = constantTestSpec.operator;
    }else{
        this.passThrough = true;
    }
    nextId++;
};

/**
   @data AlphaMemory
   @purpose to store wmes that have passed through constant tests
*/
//Alpha Memory node
var AlphaMemory = function(parent){
    this.isAlphaMemory = true;
    this.items = [];
    this.parent = parent;
    //If adding to a node other than a test node,
    if(parent && parent.isConstantTestNode === undefined){
        //add to children
        this.parent.children.unshift(this);
    }else if(this.parent && this.parent.outputMemory === undefined){
        //if an alphanode, set the ouputmemory field
        this.parent.outputMemory = this;
    }else if(this.parent && this.parentOutputMemory !== undefined){
        throw new Error("trying to create an alpha memory for a node that already has one");
    }
    this.children = [];
    this.unlinkedChildren = [];
    this.referenceCount = 0;
    this.isMemoryNode = true;
    this.id = nextId;
    nextId++;
};

/**
   @data ReteNode
   @purpose provides a base definition of a node in the rete network
*/    
//Base node for the beta network
var ReteNode = function(parent){
    this.children = [];
    this.unlinkedChildren = [];
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.unshift(this);
    }
    this.id = nextId;
    nextId++;
};

/**
   @data BetaMemory
   @inherits ReteNode
   @purpose A Node to store tokens in the rete network
*/
//Beta Memory Stores tokens
var BetaMemory = function(parent){
    ReteNode.call(this,parent);
    this.isBetaMemory = true;
    this.isMemoryNode = true;
    this.items = [];
    if(parent === undefined){
        this.dummy = true;
        this.items.push(new Token());
        this.items[0].owningNode = this;
    }

};

/**
   @data JoinNode
   @inherits ReteNode
   @purpose To combine tokens and wmes, according to binding tests
*/
//Join Node combines tokens with wmes
//tests are the binding tuples from a condition
var JoinNode = function(parent,alphaMemory,tests){
    ReteNode.call(this,parent);
    this.isJoinNode = true;
    this.alphaMemory = alphaMemory;
    if(tests){
        this.tests = tests;
    }else{
        this.tests = [];
    }
    if(this.alphaMemory && this.alphaMemory.children){
        this.alphaMemory.children.unshift(this);
        this.alphaMemory.referenceCount += 1;
    }
    this.nearestAncestor = null;
};

/**
   @data ActionNode
   @purpose A Node which, when activated, will cause the effects a rule describes
*/
//Container object for a general graphnode action description    
var ActionNode = function(parent,actionDescriptions,boundActions,ruleName,reteNet){
    ReteNode.call(this,parent);
    this.isActionNode = true;
    this.name = ruleName;
    this.actionDescriptions = actionDescriptions;
    this.boundActions = boundActions;
    //reference to retenet, to allow storage of results of firing:
    this.reteNet = reteNet;
};


/**
   @data NegativeJoinResult
   @purpose To Store the combination of a token and a wme that blocks it from progressing through the network
*/
//Storage for a token blocked by a wme
//Updates the owner token and wme as part of its construction
var NegativeJoinResult = function(owner,wme){
    this.owner = owner;
    if(this.owner){
        this.owner.negJoinResults.unshift(this);
    }
    this.wme = wme;
    if(this.wme){
        this.wme.negJoinResults.unshift(this);
    }
    this.id = nextId;
    nextId++;
};


/**
   @data NegativeNode
   @purpose A Node that tests for the abscence of particular wmes
*/
//Negative Node:The node that gates token progression
var NegativeNode = function(parent,alphaMemory,tests){
    if(tests.length === 0){
        throw new Error("Negative Node requires a binding");
    }
    ReteNode.call(this,parent);
    this.isNegativeNode = true;
    this.items = [];
    this.alphaMemory = alphaMemory;
    if(this.alphaMemory){
        this.alphaMemory.referenceCount++;
        this.alphaMemory.children.unshift(this);
    }
    this.tests = tests;
    this.nearestAncestor = null;
};

/**
   @data NCCNode
   @purpose The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork
*/
//NCC : gates token progression based on a subnetwork
//SEE ALSO: NCCCondition
//old: NegatedConjunctiveConditionNode
var NCCNode = function(parent){
    //don't pass parent in
    ReteNode.call(this);
    this.parent = parent;
    if(this.parent && this.parent.children){
        this.parent.children.push(this);
    }
    this.isAnNCCNode = true;
    this.items = [];
    this.partner = null;
};


/**
   @data NCCPartnerNode
   @purpose to store potential partial matches in the subnetwork for a NCCNode
*/
//The partner of the NCC, connects to the subnetwork
//old NegConjuConPartnerNode
//var NCCPartner
var NCCPartnerNode = function(parent,num){
    ReteNode.call(this,parent);
    this.isAnNCCPartnerNode = true;
    this.nccNode = null;
    this.numberOfConjuncts = num;
    this.newResultBuffer = [];
    this.id = nextId;
};



//--------------------
/**
   @interface ReteDataStructures
*/
var DataStructures = {
    "WME"              : WME,
    "Token"            : Token,
    "AlphaMemory"      : AlphaMemory,
    "AlphaMemoryItem"  : AlphaMemoryItem,
    "AlphaNode"        : AlphaNode,
    "ReteNode"         : ReteNode,
    "BetaMemory"       : BetaMemory,
    "JoinNode"         : JoinNode,
    "NegativeJoinResult":NegativeJoinResult,
    "NegativeNode"     : NegativeNode,
    "NCCNode"          : NCCNode,
    "NCCPartnerNode"   : NCCPartnerNode,
    "ActionNode"       : ActionNode,
    "ProposedAction"   : ProposedAction
};

module.exports = DataStructures;


});

define('ReteUtilities',['require','exports','module','underscore'],function (require, exports, module) {var _ = require('underscore');
    "use strict";

    /**
       @function relinkToAlphaMemory
       @utility
       @purpose reconnects a joinnode with its alpha memory, once the beta memory is populated
     */
    //reconnect an unlinked join node to its alpha memory when there are
    //wmes in said alpha memory
    var relinkToAlphaMemory = function(node){
        if(node.isJoinNode === undefined && node.isNegativeNode === undefined){
            throw new Error("trying to relink alpha on something other than a join node or negative node");
        }
        
        var ancestor = node.nearestAncestor;
        var indices = node.alphaMemory.children.map(d=>d.id);

        //While the ancestor is a child of the alpha memory
        while(ancestor && indices.indexOf(ancestor.id) === -1){
            //go up an ancestor if it is unlinked to
            ancestor = findNearestAncestorWithAlphaMemory(ancestor,node.alphaMemory.id);
        }
        
        //When finished, if the ancestor exists:
        if(ancestor !== null){
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(ancestor.id);
            //add the node into the child list in front of the ancestor
            node.alphaMemory.children.splice(index,0,node);
        }else{
            //otherwise just add at the end
            node.alphaMemory.children.push(node);
        }

        //remove from the unlinkedChildren Field
        var nodeIndex = node.alphaMemory.unlinkedChildren.map(d=>d.id).indexOf(node.id);
        node.alphaMemory.unlinkedChildren.splice(nodeIndex,1);
        
        
    };

    /**
       @function relinkToBetaMemory
       @utility
       @purpose reconnects a join node to its beta memory, once the alpha memory is populated
     */
    //relink an unlinked join node to its betamemory when there are tokens
    //in said memory
    var relinkToBetaMemory = function(node){
        //remove from the unlinked children list
        //and add it into the children
        var index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
        if(index > -1){
            node.parent.unlinkedChildren.splice(index,1);
            node.parent.children.unshift(node);
        }
    };


    /**
       @function unlinkAlphaMemory
       @purpose if an alpha memory becomes empty, displace all its children temporarily
     */
    var unlinkAlphaMemory = function(alphaMemory){
        //if the alphaMem has no items: UNLINK
        if(alphaMemory.items.length === 0){
            alphaMemory.children.forEach(function(amChild){
                if(amChild.isJoinNode){
                    var index = amChild.parent.children.map(d=>d.id).indexOf(amChild.id);
                    //splice out
                    var removed = amChild.parent.children.splice(index,1);
                    //and store
                    amChild.parent.unlinkedChildren.push(removed[0]);
                }
            });
        }
    };

    
    /**
       @function ifEmptyBetaMemoryUnlink
       @purpose if a beta memory becomes empty, displace all its children temporarily
     */
    //Now Essentially switch on: BetaMemory, NegativeNode,
    //NCCNode, and NCCPartnerNode
    var ifEmptyBetaMemoryUnlink = function(node){
        //BETAMEMORY
        if(node && node.isBetaMemory){
            //and that betaMemory has no other items
            if(node.items.length === 0){
                //for all the node's children
                node.children.forEach(function(jn){
                    if(jn.isJoinNode === undefined){return;}
                    var index = jn.alphaMemory.children.map(d=>d.id).indexOf(jn.id);
                    if(index !== -1){
                        var removed = jn.alphaMemory.children.splice(index,1);
                        //push it in the unlinked children list
                        jn.alphaMemory.unlinkedChildren.push(removed[0]);
                    }
                });
            }
            return true;
        }else{
            return false;
        }        
    };

    /**
       @function ifEmptyNegNodeUnlink
       @purpose if a negative node becomes empty, displace its alpha memory's children
     */
    var ifEmptyNegNodeUnlink = function(node){
        if(node && node.isNegativeNode){
            //with elements
            if(node.items.length === 0){
                //unlink alpha memory
                var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
                var removed = node.alphaMemory.children.splice(index,1);
                node.alphaMemory.unlinkedChildren.push(removed[0]);
            }
        }
    };

    

    /**
       @function compareConstantNodeToTest
       @purpose compare an existing constant test node to a constant test that wants to be built
     */
    //taking an alpha node and a ConstantTest
    var compareConstantNodeToTest = function(node,constantTestSpec){
        if(node.testField !== constantTestSpec.field
           || node.testValue !== constantTestSpec.value){
            return false;
        }
        if(node.operator !== constantTestSpec.operator){
            return false;
        }
        return true;
    };

    /**
       @function compareJoinTests
       @purpose Compare specified join tests, to see if a join node is the same as one needed
    */
    var compareJoinTests = function(firstTestSet,secondTestSet){
        if(!(secondTestSet instanceof Array)){
            secondTestSet = _.pairs(secondTestSet);
        }
        
        if(firstTestSet.length === 0 && secondTestSet.length === 0){
            return true;
        }
        var i = firstTestSet.length -1;
        var j = secondTestSet.length -1;
        while(i >= 0 && j >= 0){
            var ts1 = firstTestSet[i],
                ts2 = secondTestSet[j];
            //console.log("comparing",i,j,"|||",firstTestSet[i][0],secondTestSet[j][0],"|||",firstTestSet[i][1],secondTestSet[j][1]);
            if(firstTestSet[i][0] === secondTestSet[j][0]){
                if(firstTestSet[i][1] === secondTestSet[j][1]){
                    i--; j--;
                }else{
                    return false;
                }
            }else if(firstTestSet[i][0] > secondTestSet[j][0]){
                i--;
            }else if(firstTestSet[i][0] < secondTestSet[j][0]){
                j--;
            }else{
                return false;
            }
        }
        if(i === j && i === -1){
            return true;
        }
        return false;
    };


    var altCompareJoinTests = function(firstTestSet,secondTestSet){
        try{
            //compare lengths
            if(firstTestSet.length !== secondTestSet.length) { throw "unequal lengths"; }
            for(var i = 0; i < firstTestSet.length; i++){
                var fTest = firstTestSet[i],
                    sTest = secondTestSet[i];
                //compare the bound names
                if(fTest[0] !== sTest[0]) { throw "different bound names"; }
            
                //compare the source names
                if(fTest[1][0] !== sTest[1][0]) { throw "different source names"; }
            
                //compare the bind tests
                if(fTest[1][1].length !== sTest[1][1].length) { throw "different binding tests length"; }
                for(var j = 0; fTest[1][1].length; j++){
                    if(fTest[1][1][j][0] !== sTest[1][1][j][0]) { throw "different comp operator"; }
                    if(fTest[1][1][j][1] !== sTest[1][1][j][1]) { throw "different comp value"; }
                }
            }
        }catch(e){
            return false;
        }
        return true;
    };

    
    /**
       @function findNearestAncestorWithAlphaMemory
       @recursive
       @purpose To go up the network, to find appropriate beta network elements linked to the alphamemory
    */
    var findNearestAncestorWithAlphaMemory = function(node,alphaMemory){
        //base conditions:
        if(node.dummy){ return null;}
        if(node.isJoinNode || node.isNegativeNode){
            if(node.alphaMemory.id === alphaMemory.id){
                return node;
            }
        }
        //switch recursion into the partner clause
        if(node.isAnNCCNode){
            return findNearestAncestorWithAlphaMemory(node.partner.parent,alphaMemory);
        }
        //recurse:
        return findNearestAncestorWithAlphaMemory(node.parent,alphaMemory);        
    };

    //--------------------
    var retrieveWMEValueFromDotString = function(wme,dotString){
        //get from the node stored in wme.data the value
        //that the dotString address specifies
        var address = dotString.split("."),
            currLocation = wme.data;
        while(address.length > 0){
            var curr = address.shift();
            if(currLocation[curr] !== undefined){
                currLocation = currLocation[curr];
            }
        }

        //return the final location arrived at
        return currLocation;
    };

    //remove proposed actions from the retenet, and from their owning tokens
    var cleanupInvalidatedActions = function(invalidatedActions){
        if(invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined){
            return;
        }
        var reteNet = invalidatedActions[0].reteNet,
            proposedActions = reteNet.proposedActions,
            idList = invalidatedActions.map(d=>d.id);
        //console.log("Cleaning up:",[idList,invalidatedActions,proposedActions]);
        //filter out the ids from the proposedActions list
        //also removing them from the owning tokens
        proposedActions = _.reject(proposedActions,function(d){
            if(d === undefined) { return true; }
            return idList.indexOf(d.id) !== -1;
        });
        reteNet.proposedActions = proposedActions;
    };


    /**
       @function objDescToObject
       @purpose Take a single object that describes a more complex object,
       and convert it to that more complex object

       @note can work on arbitrary depths, will overwrite primitives if later an object is needed

       ie: {"values.a" : 5, "values.b" : 10,
       "tags.type" : "rule", "tags.character" : "bob"}
       --->
       {"values": {"a": 5, "b": 10},
       "tags" : {"type" : "rule", "character": "bob"}}

     */
    var objDescToObject = function(objDesc,baseObject){
        var newObj = baseObject || {},
            //take the starting object and for all keys
            finalObj = _.keys(objDesc).reduce(function(m,v){
                //split the keys apart
                var keys = v.split(/\./),
                    currObj = m,
                    currKey;
                //add an object for each key
                while(keys.length > 1){
                    currKey = keys.shift();
                    if(currObj[currKey] === undefined
                      || typeof currObj[currKey] !== 'object'){
                        currObj[currKey] = {};
                    }
                    currObj = currObj[currKey];
                }
                currKey = keys.shift();
                currObj[currKey] = objDesc[v];
                return m;
            },newObj);
        return finalObj;
    };

    
    
    //------------------------------
    var moduleInterface = {
        "unlinkAlphaMemory" : unlinkAlphaMemory,
        "relinkToAlphaMemory" : relinkToAlphaMemory,
        "ifEmptyBetaMemoryUnlink" : ifEmptyBetaMemoryUnlink,
        "ifEmptyNegNodeUnlink" : ifEmptyNegNodeUnlink,
        "relinkToBetaMemory" : relinkToBetaMemory,
        "compareJoinTests" : altCompareJoinTests,
        //"compareJoinTests" : compareJoinTests,
        "compareConstantNodeToTest" : compareConstantNodeToTest,
        "findNearestAncestorWithAlphaMemory" : findNearestAncestorWithAlphaMemory,
        "retrieveWMEValueFromDotString" : retrieveWMEValueFromDotString,
        "cleanupInvalidatedActions" : cleanupInvalidatedActions,
        "objDescToObject" : objDescToObject
    };
module.exports = moduleInterface;    


});

define('ReteComparisonOperators',['require','exports','module'],function (require, exports, module) {/**
   @file ReteComparisonOperators
   @purpose To define the possible operators available for constant test nodes
*/

//Define an object of comparisons able to
//be used in constant tests

//See general utils file for converting to string
//TODO: These can be changed to their actual representations, similar to reteArithActions
var ConstantTestOperators = {
    "EQ" : function(a,b){
        return a===b;
    },
    "LT" : function(a,b){
        return a < b;
    },
    "GT" : function(a,b){
        return a > b;
    },
    "LTE" : function(a,b){
        return a <= b;
    },
    "GTE": function(a,b){
        return a >= b;
    },
    "NE" : function(a,b){
        return a !== b;
    }
};

module.exports = ConstantTestOperators;

});

define('ReteTestExecution',['require','exports','module','./ReteDataStructures','underscore','./ReteUtilities','./ReteComparisonOperators'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    ReteComparisonOps = require('./ReteComparisonOperators');


/**
   @function performJoinTests
   @purpose compare a token and wme, using defined bindings from a joinNode
   @return False if no match, dict of all updated bindings otherwise
*/
var performJoinTests = function(joinNode,token,wme){
    var newBindings = {},
        successState = true,
        varRegex = new RegExp(/^\$/);
    //Populate with current bindings from token
    _.keys(token.bindings).forEach(function(key){
        newBindings[key] = token.bindings[key];
    });

    try{
        //add new bindings:
        joinNode.tests.forEach(function(test){
            var newValue = null;
            //retrieve the value
            if(test[1] === "#id" || test[1] === '$id'){
                newValue = wme.id;
            }else{
                newValue = ReteUtil.retrieveWMEValueFromDotString(wme,test[1][0]);
            }
            
            //compare the value for each specified binding test
            var bindingComparisons = test[1][1];
            
            //Compare using any defined binding tests
            bindingComparisons.forEach(function(d){
                var comparator = ReteComparisonOps[d[0]],
                    varName = d[1];
                //if it fails, fail the test
                //use the value in the test, minus the $ at the beginning:
                if(!varRegex.test(varName)) { throw new Error("Non-bound var name"); }
                
                if(!comparator(newValue,newBindings[varName.slice(1)])){
                    throw new Error("Test failed");
                }
            });
            
            if(newBindings[test[0]] === undefined){
                newBindings[test[0]] = newValue;
            }
            if(newBindings[test[0]] !== newValue){
                throw new Error("Test failed");
            }
        });
        
        if(successState){
            return newBindings;
        }else{
            throw new Error("Test failed");
        }
    }catch(e){
        return false;
    }
};


var moduleInterface = {
    "performJoinTests" : performJoinTests,
};
module.exports =  moduleInterface;

});

define('ReteArithmeticActions',['require','exports','module','underscore'],function (require, exports, module) {/**
   @file ReteArithmeticActions
   @purpose to define the arithmetic that an action can perform on a value
*/
var _ = require('underscore');

    "use strict";
    var ArithmeticActions = {
        "+" : function(a,b){
            return a + b;
        },
        "-" : function(a,b){
            return a - b;
        },
        "*" : function(a,b){
            return a * b;
        },
        "/" : function(a,b){
            return a / b;
        },
    };

module.exports = ArithmeticActions;
    


});

define('ReteActions',['require','exports','module','./ReteArithmeticActions','underscore','./ReteUtilities','./ReteDataStructures'],function (require, exports, module) {/**
   @file ReteActions
   @purpose Defines action proposals
*/
var ArithmeticActions = require('./ReteArithmeticActions'),
    _ = require('underscore'),
    ReteUtil = require('./ReteUtilities'),
    RDS = require('./ReteDataStructures');


if(ArithmeticActions === undefined){
    throw new Error("Arithmetic Actions missing");
}

//Action node possible actions:
//Stores both performance functions and proposal functions
//in the form: {name: "", performFunc : func, propseFunc : func }
var ActionInterface = {};

//Performance functions take a retenet, and a payload
//proposal functions are bound to an action description, and take a token and a retenet

//eg: the action asserts a new wme, with an arithmetic action of +2,
//the action has the information (+ 2), the incoming token as the base value to add to.

//Proposal functions return an object of the form:
//{ action: "", payload: {}, (timeData)? }


//** @action assert
ActionInterface.assert = {
    name : "assert",
    proposeFunc : null,
    performFunc : null
};

ActionInterface.assert.proposeFunc = function(token,reteNet){
    //create the data object:
    //initialise from the action's 'values' object
    var newWMEData = _.reduce(_.keys(this.values),function(memo,key){
        var v = this.values[key];
        //if the value starts with # or $, look it up in the token list
        memo[key] = v.match(/^[\$#]/) === null ? v : token.bindings[v.slice(1)];
        return memo;
    },{bindings: {} },this);

    //Then copy in the bindings:
    var newDataPlusBindings = _.reduce(_.keys(token.bindings),function(memo,key){
        memo.bindings[key] = token.bindings[key];            
        return memo;
    },newWMEData);
    
    //perform arithmetic:
    _.keys(this.arithmeticActions).forEach(function(key){
        var newVal = Number(newDataPlusBindings[key]);
        if(isNaN(newVal)) { throw new Error("Arithmetic value should be convertable to a number"); }
        //look up the function:
        //because the representation form is: a : ["+", 5]
        var action = ArithmeticActions[this.arithmeticActions[key][0]];
        newDataPlusBindings[key] = action(newVal,Number(this.arithmeticActions[key][1]));
    },this);

    //todo: allow for importing of other vars as the replacement values?
    _.keys(this.regexActions).forEach(function(key){
        var pair = this.regexActions[key],
            regex = new RegExp(pair[0],pair[1]),
            replaceValue = pair[2].match(/\$/) ? newDataPlusBindings[pair[2].slice(1)] : pair[2];
        newDataPlusBindings[key] = newDataPlusBindings[key].replace(regex,replaceValue);
    },this);
    
    //Expand out to object structure
    //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}
    var complexFormData = ReteUtil.objDescToObject(newWMEData);
    
    //DONT create the wme, just store the data for it
    //To be returned to activateActionNode
    var proposedAction = new RDS.ProposedAction(reteNet,"assert", complexFormData, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;        
};


ActionInterface.assert.performFunc = function(reteNet,proposedAction){
    //check the type matches
    if(proposedAction.actionType !== 'assert') { throw new Error("Expected Assert"); }
    //Perform the action:
    var newWMEID = reteNet.assertWME(proposedAction.payload,proposedAction.retractTime);

    //schedule the retraction:
    if(proposedAction.timing.unperformOffset > 0){
        //schedule a retract, with no invalidate time (its not being proposed)
        //and the perform time being the original actions unperformoffset
        reteNet.addToSchedule(new RDS.ProposedAction(reteNet,"retract",newWMEId,null,reteNet.currentTime,{
            invalidateOffset : null,
            performOffset : proposedAction.timing.unperformOffset,
            unperformOffset : null
        }));
    }
};



//----------------------------------------
//** @action retract
ActionInterface.retract = {
    name : "retract",
    proposeFunc : null,
    performFunc : null,

};

ActionInterface.retract.proposeFunc = function(token,reteNet){
    //get all wmes the token touches:
    var wmes = [];
    var currToken = token;
    while(currToken && currToken.wme !== undefined){
        wmes.push(currToken.wme);
        currToken = currToken.parentToken;
    }

    //get the wme ids to remove:
    var wmeIDs = _.values(token.bindings);

    //filter the wmeList by the wmeIDs:
    var toRetract = _.filter(wmes,function(wme){
        return _.contains(wmeIDs,wme.id);
    });

    //Propose the list of all wmes to retract 
    var proposedAction = new RDS.ProposedAction(reteNet,"retract", toRetract, token,
                                                reteNet.currentTime,
                                                this.timing);

    return proposedAction;
};

ActionInterface.retract.performFunc = function(reteNet,proposedAction){
    if(proposedAction.actionType !== 'retract') { throw new Error("Expected retract"); }
    if(proposedAction.payload instanceof Array){
        var retractedWMEs = proposedAction.payload.map(d=>reteNet.retractWME(d));
    }else{
        var retractedWME = reteNet.retractWME(proposedAction.payload);
    }
    //do anything with the retracted wme(s)?
};

//--------------------
ActionInterface.addRule = {
    name : "addRule",
    performFunc : null,
    proposeFunc : null
};

//propose takes the token, retrieves existing conditions/actions, or creates new ones
//perform takes the payload, as a rule object, and calls addRule on it

//--------------------
ActionInterface.removeRule = {
    name : "removeRule",
    performFunc : null,
    proposeFunc : null
};

//propose gets the rule id specified and packages it up
//perform calls removeRule on the retrieved rule

module.exports = ActionInterface;


});

define('ReteActivationAndDeletion',['require','exports','module','./ReteDataStructures','./ReteComparisonOperators','./ReteUtilities','./ReteTestExecution','./ReteActions','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ConstantTestOperators = require('./ReteComparisonOperators'),
    ReteUtil = require('./ReteUtilities'),
    ReteTestExecution = require('./ReteTestExecution'),
    PossibleActions = require('./ReteActions'),
    _ = require('underscore');




/**
   @function alphaMemoryActivation
   @purpose stores a wme in an alpha memory
   Trigger an alpha memory with a new wme to store
*/
var alphaMemoryActivation = function(alphaMem,wme){
    var newItem = new RDS.AlphaMemoryItem(wme,alphaMem);
    alphaMem.items.unshift(newItem);
    wme.alphaMemoryItems.unshift(newItem);
    //console.log("AlphaMemory activated:",alphaMem,wme);
    alphaMem.children.forEach(child=>rightActivate(child,wme));
};

/**
   @function constantTestNodeActivation
   @purpose tests a wme against the test in the given node
*/
//Trigger a constant test with a new wme
var constantTestNodeActivation = function(alphaNode,wme){
    //test the wme using the constant test in the node
    var testResult = false;
    if(alphaNode.passThrough){
        testResult = true;
    }else{
        var wmeFieldValue = ReteUtil.retrieveWMEValueFromDotString(wme,alphaNode.testField);
        var value = alphaNode.testValue;
        var operator = alphaNode.operator;
        if(ConstantTestOperators[operator]){
            if(operator !== 'EQ' && operator !== 'NE'){
                testResult = ConstantTestOperators[operator](Number(wmeFieldValue),Number(value));
            }else{
                //console.log("testing:",wmeFieldValue,operator,value,alphaNode,wme);
                testResult = ConstantTestOperators[operator](wmeFieldValue,value);
            }
            
        }
    }
    if(testResult){
        //console.log("successful constant test result",testResult,wme,alphaNode);
        if(alphaNode.outputMemory){
            alphaNodeActivation(alphaNode.outputMemory,wme);
        }
        alphaNode.children.forEach(child=>alphaNodeActivation(child,wme));
    }
    //console.log("ConstantTest Result:",alphaNode,wme,testResult);
    return testResult;
};

/**
   @function alphaNodeActivation
   @utility
   @purpose selects whether to store a wme, or test the wme
*/
//Switchable activation function for alpha network stuff
var alphaNodeActivation = function(alphaNode,wme){
    if(alphaNode.isAlphaMemory){
        alphaMemoryActivation(alphaNode,wme);
    }else if(alphaNode.isConstantTestNode){
        return constantTestNodeActivation(alphaNode,wme);
    }else{
        throw new Error("Unrecognised node:",alphaNode);
    }
};

/**
   @function betaMemoryActivation
   @purpose stores a token in the beta memory
*/
//trigger a beta memory to store a new token
//bindings are from the join node, holding results of the NEW binding tests
//old bindings are still in the token, the constructor of Token will combine the two
//sets of bindings
var betaMemoryActivation = function(betaMemory,token){
    var newToken = token;
    betaMemory.items.unshift(newToken);
    betaMemory.children.forEach(child=>leftActivate(child,newToken));
};


/**
   @function joinNodeLeftActivation
   @purpose given a new token, compares it to all wmes in the related alpha memory
*/
//Trigger a join node with a new token
//will pull all wmes needed from the linked alphaMemory
var joinNodeLeftActivation = function(node,token){
    //If necessary, relink or unlink the
    //parent betamemory or alphamemory
    if(node.parent.items && node.parent.items.length === 1){
        ReteUtil.relinkToAlphaMemory(node);
        if(node.alphaMemory.items.length === 0){
            //unlink beta memory if alphamemory is empty
            var index = node.parent.children.map(d=>d.id).indexOf(node.id);
            var unlinked = node.parent.children.splice(index,1);
            node.parent.unlinkedChildren.push(unlinked[0]);
        }
    }
    //for each wme in the alpha memory,
    //compare using join tests,
    //and pass on successful combinations
    //to beta memory /negative node children
    //to be combined into tokens
    node.alphaMemory.items.forEach(function(item){
        var currWME = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,token,currWME);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(child=>leftActivate(child,token,currWME,joinTestResult));
            
        }
    });//end of looping all wmes in alphamemory
};

/**
   @function joinNodeRightActivation
   @purpose given a new wme, compares it against all tokens in the related beta memory
*/
//Trigger a join node with a new wme
//pulling all necessary tokens from the parent as needed
var joinNodeRightActivation = function(node,wme){
    //relink or unlink as necessary
    if(node.alphaMemory.items.length === 1){
        ReteUtil.relinkToBetaMemory(node);
        if(node.parent.items.length === 0){
            var index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
            var unlinked = node.alphaMemory.children.splice(index,1);
            node.alphaMemory.unlinkedChildren.push(unlinked[0]);
        }
    }

    //For all tokens, compare to the new wme,
    //pass on successful combinations to betamemory/negative node
    node.parent.items.forEach(function(currToken){
        //console.log("--------\nComparing: ",currToken.bindings,"\n To: ",wme.data,"\n using: ",node.tests);
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            node.children.forEach(currNode=>leftActivate(currNode,currToken,wme,joinTestResult));
        }
    });
};


/**
   @function activateActionNode
   @purpose given a new token, activates any stored actions necessary
*/
var activateActionNode = function(actionNode,token){
    //get the actions the node embodies:
    var boundActionFunctions = actionNode.boundActions,
        //apply the token to each of the actions
        newProposedActions = boundActionFunctions.map(d=>d(token,actionNode.reteNet)),
        newProposedActionIds = newProposedActions.map(d=>d.id);
    
    //store the proposed actions in the reteNet.potential actions
    //and also tie all the actions that fire together by their ids
    //ie: {action:"assert",payload:wme}
    //see RDS.ProposedAction for details
    newProposedActions.forEach(function(d){
        d.parallelActions = newProposedActionIds;
        actionNode.reteNet.proposedActions[d.id] = d;
    });
};


/**
   @function leftActivate
   @utility
   @purpose selects what node to activate as appropriate, for a new token
*/
//Utility leftActivation function to call
//whichever specific type is needed
var leftActivate = function(node,token,wme,joinTestResults){
    //Construct a new token if supplied the correct
    //parameters
    if(joinTestResults && wme){
        token = new RDS.Token(token,wme,node,joinTestResults);
        //owning node is the node going into, rather than coming out of
    }
    //Activate the node:
    //Essentially a switch of:
    //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode,
    //and Action
    if(node.__isDummy){
        //pass on, because this is a test
    }else if(node.isBetaMemory){
        betaMemoryActivation(node,token);
    }else if(node.isJoinNode){
        joinNodeLeftActivation(node,token);
    }else if(node.isNegativeNode){
        negativeNodeLeftActivation(node,token);
    }else if(node.isAnNCCNode){
        nccNodeLeftActivation(node,token);
    }else if(node.isAnNCCPartnerNode){
        nccPartnerNodeLeftActivation(node,token);
    }else if(node.isActionNode){
        activateActionNode(node,token);
    }else{
        throw new Error("Unknown node type leftActivated");
    }
    return token;
};

/**
   @function rightActivate
   @purpose selects what node to activate, given a new wme
*/
var rightActivate = function(node,wme){
    if(node.isJoinNode){
        joinNodeRightActivation(node,wme);
    }else if(node.isNegativeNode){
        negativeNodeRightActivation(node,wme);
    }else{
        throw new Error("Tried to rightActivate Unrecognised node");
    }
};

/**
   @function negativeNodeLeftActivation
*/
//Trigger a negative node from a new token
//brings in bindings, creates a new token as necessary,
//combining bindings to.
var negativeNodeLeftActivation = function(node,newToken){
    //Relink
    //console.log("Negative node left activation");
    if(node.items.length === 0){
        ReteUtil.relinkToAlphaMemory(node);
    }
    node.items.unshift(newToken);

    node.alphaMemory.items.forEach(function(item){
        var currWme = item.wme;
        var joinTestResult = ReteTestExecution.performJoinTests(node,newToken,currWme);
        if(joinTestResult){
            //adds itself to the token and
            //wme as necessary to block the token
            var joinResult = new RDS.NegativeJoinResult(newToken,currWme);
        }
    });

    //if no wmes block the token, pass it on down the network
    if(newToken.negJoinResults.length === 0){
        node.children.forEach(child=>leftActivate(child,newToken));
    }
    
};

/**
   @function negativeNodeRightActivation
*/
//trigger a negative node from a new wme,
//getting all tokens stored, comparing to the wme.
//any that the wme blocks, gets an additional negative Join result
//any that don't get blocked should already have been activated
var negativeNodeRightActivation = function(node,wme){
    console.log("Negative node right activation");
    node.items.forEach(function(currToken){
        var joinTestResult = ReteTestExecution.performJoinTests(node,currToken,wme);
        if(joinTestResult !== undefined && joinTestResult !== false){
            if(currToken.negJoinResults.length === 0){
                //todo: fix this
                var invalidatedActions = deleteDescendentsOfToken(currToken);
                ReteUtil.cleanupInvalidatedActions(invalidatedActions);
            }
            //Adds itself to the currToken and wme as
            //necessary
            var negJoinResult = new RDS.NegativeJoinResult(currToken,wme);
        }
    });
};

/**
   @function nccNodeLeftActivation
*/
//from a new token, trigger the subnetwork?
var nccNodeLeftActivation = function(nccNode,token){
    //Create and store the incoming token from prior join node
    if(nccNode.isAnNCCNode === undefined){
        throw new Error("nccNodeLeftActivation should be on an NCCNode");
    }
    if(token.isToken === undefined){
        throw new Error("nccNodeLeftActivation should be on a token");
    }
    var newToken = token;
    nccNode.items.unshift(newToken);

    //the partner's network MUST fire before the nccnode
    //hence this. all the new results' in the partners new result buffer,
    //are from the same origin as token
    //if there are new results to process:
    while(nccNode.partner && nccNode.partner.newResultBuffer.length > 0){
        var newResult = nccNode.partner.newResultBuffer.pop();
        //add the subnetworks result as a blocking token
        newToken.nccResults.unshift(newResult);
        //set the subnetwork result to have its parent as the new token
        newResult.parentToken = newToken;
    }

    //if the new token has no blocking tokens,
    //continue on
    if(newToken.nccResults.length === 0){
        nccNode.children.forEach(child=>leftActivate(child,newToken));
    }
};

/**
   @function nccPartnerNodeLeftActivation
*/
//the nccPartnerNode is activated by a new token from the subnetwork
//figure out who owns this new token from the main (positive) network
var nccPartnerNodeLeftActivation = function(partner,token){
    //the partner's ncc
    var nccNode = partner.nccNode,
        //the token created in left activate, with partner as owner
        newToken = token,
        ownersToken = token.parentToken,//the prior token
        ownersWme = token.wme,//the prior wme
        owner;

    
    for(var i = 1; i < partner.numberOfConjuncts; i++){
        //go up the owner chain
        ownersToken = ownersToken.parentToken;
        ownersWme = ownersWme.wme;
    }

    //find an owner in the ncc node's memory to link to
    if(nccNode !== undefined){
        var possible_tokens = nccNode.items.map(function(d){
            if(d.parentToken.id === ownersToken.id && d.wme.id === ownersWme.id){
                return d;
            }}).filter(d=> d !== undefined);
        owner = possible_tokens[0];
    }

    //link the owner and the new token
    if(owner !== undefined){
        //the necessary owner exists in the nccNode,
        //so update it:
        owner.nccResults.unshift(newToken);
        newToken.parent = owner;
        var invalidatedActions = deleteDescendentsOfToken(owner);
        ReteUtil.cleanupInvalidatedActions(invalidatedActions); 
    }else{        
        //else no owner: add to temp buffer to wait for the ncc node to be activated
        partner.newResultBuffer.unshift(newToken);
    }
};


/**
   @function activateIfNegatedJRIsUnblocked
*/
var activateIfNegatedJRIsUnblocked = function(nJR){
    var currJoinResult = nJR;
    //if the negation clears, activate it
    if(currJoinResult.owner.negJoinResults.length === 0){
        currJoinResult.owner.owningNode.children.forEach(child=>leftActivate(child,currJoinResult.owner));
    }
};


/**
   @function removeAlphaMemoryItemsForWME
   @purpose to remove a wme from all alpha memories it is stored in
   @postCondition wme.alphaMemoryItems is empty
*/
var removeAlphaMemoryItemsForWME = function(wme){
    //remove alpha memory items
    wme.alphaMemoryItems.forEach(function(item){
        //unlink the alphamemory from the item
        var index = item.alphaMemory.items.map(d=>d.id).indexOf(item.id);
        if(index !== -1){ item.alphaMemory.items.splice(index,1);}
        //unlink the alphaMemory itself if it is now empty
        //will unlink if am.items.length === 0
        ReteUtil.unlinkAlphaMemory(item.alphaMemory);
        //clear the item's links
        item.alphaMemory = undefined;
        item.wme = undefined;
    });
    //completely clear am items:
    wme.alphaMemoryItems = [];
};

/**
   @function deleteAllTokensForWME
   @purpose to cleanup all tokens a wme is part of
*/
var deleteAllTokensForWME = function(wme){
    var invalidatedActions = [];
    //For all tokens
    while(wme.tokens.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(wme.tokens[0]));
    }

    return invalidatedActions;
    
};

/**
   @function deleteAllNegJoinResultsForWME
   @purpose For negative conditions, discount the wme as a block
*/
var deleteAllNegJoinResultsForWME = function(wme){
    //unlink the negative Join results in the owning token
    wme.negJoinResults.forEach(function(jr){
        var index = jr.owner.negJoinResults.map(j=>j.id).indexOf(jr.id);
        if(index !== -1){
            jr.owner.negJoinResults.splice(index,1);
        }
        activateIfNegatedJRIsUnblocked(jr);
        //remove internal references:
        jr.owner = undefined;
        jr.wme = undefined;
    });
    //completely clear negjoinresults
    wme.negJoinResults = [];
};


/**
   @function removeNegJoinResultsForToken
   @purpose to delete any blocked tokens in negative conditions
*/
var removeNegJoinResultsForToken = function(token){
    //remove Negative join results
    token.negJoinResults.forEach(function(jr){
        var index = jr.wme.negJoinResults.map(d=>d.id).indexOf(jr.id);
        if(index !== -1){
            jr.wme.negJoinResults.splice(index,1);
        }
        //clear the references
        jr.wme = undefined;
        jr.token = undefined;
    });
    token.negJoinResults = [];
};


/**
   @function removeTokenFromNode
   @purpose To remove a token from whatever node created it
*/
//Now the utility functions for deleteing token:
var removeTokenFromNode = function(token){
    //Deal with if the owning node is NOT an NCC
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode === undefined
       && token.owningNode.isMemoryNode){
        //by removing the token as an element in that node
        var index = token.owningNode.items.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.owningNode.items.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromWME
   @purpose to clean a token up, removing it from any WME references
*/
var removeTokenFromWME = function(token){
    //remove the token from the wme it is based on
    if(token.wme && token.wme.tokens){
        var index = token.wme.tokens.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.wme.tokens.splice(index,1);
        }
    }
};

/**
   @function removeTokenFromParentToken
   @purpose cleanup the token from its parents list
*/
var removeTokenFromParentToken = function(token){
    //Remove the token from it's parent's child list
    if(token && token.parentToken){
        var index = token.parentToken.children.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.parentToken.children.splice(index,1);
        }
    }
};




/*
  Removes DOWNWARD links, but leaves UPWARD links intact
  Do a number of things:
  clean up tokens stored in a node
  remove any reference to the node from a connected alpha
  remove any reference to the node from a parent

  +: call recursively on any parent that has no children
*/

/**
   @function deleteNodeAndAnyUnusedAncestors
   @purpose cleanup an unused node and any parent nodes that are also unused once this node is gone.
*/
var deleteNodeAndAnyUnusedAncestors = function(node){
    var index,
        invalidatedActions = [];
    //if NCC, delete partner to
    if(node.isAnNCCNode){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.partner));
    }
    
    //clean up tokens
    if(node.isBetaMemory){
        while(node.items.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }
    if(node.isAnNCCPartnerNode){
        while(node.newResultBuffer.length > 0){
            invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(node.items[0]));
        }
    }

    //clean up any associated alphamemory
    if(node.isJoinNode || node.isNegativeNode && node.alphaMemory){
        index = node.alphaMemory.children.map(d=>d.id).indexOf(node.id);
        if(index > -1){
            node.alphaMemory.children.splice(index,1);
            node.alphaMemory.referenceCount--;
        }
        if(node.alphaMemory.referenceCount === 0){
            //TODO: write delete alpha memory
            //deleteAlphaMemory(node.alphaMemory);
        }
    }
    
    //remove the node from its parent
    if(node.parent){
        //check the child list:
        index = node.parent.children.map(d=>d.id).indexOf(node.id);
        if(index !== -1){                            
            node.parent.children.splice(index,1);
        }else{
            //check the unlinked children list:
            index = node.parent.unlinkedChildren.map(d=>d.id).indexOf(node.id);
            if(index !== -1){
                node.parent.unlinkedChildren.splice(index,1);
            }
        }
    }

    //delete parent node if its got no children
    if(node.parent && node.parent.children.length === 0
       && node.parent.unlinkedChildren
       && node.parent.unlinkedChildren.length === 0){
        invalidatedActions = invalidatedActions.concat(deleteNodeAndAnyUnusedAncestors(node.parent));
    }
    //deallocate memory for none

    return invalidatedActions;
    
};


/**
   @function deleteDescendentsOfToken
   @purpose simplification of removing children of a token, but not the token itself
   @utility
*/
//utility function to delete all descendents without deleting the token
var deleteDescendentsOfToken = function(token){
    var invalidatedActions = [];
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    return invalidatedActions;
};


/**
   @function deleteTokenAndDescendents
   @purpose To remove a token and clean it 
   delete a token and all the tokens that rely on it
   a bit of a frankenstein. Deletes the token,
   deletes descendents, but also sets and cleans up 
   left unlinking of join nodes, AND
   activates NCC's that are no longer blocked
*/
var deleteTokenAndDescendents = function(token){
    var invalidatedActions = [];
    
    //Recursive call:
    while(token.children.length > 0){
        invalidatedActions = invalidatedActions.concat(deleteTokenAndDescendents(token.children[0]));
    }

    //Base Cases:
    //remove memory items
    removeTokenFromNode(token);
    removeTokenFromWME(token);
    removeTokenFromParentToken(token);
    
    ReteUtil.ifEmptyBetaMemoryUnlink(token.owningNode);
    ReteUtil.ifEmptyNegNodeUnlink(token.owningNode,token.id);

    removeNegJoinResultsForToken(token);

    cleanupNCCResultsInToken(token);
    cleanupNCCPartnerOwnedToken(token);
    
    if(token && token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken.nccResults.length === 0){
        //Activate newly unblocked Token
        //todo: should this be nccnode AND/OR negNode?
        token.owningNode.nccNode.children.forEach(d=>leftActivate(d,token.parentToken));
    }

    //get the queued actions linked with the token, and return them for cleanup
    invalidatedActions = invalidatedActions.concat(token.proposedActions);
    
    return invalidatedActions;
};

/**
   @function cleanupNCCResultsInToken
*/
var cleanupNCCResultsInToken = function(token){
    //NCCNODE
    if(token && token.owningNode && token.owningNode.isAnNCCNode){
        //for all the nccResult tokens, delete them
        token.nccResults.forEach(function(nccR){
            //remove the nccR token from its linked wme
            if(nccR.wme){
                var index = nccR.wme.tokens.map(d=>d.id).indexOf(nccR.id);
                if(index !== -1){
                    nccR.wme.tokens.splice(index,1);
                }
            }
            if(nccR.parent){
                //remove the token from it's parent
                var nccRindex = nccR.parent.children.map(d=>d.id).indexOf(nccR.id);
                if(nccRindex !== -1){
                    nccR.parent.children.splice(nccRindex,1);
                }
            }
        });
        //clear the nccResults
        token.nccResults = [];
        return true;
    }else{
        return false;
    }
};

/**
   @function cleanupNCCPartnerOwnedToken
*/
var cleanupNCCPartnerOwnedToken = function(token){
    //NCCPARTNERNODE
    if(token.owningNode
       && token.owningNode.isAnNCCPartnerNode
       && token.parentToken){
        //remove from owner.nccResults:
        var index = token.parentToken.nccResults.map(d=>d.id).indexOf(token.id);
        if(index !== -1){
            token.parentToken.nccResults.splice(index,1);
        }
        return true;
    }else{
        return false;
    }
};



var moduleInterface = {
    "deleteDescendentsOfToken" : deleteDescendentsOfToken,
    "removeAlphaMemoryItemsForWME" : removeAlphaMemoryItemsForWME,
    "deleteAllTokensForWME" : deleteAllTokensForWME,
    "deleteAllNegJoinResultsForWME" : deleteAllNegJoinResultsForWME,
    "deleteNodeAndAnyUnusedAncestors" : deleteNodeAndAnyUnusedAncestors,
    "leftActivate" : leftActivate,
    "rightActivate" : rightActivate,
    "alphaNodeActivation" : alphaNodeActivation,
    "activateIfNegatedJRIsUnblocked" : activateIfNegatedJRIsUnblocked,
};
module.exports = moduleInterface;

});

define('ReteNetworkBuilding',['require','exports','module','./ReteDataStructures','./ReteUtilities','./ReteActivationAndDeletion','underscore'],function (require, exports, module) {var RDS = require('./ReteDataStructures'),
    ReteUtil = require('./ReteUtilities'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    _ = require('underscore');


/**
   @function buildOrShareNetworkForConditions
   @purpose to add all given conditions to the network
*/
var buildOrShareNetworkForConditions = function(parent,conditions,rootAlpha,allNodes,reteNet){
    var currentNode = parent;
    var alphaMemory;
    //for each condition
    conditions.forEach(function(condition){
        if(condition.tags.type !== 'condition' && condition.tags.type !== 'negConjCondition'
           && condition.tags.type !== 'negCondition' && condition.tags.type !== 'rule'){
            throw new Error("Inappropriate condition format");
        }
        //get the binding tests for join nodes
        var tests = _.pairs(condition.bindings);
        
        if(condition.tags.isPositive !== undefined){
            //Build a positive condition:
            currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareJoinNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNegative !== undefined){
            //Build a negative condition:
            alphaMemory = buildOrShareAlphaMemory(condition,rootAlpha,allNodes,reteNet);
            currentNode = buildOrShareNegativeNode(currentNode,alphaMemory,tests,reteNet);
        }else if(condition.tags.isNCCCondition !== undefined){
            //Build a Negated Conjunctive Condition
            currentNode = buildOrShareNCCNodes(currentNode,condition,rootAlpha,allNodes,reteNet);
        }else if(condition.tags.type === 'rule'){
            //for using other rules as composable conditions
            var ruleConditions = _.keys(condition.conditions).map(d=>allNodes[d]);
            currentNode = buildOrShareNetworkForConditions(currentNode,ruleConditions,rootAlpha,allNodes,reteNet);
        }else{
            console.error("Problematic Condition:",condition);
            throw new Error("Unrecognised condition type");
        }
    });
    
    //Everything is build, tack on a final memory and return that
    //to have action connected to.
    var finalBetaMemory = buildOrShareBetaMemoryNode(currentNode,reteNet);
    return finalBetaMemory;
};

/**
   @function buildOrShareConstantTestNode
   @purpose Reuse, or create a new, constant test node, for the given test
*/
var buildOrShareConstantTestNode = function(parent,constantTestSpec,reteNet){
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var node = children[i];
        if(ReteUtil.compareConstantNodeToTest(node,constantTestSpec)){
            return node;
        }
    }
    //No existing, create a new node:
    var newAlphaNode = new RDS.AlphaNode(parent,constantTestSpec);
    reteNet.storeNode(newAlphaNode);
    return newAlphaNode;
};


/**
   @function buildOrShareAlphaMemory
   @purpose Create alpha network as necessary, stick an alpha memory on the end
   @reminder Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}
*/
var buildOrShareAlphaMemory = function(condition,root,allNodes,reteNet){
    var currentNode = root,
        constantTests = condition.constantTests;//[{field:,op:,value:}]
    
    currentNode = constantTests.reduce(function(m,v){
        return buildOrShareConstantTestNode(m,v,reteNet);
    },currentNode);
    
    //see if there is an existing memory for this condition.
    //if so, return existing alphamemory
    if(currentNode.outputMemory !== undefined){
        return currentNode.outputMemory;
    }
    //else: create the alpha memory
    //ctor will update the current node's outputMemory field
    var newAlphaMemory = new RDS.AlphaMemory(currentNode);
    //run wmes in working memory against the alpha network
    reteNet.storeNode(newAlphaMemory);
    return newAlphaMemory;
};

/**
   @function buildOrShareBetaMemoryNode
   @purpose given a node (ie: join), stick a betamemory on it as a child
*/
var buildOrShareBetaMemoryNode = function(parent,reteNet){
    //if passed in the dummy top node, return it:
    if(parent.isBetaMemory === true){
        return parent;
    }
    
    //if theres an available beta memory to use,
    //return that
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i++){
        var child = children[i];
        if(child.isBetaMemory){
            return child;
        }
    }
    //else: create a new beta memory
    //ctor should update  parent's children
    var newBetaMemory = new RDS.BetaMemory(parent);
    //update it with matches
    updateNewNodeWithMatchesFromAbove(newBetaMemory);
    reteNet.storeNode(newBetaMemory);
    //return new beta memory
    return newBetaMemory;
};




/**
   @function buildOrShareJonNode
   @purpose To reuse, or create a new, join node linking an alpha memory and betamemory
*/
var buildOrShareJoinNode = function(parent,alphaMemory,tests,reteNet){
    //convert tests if necessary:
    if(!(tests instanceof Array)){
        tests = _.pairs(tests);
    }
    
    //see if theres a join node to use already
    var allChildren = parent.children.concat(parent.unlinkedChildren);
    for(var i = 0; i < allChildren.length; i++){
        var child = allChildren[i];
        if(child.isJoinNode && child.alphaMemory.id === alphaMemory.id && ReteUtil.compareJoinTests(child.tests,tests)){
            //return it
            return child;
        }
    }
    //else: create a new join node
    //increment alphamemories reference count in the constructor
    var newJoinNode = new RDS.JoinNode(parent,alphaMemory,tests);
    //set the nearest ancestor
    newJoinNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);

    //if either parent memory is empty, unlink
    if(parent.items.length === 0){
        //BETA IS EMPTY: UNLINK RIGHT
        var index = alphaMemory.children.map(d=>d.id).indexOf(newJoinNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.unshift(removed[0]);
    }else if(alphaMemory.items.length === 0){
        //ALPHA IS EMPTY: UNLINK LEFT
        var newNodeIndex = parent.children.map(d=>d.id).indexOf(newJoinNode.id),
            removedNode = parent.children.splice(newNodeIndex,1);
        parent.unlinkedChildren.unshift(removedNode[0]);
    }
    //return new join node
    reteNet.storeNode(newJoinNode);
    
    return newJoinNode;
};

/**
   @function buildOrShareNegativeNode
   @purpose To reuse, or build a new, negative node
*/
var buildOrShareNegativeNode = function(parent,alphaMemory,tests,reteNet){
    if(!(tests instanceof Array)) { tests = _.pairs(tests); }
    //see if theres an existing negative node to use
    var children = _.values(parent.children);
    for(var i = 0; i < children.length; i ++){
        var child = children[i];
        if(child.isNegativeNode
           && child.alphaMemory.id === alphaMemory.id
           && ReteUtil.compareJoinTests(child.tests,tests)){
            return child;
        }
    }
    var newNegativeNode = new RDS.NegativeNode(parent,alphaMemory,tests);
    newNegativeNode.nearestAncestor = ReteUtil.findNearestAncestorWithAlphaMemory(parent,alphaMemory);
    //update with matches
    updateNewNodeWithMatchesFromAbove(newNegativeNode);
    //unlink if it has no tokens
    if(newNegativeNode.items.length === 0){
        var index = alphaMemory.children.map(d=>d.id).indexOf(newNegativeNode.id),
            removed = alphaMemory.children.splice(index,1);
        alphaMemory.unlinkedChildren.push(removed[0]);
    }
    //return new negative node

    reteNet.storeNode(newNegativeNode);
    return newNegativeNode;
};

/**
   @function buildOrShareNCCNodes
   @purpose construction of NCCConditions
*/
var buildOrShareNCCNodes = function(parent,condition,rootAlpha,allNodes,reteNet){
    if(condition.tags.isNCCCondition === undefined){
        throw new Error("BuildOrShareNCCNodes only takes NCCCondition");
    }
    //build a network for the conditions
    var conditions = _.keys(condition.conditions).map(d=>allNodes[d]),
        //build the subnetwork
        bottomOfSubNetwork = buildOrShareNetworkForConditions(parent,conditions,rootAlpha,allNodes,reteNet);
    //find an existing NCCNode with partner to use
    for(var i = 0; i < parent.children.length; i++){
        var child = parent.children[i];
        if(child.isAnNCCNode && child.partner.parent.id === bottomOfSubNetwork.id){
            return child;
        }
    }
    
    //else: build NCC and Partner nodes
    var newNCC = new RDS.NCCNode(parent),
        newNCCPartner = new RDS.NCCPartnerNode(bottomOfSubNetwork,condition.conditions.length);

    newNCC.partner = newNCCPartner;
    newNCCPartner.nccNode = newNCC;
    //update NCC
    updateNewNodeWithMatchesFromAbove(newNCC);
    //update partner
    updateNewNodeWithMatchesFromAbove(newNCCPartner);

    reteNet.storeNode(newNCC);
    reteNet.storeNode(newNCCPartner);
    
    return newNCC;
};


/**
   @function updateNewNodeWithMatchesFromAbove
   @purpose pulls tokens down from parent upon new creation
*/
//essentially a 4 state switch:
//betaMemory, joinNode, negativeNode, NCC
var updateNewNodeWithMatchesFromAbove = function(newNode){
    var i, token;
    var parent = newNode.parent;
    if(parent.isBetaMemory){
        for(i in parent.items){
            ReteActivationsAndDeletion.leftActivate(newNode,parent.items[i]);
        }
    }else if(parent.isJoinNode){
        var savedChildren = parent.children,
            items = _.values(parent.alphaMemory.items);
        parent.children = [newNode];
        for(i = 0; i < items.length; i++){
            var item = items[i];
            ReteActivationsAndDeletion.rightActivate(parent,item.wme);
        }
        parent.children = savedChildren;
    }else if(parent.isNegativeNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = items[i];
            if(token.negJoinResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }else if(parent.isAnNCCNode){
        var items = _.values(parent.items);
        for(i = 0; i < items.length; i++){
            token = parent.items[i];
            if(token.nccResults.length === 0){
                ReteActivationsAndDeletion.leftActivate(newNode,token);
            }
        }
    }
};



var moduleInterface = {
    "buildOrShareNetworkForConditions" : buildOrShareNetworkForConditions,
};
module.exports =  moduleInterface;


});

define('RuleCtors',['require','exports','module'],function (require, exports, module) {//Ctors for Rules

/**
   Rule Ctor. Holds conditions and actions
*/
var nextId = 0;

var Rule = function(name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { type : "rule" };
    this.conditions = {};
    this.actions = {};
};

//testsAndBindings = { tests : [ [var,op,val]...], bindings : [ [var,val,[op,var]]] }
Rule.prototype.newCondition = function(type,testsAndBindings){
    var newCondition = new Condition(type);
    //Add all tests
    testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    this.addCondition(newCondition);
    return this;
};

//valuesArithRegexsAndTiming = { values : [], arith : [], regexs : [], timing : [] }
Rule.prototype.newAction = function(type,name,valuesArithRegexsAndTiming){
    var newAction = new Action(type,name);
    valuesArithRegexsAndTiming.values.forEach(d=>newAction.addValue(...d));
    valuesArithRegexsAndTiming.arith.forEach(d=>newAction.addArithmetic(...d));
    valuesArithRegexsAndTiming.regexs.forEach(d=>newAction.addRegex(...d));
    newAction.addTiming(...valuesArithRegexsAndTiming.timing);
    this.addAction(newAction);
    return this;
};

Rule.prototype.addCondition = function(condition){
    this.conditions[condition.id] = condition;
    return this;
};

Rule.prototype.addAction = function(action){
    this.actions[action.id] = action;
    return this;
};

/**
   Condition Ctor. Holds tests, bindings, and other conditions
 */
var Condition = function(type){
    this.id = nextId++;
    type = type === undefined ? "condition" : type;
    switch(type){
    case "condition":
        this.tags = { type : "condition",
                      isPositive : true };
        break;
    case "negCondition":
        this.tags = { type : "condition",
                      isNegative : true };
        break;
    case "negConjCondition":
        this.tags = { isNCCCondition : true,
                      type : "negConjCondition" };
        break;
    default:
        throw new Error("Unrecognised condition");
    };
    this.constantTests = [];
    this.bindings = {};
    this.conditions = {};    
};

Condition.prototype.addTest = function(field,op,val){
    this.constantTests.push({
        field : field,
        operator : op,
        value : val
    });
    return this;
};

Condition.prototype.addBinding = function(boundName,dataName,tests){
    //tests as pairs of op and value/boundName
    this.bindings[boundName] = [dataName,tests];
};

Condition.prototype.newCondition = function(type,testsAndBindings){
    if(this.type !== 'negConjCondition') { throw new Error("Only NCC's can have sub conditions"); }
    var newCondition = new Condition(type);
    testsAndBindings.tests.forEach(d=>newCondition.addTest(...d));
    testsAndBindings.bindings.forEach(d=>newCondition.addBinding(...d));
    this.conditions[newCondition.id] = newCondition;
}

/**
   Action constructor, defines data/values to put in a new wme,
   arithmetic and regex actions to apply to those values
 */
var Action = function(actionType,name){
    this.id = nextId++;
    this.name = name || "anon";
    this.tags = { actionType : actionType || "assert" };
    this.values = {};
    this.arithmeticActions = {};
    this.regexActions = {};
    //Specify the timing of the proposed action to create:
    this.timing = {
        invalidateOffset : 0,
        performOffset : 0,
        unperformOffset : 0
    }
};

Action.prototype.addValue = function(varName,value){
    this.values[varName] = value;
    return this;
};

Action.prototype.addArithmetic = function(varName,op,value){
    this.arithmeticActions[varName] = [op,value];
    return this;
}

Action.prototype.addRegex = function(varName,regex,options,replaceValue){
    this.regexActions[varName] = [regex,options,replaceValue];
    return this;
};

Action.prototype.addTiming = function(invalid,perform,unperform){
    this.timing = {
        invalidateOffset : invalid,
        performOffset : perform,
        unperformOffset : unperform
    };
    return this;
};

module.exports = {
    Rule : Rule,
    Condition : Condition,
    Action : Action
};

});

define('ReteClassInterface',['require','exports','module','underscore','./ReteDataStructures','./ReteNetworkBuilding','./ReteActivationAndDeletion','./ReteUtilities','./RuleCtors','./ReteActions','./ReteComparisonOperators','./ReteArithmeticActions'],function (require, exports, module) {/**
   @file ReteClassInterface
   @purpose Defines a class based ReteNet interface
 */

var _ = require('underscore'),
    RDS = require('./ReteDataStructures'),
    ReteNetworkBuilding = require('./ReteNetworkBuilding'),
    ReteActivationsAndDeletion = require('./ReteActivationAndDeletion'),
    ReteUtil = require('./ReteUtilities'),
    RuleCtors = require('./RuleCtors'),
    ReteActions = require('./ReteActions'),
    ComparisonOperators = require('./ReteComparisonOperators'),
    ArithmeticOperators = require('./ReteArithmeticActions');


/**
   @data ReteNet
   @purpose A Data structure to hold what you need to start a retenet.
*/
var ReteNet = function(){
    this.dummyBetaMemory = new RDS.BetaMemory();
    this.rootAlpha = new RDS.AlphaNode();

    //To store proposal functions and performance actions
    //Each element of form {name: "",performFunc : func, proposeFunc : func };
    this.actionFunctions = ReteActions;

    //RuleCtor storage
    this.RuleCtors = RuleCtors;
    //Comparison operators
    this.ComparisonOperators = ComparisonOperators;
    //Arithmetic Operators:
    this.ArithmeticOperators = ArithmeticOperators;
    
    //DataStructures
    this.DataStructures = RDS;
    
    
    //Actions indexed by rule node id:
    this.actions = [];
    //WMEs indexed by id:
    this.allWMEs = [];

    //Actions whose conditions are satisfied, indexed by id
    this.proposedActions = [];
    //Actions that were chosen to be performed
    this.enactedActions = [];

    //Storage of internal nodes:
    this.allReteNodes = {};
    this.allReteNodesByType = {
        "constantTests" : {},
        "alphaMemories" : {},
        "betaMemories" : {},
        "joinNodes" : {},
        "negativeNodes" : {},
        "nccNodes" : {},
        "nccPartnerNodes" : {},
        "actionNodes" : {},
    };
    

    this.currentTime = 1;
    //Schedule Actions:
    this.schedule = {
        assertions : [],
        retractions : [],
        modifications: []
    };

};

ReteNet.prototype.storeWME = function(wme){
    this.allWMEs[wme.id] = wme;
};


//Clear the record of actions that have been performed
ReteNet.prototype.clearHistory = function(){
    this.enactedActions = [];
};

//Clear the list of proposed actions
ReteNet.prototype.clearProposedActions = function(){
    this.proposedActions = [];
};

//Assert Immediately
ReteNet.prototype.assertWME = function(wme){
    //console.log("ASSERTING:",wme);
    if(wme.isWME === undefined || wme.id === undefined){
        wme = new RDS.WME(wme,this.currentTime);
        this.storeWME(wme);
    }
    //Actually push the wme into the net
    ReteActivationsAndDeletion.alphaNodeActivation(this.rootAlpha,wme);
    return wme.id;
};

//Retract Immediately
ReteNet.prototype.retractWME = function(wme){
    //console.log("retracting immediately:",wme);
    //if not given the wme directly
    if(wme.isWME === undefined){
        //if given a wme id
        if(Number.isInteger(wme) && this.allWMEs[wme] !== undefined){
            wme = this.allWMEs[wme];
            //if given a graph node with a related wme
        }else if(wme.wmeId !== undefined && this.allWMEs[wme.wmeId] !== undefined){
            console.log("Retrieving wme using wmeId:",wme.wmeId);
            wme = this.allWMEs[wme.wmeId];
        }else{
            console.log("Unknown:",wme);
            throw new Error("Unknown wme to retract");
        }
    }
    //console.log("Retracting:",wme);
    ReteActivationsAndDeletion.removeAlphaMemoryItemsForWME(wme);
    var invalidatedActions = ReteActivationsAndDeletion.deleteAllTokensForWME(wme);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
    ReteActivationsAndDeletion.deleteAllNegJoinResultsForWME(wme);
    //Record when the wme was retracted
    wme.lifeTime[1] = this.currentTime;
    return wme;
};


//Modify immediately
ReteNet.prototype.modifyWME = function(wme,modifyFunction){
    var retractedWME = this.retractWME(wme),
        data = retractedWME.data,
        modifiedData = modifyFunction(data);
    if(modifiedData === undefined || modifiedData === null) {
        throw new Error("Modify function must return the new data");
    }
    return this.assertWME(modifiedData);
    
};

//Schedule an action by it's ID, ALSO scheduling any parallel actions
ReteNet.prototype.scheduleAction = function(actionId){
    if(this.proposedActions[actionId] === undefined){
        throw new Error("Invalid action specified");
    }
    var action = this.proposedActions[actionId],
        parallelActions = action.parallelActions.map(d=>this.proposedActions[d]);

    this.addToSchedule(action);
    parallelActions.forEach(d=>this.addToSchedule(d));
    
};

//Utility method to add an action object
ReteNet.prototype.addToSchedule = function(action){
    if(action.actionType === undefined || action.payload === undefined || action.timing === undefined){
        throw new Error("Scheduling action failure");
    }
    if(this.schedule[action.actionType] === undefined){
        this.schedule[action.actionType] = [];
    }
    var performTime = this.currentTime + action.timing.performOffset;
    if(this.schedule[action.actionType][performTime] === undefined){
        this.schedule[action.actionType][performTime] = [];
    }
    this.schedule[action.actionType][performTime].push(action);
    //Action is no longer proposed, so remove it from the token
    action.token.proposedActions = _.reject(action.token.proposedActions,d=>d.id===action.id);
};

//Step Time forward
ReteNet.prototype.stepTime = function(){
    //get all actions scheduled at the current timepoint
    var actions = _.values(this.schedule),
        actionsForTimePoint = _.flatten(actions.map(d=>d[this.currentTime]).reject(d=>d===undefined));
    //perform those actions
    actionsForTimePoint.forEach(function(d){
        var performanceFunction = this.actionFunctions(d.actionType).performFunc;
        performanceFunction(this,d.payload);
        this.enactedActions.push(d);
    },this);

    //todo: remove performed actions from proposed action list
    
    //cleanup invalidated actions
    this.proposedActions = _.reject(this.proposedActions,d=>d.timing.invalidateTime === this.currentTime);
    
    this.currentTime++;
};

//Add a rule
ReteNet.prototype.addRule = function(ruleId,components){
    if(ruleId instanceof Array){
        return ruleId.map(d=>this.addRule(d,components));
    }
    if(ruleId instanceof this.RuleCtors.Rule){
        var convertedComponents = this.convertRulesToComponents(ruleId);
        return this.addRule(ruleId.id,convertedComponents);
    }
    //-----------
        //Add a single rule:
    if(!Number.isInteger(ruleId) || components[ruleId] === undefined){
        throw new Error("Unrecognised rule id specified");
    }
    var rule = components[ruleId],
        conditions = _.keys(rule.conditions).map(d=>components[d]),
        //build network with a dummy node for the parent
        finalBetaMemory = ReteNetworkBuilding.buildOrShareNetworkForConditions(this.dummyBetaMemory,conditions,this.rootAlpha,components,this),
        //Get the action descriptions that are triggered by the rule:
        actionDescriptions = _.keys(rule.actions).map(d=>components[d]),
        //Bind proposalFuncs with actionDescriptions
        boundActionDescriptions = actionDescriptions.map(function(d){
            if(this.actionFunctions[d.tags.actionType] === undefined){
                throw new Error("Unrecognised action type");
            }
            return _.bind(this.actionFunctions[d.tags.actionType].proposeFunc,d);
        },this),
        //Create the action, with the bound action functions
        ruleAction = new RDS.ActionNode(finalBetaMemory,actionDescriptions,boundActionDescriptions,rule.name,this);

    //Add the bound actions into the action node:
    ruleAction.boundActions = boundActionDescriptions;
    this.actions[rule.id] = ruleAction;
    return ruleAction;
};


//Remove rule
ReteNet.prototype.removeRule = function(rule){
    if(actionNode instanceof Array){
        actionNode.forEach(d=>this.removeRule(d));
        return;
    }
    //delete from bottom up
    var invalidatedActions = ReteActivationsAndDeletion.deleteNodeAndAnyUnusedAncestors(actionNode);
    ReteUtil.cleanupInvalidatedActions(invalidatedActions);
};

//register a join action proposal and performance function
//as a single object of form : {name: "", propose:func, perform:func};
ReteNet.prototype.registerAction = function(actionObj){
    if(actionObj.name === undefined || actionObj.performFunc === undefined || actionObj.proposeFun === undefined){
        throw new Error("Action Registration Failure");
    }
    if(this.actionFunctions[actionObj.name] !== undefined){
        throw new Error("Registration Attempt for existing Action");
    }
    this.actionFunctions[actionObj.name] = actionObj;
};


//Utility method:
ReteNet.prototype.storeNode = function(node){
    this.allReteNodes[node.id] = node;
    var storeTarget = "unknown";
    if(node.isConstantTestNode){
        storeTarget = "constantTests";
    }else if(node.isAlphaMemory){
        storeTarget = "alphaMemories";
    }else if(node.isBetaMemory){
        storeTarget = "betaMemories";
    }else if(node.isJoinNode){
        storeTarget = "joinNodes";
    }else if(node.isActionNode){
        storeTarget = "actionNodes";
    }else if(node.isNegativeNode){
        storeTarget = "negativeNodes";
    }else if(node.isAnNCCNode){
        storeTarget = "nccNodes";
    }else if(node.isAnNCCPartnerNode){
        storeTarget = "nccPartnerNodes";
    }

    if(this.allReteNodesByType[storeTarget] !== undefined){
        this.allReteNodesByType[storeTarget][node.id] = node;
    }else{
        console.log(node);
        throw new Error("unrecognised type attempted to be stored");
    }
};

//convert a rule to a component list
//used to convert the jsRete Rule object to the standard form for loading
ReteNet.prototype.convertRulesToComponents = function(rules){
    if(!(rules instanceof Array)){
        rules = [rules];
    }
    var actions = _.flatten(rules.map(d=>_.values(d.actions))),
        conditions = _.flatten(rules.map(d=>_.values(d.conditions))),
        all = actions.concat(conditions).concat(rules),
        components = all.reduce(function(m,v){
            m[v.id] = v;
            return m;
        },{});
    return components;
};

module.exports = ReteNet;

});


require(["ReteClassInterface"]);
define('underscore',function() { return _; }); return require('ReteClassInterface'); }));
/**
   @purpose Defines prototype methods for shell node creation
 */



define('ShellModules/shell_node_addition',['underscore','../Node/Constructors','Rete'],function(_,getCtor,Rete){
    "use strict";
    var ShellPrototype = {};

        /**
       @class CompleteShell
       @method addLink
       @purpose Add an ID number and name to a field of an object
       @param node the node to add the link FROM
       @param target the field of the node to link FROM
       @param id the id of the node to link TO
       @param name the name of the node to link TO
    */
    ShellPrototype.addLink = function(node,target,id,name){
        if(isNaN(Number(id))){
            throw new Error("Trying to link without providing a valid id number");
        }
        if(node && node[target]){
            node[target][Number(id)] = name;
        }else{
            throw new Error("Unrecognised target");
        }
    };


    /**
       @class CompleteShell
       @method addNode
       @purpose Create a new node, and link it to the cwd of the shell
       @param name The name of the new node
       @param target The field of the cwd to add the new node to
       @param type The type of node the new node should be annotated as. See GraphStructureConstructors
       @return the newly created node
    */
    ShellPrototype.addNode = function(name,target,type,values,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        
        if(name === null || name === undefined || name === "") {
            name = type || "anon";
            console.warn("making an anonymous node");
        }
        //validate input:
        if(source[target] === undefined){ 
            console.warn("Creating target: ",target,source);
            source[target] = {};
        }
        type = type || "GraphNode";

        var ctor = getCtor(type),
            newNode;
        
        if(target === 'parents' || target === 'parent'){
            //if adding to parents,don't store the cwd as newnode's parent
            newNode = new ctor(name,undefined,type);
            //add the cwd to the newNodes children:
            this.addLink(newNode,'children',source.id,source.name);
            //newNode.children[this.cwd.id] = true;
        }else{
            newNode = new ctor(name,source,type);
        }

        //add to cwd:
        //console.log("Linking new node:",newNode);
        this.addLink(source,target,newNode.id,newNode.name);

        //Store in allNodes:
        if(this.allNodes[newNode.id] !== undefined){
            console.warn("Assigning to existing node:",newNode,this.allNodes[newNode.id]);
        }
        this.allNodes[newNode.id] = newNode;

        //get all subrelation objects:
        var relationObjects = newNode.getRelationObjects();
        while(relationObjects.length > 0){
            //get an object off
            var obj = relationObjects.shift();
            //get any sub objects and add them to the list
            relationObjects = relationObjects.concat(obj.getRelationObjects());
            //add the obj to allNodes
            this.allNodes[obj.id] = obj;
        }
        

        //If the cwd WAS disconnected in some way,
        //remove it from that designation
        if(source[target][this.disconnected.noParents.id]){
            this.rm(this.disconnected.noParents.id,source.id);
        }
        if(source[target][this.disconnected.noChildren.id]){
            this.rm(this.disconnected.noChildren.id,source.id);                
        }
        
        return newNode;        
    };

    /**
       @class CompleteShell
       @method addTest
       @purpose Add a constant test to a specified condition of the current rule
       @param conditionNumber The position in the condition array to add the test to
       @param testField the wme field to test
       @param op The operator to use in the test
       @param value The constant value to test against
     */
    ShellPrototype.addTest = function(conditionId,testParams,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Adding test:",conditionId,testParams,source.conditions);
        //check you're in a rule
        if(source.tags.type !== 'rule' && source.tags.type !== 'negConjCondition'){
            throw new Error("Trying to modify a rule when not located at a rule");
        }
        //check the specified condition exists
        if(source.conditions[conditionId] === undefined || this.allNodes[conditionId] === undefined){
            console.log(conditionId,source.conditions);
            throw new Error("Can't add a test to a non-existent condition");
        }
        if(testParams.length !== 3){
            throw new Error("Insufficient test specification");
        }
        //Check the operator is a defined one
        if(this.reteNet.ComparisonOperators[testParams[1]] === undefined){
            throw new Error("Unrecognised operator");
        }
        var condition = this.allNodes[conditionId];
        //Create the test
        condition.setTest(undefined,testParams[0],testParams[1],testParams[2]);
    };

    /**
       @class CompleteShell
       @method addAction
       @purpose add a new action to current rule
       @param valueArray The names of actions to create
       @return newActions an array of all actions created
    */
    ShellPrototype.addAction = function(valueArray,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule'){
            throw new Error("Trying to modify a rule when not located at a rule");
        }
        var name = valueArray.shift() || "anonAction";
        
        //add an action node to cwd.actions
        var newAction = this.addNode(name,'actions','action',valueArray,sourceId);
        return newAction;
    };


    return ShellPrototype;
});

/**
   @purpose Defines Shell prototype methods for deleting nodes
 */



define('ShellModules/shell_node_deletion',['underscore'],function(_){
    "use strict";
    var ShellPrototype = {};

        /**
       @class CompleteShell
       @method deleteNode
       @purpose remove a node from the list of all nodes
       @param id The id of the node to remove
     */
    ShellPrototype.deleteNode = function(id){
        if(this.allNodes[id] === undefined){
            throw new Error("unrecognised node to delete");
        }
        delete this.allNodes[id];
    };

    /**
       @class CompleteShell
       @method rm
       @purpose remove a node link from the cwd
       @param nodeToDelete The node object to remove from the cwd
     */
    ShellPrototype.rm = function(nodeToDelete,target,sourceId){
        if(target === undefined) { target = 'parents'; }
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        var removedNode = null;
        if(!isNaN(Number(nodeToDelete))){
            //delete numeric id node
            removedNode = this.removeNumericId(Number(nodeToDelete),target,source);
            if(!removedNode){
                removedNode = this.removeNumericId(Number(nodeToDelete),'children',source);
            }
        }else{
            throw new Error("Removing a node requires an id");
        }

        if(removedNode){
            //TODO
            //this.cleanupNode(removedNode,source);
            //delete this.allNodes[Number(nodeToDelete)];
        }
    };

    /**
       @class CompleteShell
       @method removeNumericId
       @param id
       @param target
       @TODO check this
     */
    ShellPrototype.removeNumericId = function(id,target,source){
        var removedNode = null;
        if(source[target][id] !== undefined){
            removedNode = this.allNodes[id];
            delete source[target][id];
        }
        return removedNode;
    };

    /**
       @class CompleteShell
       @method cleanupNode
       @purpose To link a node to the disconnected nodes if it no longer has active links
       @param node
       @param owningNode
     */
    ShellPrototype.cleanupNode = function(node,owningNode){
        //remove the owning node from any link in the node:
        if(node.parents && node.parents[owningNode.id]){
            delete node.parents[owningNode.id];
        }
        if(node.children && node.children[owningNode.id]){
            delete node.children[owningNode.id];
        }
        
        //if now parent-less:
        if(_.values(node.parents).filter(function(d){return d;}).length === 0){
            this.addLink(this.disconnected.noParents,'children',node.id,node.name);
            this.addLink(node,'parents',this.disconnected.noParents.id,this.disconnected.noParents.name);
        }
        //if now child-less:
        if(_.values(node.children).filter(function(d){return d;}).length === 0){
            
            this.addLink(this.disconnected.noChildren,'parents',node.id,node.name);
            this.addLink(node,'children',this.disconnected.noChildren.id,this.disconnected.noChildren.name);
        }
    };
    //RM FINISHED

    /**
       @class CompleteShell
       @method removeAction
       @purpose remove an action from the current rule
       @note: an action is still a node, so is still in allnodes
     */
    ShellPrototype.removeAction = function(actionId,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.actions[actionId] === undefined){
            throw new Error("Can't delete a non-existent action");
        }
        //remove from the rule
        delete source.actions[actionId];
        //remove from allnodes
    };

    /**
       @class CompleteShell
       @method removeCondition
       @purpose remove a condition, and its tests, from a rule
     */
    ShellPrototype.removeCondition = function(condId,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;        
        if(source.conditions[condId] === undefined){
            throw new Error("Can't delete an non-existent condition");
        }
        delete source.conditions[condId];
    };

    /**
       @class CompleteShell
       @method removeTest
       @purpose remove a test from a condition
       @param condNum
       @param testNum
     */
    ShellPrototype.removeTest = function(condId,testId,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        
        if(source.conditions[condId] === undefined ||
           this.allNodes[condId] === undefined ||
           this.allNodes[condId].constantTests[testId] === undefined){
            throw new Error("can't delete a non-existent test");
        }
        var condition = this.allNodes[condId];
        if(condition.constantTests[testId] !== undefined){
            condition.constantTests.splice(testId,1);
        }
    };

    /**
       @method removeBinding
       @param conditionNumber
       @param boundVar
     */
    ShellPrototype.removeBinding = function(condId,boundVar,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("removing binding:",condId,boundVar);
        if(source.conditions[condId] === undefined || this.allNodes[condId] === undefined){
            throw new Error("can't delete from a non-existing condition");
        }
        var condition = this.allNodes[condId];
        if(condition.bindings[boundVar] !== undefined){
            delete condition.bindings[boundVar];
        }else{
            console.warn("Could not find binding:",boundVar,condition);
        }
    };


    return ShellPrototype;
});

/**
   @purpose Defines shell prototype methods for changing a node
 */


define('ShellModules/shell_node_mod',['underscore'],function(_){
    "use strict";
    var ShellPrototype = {};

    /**
       @class CompleteShell
       @method rename
       @purpose rename the current nodes name
       @param name The name to rename to
     */
    ShellPrototype.rename = function(name,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        source.name = name;
    };

    /**
       @class CompleteShell
       @method setParameter
       @purpose Set a key:value pair in the node[field] to value
       @param field
       @param parameter
       @param value
     */
    ShellPrototype.setParameter = function(field,parameter,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        //if(!source[field]) throw new Error("Unrecognised field");
        //if(field !== 'values' && field !== 'tags' && field !== 'annotations'){
        //    throw new Error("Bad field");
        //}
        if(source[field] === undefined && field !== undefined){
            source[field] = {};
        }
        if(parameter === undefined && field !== 'values' && field !== 'tags' && field !== 'children' && field !== 'parents' && field !== 'name' && field !== 'id'){
            delete source[field];
        }else if(value !== undefined){
            source[field][parameter] = value;
        }else{
            //if no value is specified, remove the entry
            delete source[field][parameter];
        }
        
    };


    /**
       @class CompleteShell
       @method link
       @purpose Interface method to add a link to the cwd. can be reciprocal
       @param target The field of the node to add the link to
       @param id The id of the node being linked towards
       @param reciprocal Whether the node of id will have a link back
     */
    ShellPrototype.link = function(target,id,reciprocal,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;

        //validate:
        if(isNaN(Number(id))) { throw new Error("id should be a global id number"); }
        if(this.allNodes[id] === undefined){
            throw new Error("Node for id " + id + " does not exist");
        }
        if(!source[target]) { throw new Error("Unrecognised target"); }

        //perform the link:
        var nodeToLink = this.getNode(id);
        this.addLink(source,target,nodeToLink.id,nodeToLink.name);
        //this.cwd[target][nodeToLink.id] = true; //this.allNodes[id];
        if(reciprocal){
            var rTarget = 'parents';
            if(target === 'parents') { rTarget = 'children'; }
            this.addLink(nodeToLink,rTarget,source.id,source.name);
            //nodeToLink[rtarget][this.cwd.id] = true; //this.cwd;
        }
    };


    /**
       @class CompleteShell
       @method setBinding
       @purpose Set/Add a binding pair to a condition in a rule
       @param conditionNum The condition to add the binding to
       @param toVar The variable name to use as the bound name
       @param fromVar the wme field to bind

       @ie: toVar = wme.fromVar
     */
    ShellPrototype.setBinding = function(conditionId,toVar,fromVar,testPairs,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Add binding to:",conditionId,toVar,fromVar);
        if(source.tags.type !== 'rule' && source.tags.type !== 'negConjCondition'){
            throw new Error("Trying to modify a rule when not located at a rule");
        }
        if(source.conditions[conditionId] === undefined){
            throw new Error("Can't add binding to non=existent condition");
        }
        var condition = this.getNode(conditionId);
        //condition.bindings.push([toVar,fromVar]);
        condition.setBinding(toVar,fromVar,testPairs);
        console.log(condition,condition.bindings);
    };

    /**
       @class CompleteShell
       @method setArithmetic
       @purpose set an arithmetic operation for an action
       @param actionNum The action to add the operation to
       @param varName the variable to change
       @param op the operator to use. ie: + - * / ....
       @param value The value to apply to the varName

       @TODO allow bindings in the rhs/value field
     */
    ShellPrototype.setArithmetic = function(actionId,varName,op,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Setting arithmetic of:",actionId,varName,op,value);
        console.log(_.keys(source.actions));
        if(source.tags.type !== 'rule'){
            throw new Error("Arithmetic can only be applied to actions of rules");
        }
        if(source.actions[actionId] === undefined){
            throw new Error("Cannot add arithmetic to non-existent action");
        }
        var action = this.getNode(actionId);

        if(action === undefined){
            throw new Error("Could not find action");
        }
        action.setArith(varName,op,value);

    };

    //Store a regex transform for an action, in a similar way to arithmetic actions
    ShellPrototype.setRegex = function(actionId,varName,regex,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Setting regex transform of:",actionId,varName,regex);
        //if it includes the opening and closing /'s, remove them?

        //get the action
        var action = this.getNode(actionId);
        action.setRegex(varName,regex);

    };

    /**
       Modify the timing of an action
    */
    ShellPrototype.setTiming = function(actionId,timeVar,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd,
            action = this.getNode(actionId);
        action.setTiming(timeVar,value);

    }
    
    /**
       @class CompleteShell
       @method setActionnValue
       @purpose Set an internal value of an action, without going into that node itself
       @param actionNum The action to target
       @param a The parameter name
       @param b The parameter value

       @note If only a is supplied, sets the action's actionType tag
     */
    ShellPrototype.setActionValue = function(actionId,a,b,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule'){
            throw new Error("Can't set action values on non-actions");
        }
        if(source.actions[actionId] !== undefined){
            var action = this.getNode(actionId);
            action.setValue(b,'values',a);
        }else{
            throw new Error("Unrecognised action");
        }
    };

    /**
       @class CompleteShell
       @method setActionType
       @param actionNum
       @param a the type
     */
    ShellPrototype.setActionType = function(actionId,a,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule'){
            throw new Error("Can't set action type for non-rules");
        }
        if(source.actions[actionId] !== undefined){
            var action = this.allNodes[actionId];
            action.setValue(a,'tags','actionType');
        }else{
            throw new Error("Unrecognised action");
        }
    };
    
    /**
       @class CompleteShell
       @method setTest
       @purpose add/modify a constant test of a condition
       @param conNum the condition to target
       @param testNum the test to target
       @param field the wme field to test
       @param op The operator to test using
       @param val the value to test against
     */
    ShellPrototype.setTest = function(conditionId,testId,field,op,value,sourceId){
        console.log(conditionId,testId,field,op,value,sourceId);
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule' && source.tags.type !== 'negConjCondition'){
            throw new Error("Trying to set test on a non-rule node");
        }
        if(source.conditions[conditionId] === undefined || this.getNode(conditionId).constantTests[testId] === undefined){
            throw new Error("trying to set non-existent test");
        }

        var condition = this.getNode(conditionId);
        condition.setTest(testId,field,op,value);
    };


    return ShellPrototype;
});

/**
   @purpose Define prototype methods relating to shell <-> rete interaction
 */


define('ShellModules/shell_rete',['underscore','Rete'],function(_,Rete){
    "use strict";
    var ShellPrototype = {};
    
    /**
       @class CompleteShell
       @method clearRete
       @purpose Completely reset the retenet, by building a new one
     */
    ShellPrototype.clearRete = function(){
        this.reteNet = new Rete();
    };

    /**
       @class CompleteShell
       @method clearActivatedRules
       @purpose Clear the record of recently activated rules
     */
    ShellPrototype.clearPotentialActions = function(){
        //Rete.clearPotentialActions(this.reteNet);
        this.reteNet.clearProposedActions();
    };
    
    ShellPrototype.clearHistory = function(){
        //Rete.clearHistory(this.reteNet);
        this.reteNet.clearHistory();
    };
    
    /**
       @class CompleteShell
       @method compileRete
       @purpose Retrieve all defined rules, add them to the rete net
     */    
    ShellPrototype.compileRete = function(nodeIds){
        //take all defined rules from the provided list, or find all in the graph
        if(nodeIds === undefined) { nodeIds = _.keys(this.allNodes); }
        var shellRef = this,
            nodes  = nodeIds.map(function(d){
                return shellRef.getNode(d);
            }),
            rules = nodes.filter(function(d){
                return d.tags.type === 'rule';
            });
        
        console.log("Compiling rules:",rules);
        //and add them to the rete net
        //returning the action nodes of the net
        this.allActionNodes = rules.map(function(d){
            console.log("Adding rule:",d);
            //var actionNode = Rete.addRule(d.id,this.reteNet,this.allNodes);
            var actionNode = this.reteNet.addRule(d.id,this.allNodes);
            //TODO: store the returned node inside the shell's nodes?
            d.actionNodeId = actionNode.id;
            return {"rule": d, "actions" :actionNode};
        },this);

        console.log("All action nodes:",this.allActionNodes);
    };

    /**
       @class CompleteShell
       @method assertChildren
       @purpose Assert all child nodes of the current node as facts
       using each nodes' values field
       @TODO: be able to detect bindings and resolve them prior to assertion?
     */
    ShellPrototype.assertWMEs = function(nodeIds){
        //get all the wmes
        if(nodeIds === undefined || nodeIds.length === 0) { nodeIds = _.keys(this.allNodes); }
        var shellRef = this,
            nodes = nodeIds.map(function(d){
                return shellRef.getNode(d);
            }),
            wmes = nodes.filter(function(node){
                return node.tags.fact !== undefined;
            }).filter(function(node){
                return node.wmeId === undefined;
            });

        //assert them
        this.assertWMEList(wmes);
    };

    ShellPrototype.retractWMEs = function(nodeIds){
        if(nodeIds === undefined || nodeIds.length === 0) { nodeIds = _.keys(this.allNodes); }
        var shellRef = this,
            nodes = nodeIds.map(function(d){
                return shellRef.getNode(d);
            }),
            wmes = nodes.filter(function(node){
                return node.tags.fact !== undefined;
            }).filter(function(node){
                return node.wmeId !== undefined;
            });

        this.retractWMEList(wmes);
    };
    
    /**
       @class CompleteShell
       @method assertWMEList
       @purpose Taking a list of objects, add each as a wme to the retenet of the shell
       @param array An Array of objects
     */
    ShellPrototype.assertWMEList = function(nodes){
        if(!(nodes instanceof Array)){
            throw new Error("Asserting should be in the form of an array");
        }
        //create wme objects out of them
        var newWMEs = nodes.map(function(data){
            //var wmeId = Rete.assertWME_Immediately(data,this.reteNet);
            var wmeId = this.reteNet.assertWME(data);
            data.wmeId = wmeId;
            return wmeId;
        },this);
        console.log("New WMES:",newWMEs);
        return newWMEs;
    };

    ShellPrototype.retractWMEList = function(nodes){
        if(!(nodes instanceof Array)){
            throw new Error("Retractions should be in an array");
        }
        nodes.forEach(function(node){
            //Rete.retractWME_Immediately(node,this.reteNet);
            //TODO: should this be node.wmeID?
            this.reteNet.retractWME(node);
        },this);
    };
    
    ShellPrototype.stepTime = function(){
        //Rete.incrementTime(this.reteNet);
        this.reteNet.stepTime();
        console.log("Potential Actions:",this.reteNet.proposedActions);
        return this.reteNet.proposedActions;
    };
    
    /**
       @class CompleteShell
       @method getNode
       @purpose get a node by its id, utility method
     */
    ShellPrototype.getNode = function(nodeId){
        nodeId = Number(nodeId);
        
        if(this.allNodes[nodeId]){
            return this.allNodes[nodeId];
        }else{
            throw new Error("Unknown node specified: " + nodeId);
        }        
    };


    return ShellPrototype;
});

//------------------------------
// SEARCH method prototype
//------------------------------
//eg: search name root
//    search tags type
//    search tags type GraphNode
//    search children 0
//    search children blah



define('ShellModules/shell_search',['underscore'],function(_){
    "use strict";
    var ShellPrototype = {};
    
    ShellPrototype.searchForFieldTagValue = function(values,nodeSelection){
        var field = values.shift(),
            tag = values.shift(),
            tagValue = values.shift(),
            pattern = new RegExp(tag,"i");
        
        if(nodeSelection === undefined){
            nodeSelection = _.values(this.allNodes);
        }
        
        if(field === undefined || tag === undefined){
            this.lastSearchResults = [];
        }
        
        var nodes = nodeSelection.filter(function(node){
            if(node[field] === undefined) { return false; }
            //if field is a string
            if(typeof node[field] === "string"){
                //using default pattern of tag
                if(pattern.test(node[field])){
                    return true;
                }else{
                    return false;
                }
            }

            if(node[field] instanceof Array && node[field].length === 1){
                if(pattern.test(node[field][0])){
                    return true;
                }else{
                    return false;
                }
            }
            
            //if field is an object
            if(node[field][tag] !== undefined){
                if(tagValue === undefined){
                    return true;
                }else{
                    pattern = new RegExp(tagValue);
                    if(pattern.test(node[field][tag])){
                        return true;
                    }else{
                        return false;
                    }
                }
            }
            return false;
        });
        this.lastSearchResults = nodes;
        return this.lastSearchResults;
    };

    ShellPrototype.searchComparatively = function(values,nodeSelection){
        //TODO
    };

    return ShellPrototype;
});

/**
   tracery style parsing/text generation
   Assumes objects using $ to denote rules
   ie: { start: "$greeting", greeting: "hello" };
*/
define('Parse',['underscore'],function(_){
    "use strict";
    
    var ParseObject = function(grammarObj,start,depth=1){
        if(depth > 50){
            console.warn("Parse depth > 50");
            return `[${start}]`;
        }
        if(grammarObj[start] === undefined){
            //throw new Error("Unrecognised rule: " + start);
            console.warn(`Unrecognised rule: ${start}`);
            return `[${start}]`;
        }
        //Get the rule's string
        var currentString = grammarObj[start];
        //get one of the options
        if(currentString instanceof Array){
            currentString = _.sample(currentString);
        }

        //get the variables that need expansion
        var variables = currentString.match(/\$\w+/g);
        if(variables === null) { return currentString; }

        //For each variable, expand it
        var returnedStrings = variables.map(function(d){
            return ParseObject(grammarObj,d.slice(1),depth+1);
        }),
            zippedExpansions = _.zip(variables,returnedStrings);

        var finalString = zippedExpansions.reduce(function(m,v){
            return m.replace(v[0],v[1]);
        },currentString);

        return finalString;
    };



    

    return ParseObject;
});

/**
   @purpose Defines Shell prototype methods relating to string modification. mainly utilities
 */



define('ShellModules/shell_string',['underscore','Parse'],function(_,Parse){
    "use strict";
    var ShellPrototype = {};


    /**
       @class CompleteShell
       @method getNodeListByIds
       @utility
       @purpose To retrieve the actual node objects indicated by an array of ids
       @param idList
       @return array of node objects
     */
    ShellPrototype.getNodeListByIds = function(idList){
        var retList = idList.map(function(d){
                return this.getNode(d);
        },this).filter(function(d){ return d;});
        return retList;
    };
    
    //Utility functions for display Output:
    /**
       @class CompleteShell
       @method nodeToShortString
       @utility
       @purpose To convert a node to a text representation for display on screen
       @param node
       @param i
     */
    ShellPrototype.nodeToShortString = function(node){
        console.log("NTSS:",node);
        if(node.tags.type === "action"){
            return "(" + node.id + "): " + node.name;
        }else if(node.tags.type === "aggregate"){
            return "Group of: " + node.noOfValues;            
        }else if(node.name){
            return "(" + node.id + "): " + node.name + " (" + node.tags.type + ")";
        }else{
            return "(" + node.id + "): (" + node.tags.type + ")";
        }
    };

    /**
       @class CompleteShell
       @method nodeToStringList
       @utility
       @stub
       @purpose To convert a node to a list of strings
       @param node
     */
    ShellPrototype.nodeToStringList = function(node){
        return [];
    };

    /**
       @class CompleteShell
       @method ruleToStringList
       @utility
       @purpose Convert a rule to a string representation
       @param node
     */
    ShellPrototype.ruleToStringList = function(node){
        var retList = [];
        retList.push("(" + node.id +"): " + node.name);
        return retList;
    };
    

    /**
       @method traceNode
       @purpose convert node and subnodes to a tracery style string
     */
    ShellPrototype.traceNode = function(node){
        //console.log("Tracing node:",node);
        //no message: node is an array of children
        //message: node is a rule

        //message exists:
        //create the grammar object:
        var descendents = this.dfs(node.id).map(function(d){
            return this.getNode(d);
        },this),
            //link node name to expansion string -> grammar
            grammar = descendents.reduce(function(m,v){
                if(m[v.name] === undefined){
                    m[v.name] = [];
                }
                if(v.values.message !== undefined){
                    m[v.name].push(v.values.message);
                }else{
                    //turn each child into a rule, or use the name of the node
                    m[v.name] = _.values(v.children).length > 0 ? m[v.name].concat(_.values(v.children).map(function(d){
                        return "$"+d;
                    })) : m[v.name].concat([v.name]);
                }                
                return m;
            },{});

        var retString;
        try{
            retString = Parse(grammar,node.name);
        }catch(e){
            console.log("Trace error:",e);
        }finally{
            return retString || node.name;
        }
    };
    
    

    return ShellPrototype;
});



define('ShellModules/shell_graph_search',['underscore'],function(_){
    "use strict";
    var ShellPrototype = {};
    //--------------------
    //DFS and BFS searches:
    //--------------------

    /**
       @class CompleteShell
       @method dfs
       @purpose Depth First Search from a source nodeId,
       using children in the specified fields, filtered afterwards by a criteria function
       @return ids of nodes found
     */
    ShellPrototype.dfs = function(nodeId,focusFields,criteriaFunction){
        if(focusFields === undefined) { focusFields = ['children']; }
        var shellRef = this,
            currentStack = [this.getNode(nodeId)],
            visitedListOfIds = [];
        
        //discover all applicable nodes
        while(currentStack.length > 0){
            var curr = currentStack.pop();
            //avoid duplicates and loops
            if(visitedListOfIds.indexOf(curr.id) !== -1) { continue; }
            //store
            visitedListOfIds.push(curr.id);
            //add children to search
            focusFields.forEach(function(focusField){
                currentStack = currentStack.concat(_.keys(curr[focusField]).map(function(d){
                    return shellRef.getNode(d);
                }).reverse());
            });
        }

        //apply the criteria function to the discovered nodes
        if(criteriaFunction !== undefined && typeof criteriaFunction === 'function'){
            return visitedListOfIds.filter(function(d){
                return criteriaFunction(this.getNode(d));
            },shellRef);
        }else{
            return visitedListOfIds;
        }        
    };

    /**
       @class TotalShell
       @method bfs
       @purpose Breadth First Search on a source nodeId, for the specified fields
       filtering by the criteria, and to a specified depth
     */
    ShellPrototype.bfs = function(nodeId,focusFields,criteriaFunction,depth){
        if(focusFields === undefined) { focusFields = ['children']; }
        if(depth === undefined) { depth = 2; }
        var shellRef = this,
            currentQueue = [this.getNode(nodeId)],
            visitedListOfIds = [];

        while(currentQueue.length > 0){
            var curr = currentQueue.shift();
            //skip duplicates
            if(visitedListOfIds.indexOf(curr.id) !== -1) { continue; }
            visitedListOfIds.push(curr.id);
            
            focusFields.forEach(function(focusField){
                _.keys(curr[focusField]).forEach(function(d){
                    currentQueue.push(shellRef.getNode(d));
                });
            });
        }
        
        if(criteriaFunction !== undefined && typeof criteriaFunction === 'function'){
            return visitedListOfIds.filter(function(d){
                return criteriaFunction(this.getNode(d));
            },shellRef);
        }else{
            return visitedListOfIds;
        }
    };
    
    return ShellPrototype;
});



define('ShellModules/shell_state_change',['underscore','../utils'],function(_,util){
    "use strict";
    var ShellPrototype = {};

        /**
       @class CompleteShell
       @method cd
       @purpose to move the cwd of the shell to a new location
       @params target The id (global) or name (local) to move to
    */
    ShellPrototype.cd = function(target){
            this.cdNode(target);
    };

    /**
       @class CompleteShell
       @method cdNode
       @utility
       @purpose to move about normally, dealing with nodes
       @param target
     */
    ShellPrototype.cdNode = function(target){
        //update where you were previously
        this.previousLocation = this.cwd.id;
        //go up to parent
        if(target === ".."){
            //console.log("cd : ..");
            if(this.cwd._originalParent){
                this.cdNode(this.cwd._originalParent);
            }else{
                //if no original parent defined
                var randomParentKey = util.randomChoice(_.keys(this.cwd.parents));
                if(randomParentKey !== undefined){
                    this.cdNode(randomParentKey);
                }
            }
            return;
        }
        
        //id specified
        if(!isNaN(Number(target)) && this.allNodes[Number(target)]){
            //console.log("cd : ", Number(target));
            this.cwd = this.allNodes[Number(target)];
            return;
        }
        
        //passed a name. convert it to an id
        //console.log("Cd-ing: ",target);
        var nameIdPairs = {};
        var children = this.cwd.children;

        _.keys(children).map(function(d){
            return this.allNodes[d];
        },this).forEach(function(d){
            this[d.name] = d.id;
        },nameIdPairs);//pay attention to the state arg
        
        var parents = this.cwd.parents;
        _.keys(parents).map(function(d){
            return this.allNodes[d];
        },this).forEach(function(d){
            this[d.name] = d.id;
        },nameIdPairs);//state arg

        //console.log("Available keys:",_.keys(nameIdPairs));
        //if you can find the target to move to:
        if(nameIdPairs[target]){
            this.cd(nameIdPairs[target]);
        }else{
            //cant find the target, complain
            throw new Error("Unrecognised cd form");
        }
    };

    /**
       @class CompleteShell
       @method stash
       @purpose add the cwd to the temporary stash for reference
     */
    ShellPrototype.stash = function(){
        this._nodeStash.push(this.cwd);
    };

    /**
       @class CompleteShell
       @method unstash
       @purpose move to, and remove, the top element from the stash stack
    */
    ShellPrototype.unstash = function(){
        if(this._nodeStash.length > 0){
            this.cd(this._nodeStash.pop().id);
        }
    };

    /**
       @class CompleteShell
       @method top
       @purpose To move to the top element of the stash stack, without removing it
     */
    ShellPrototype.top = function(){
        if(this._nodeStash.length > 0){
            this.cd(this._nodeStash[this._nodeStash.length - 1].id);
        }
    };
    

    return ShellPrototype;
});

/**
   @file shell_prototype_main
   @object shellPrototype
   @purpose Aggregates different components of the shell into one prototype
*/


define('ShellModules/shell_prototype_main',['underscore','./shell_json','./shell_node_addition','./shell_node_deletion','./shell_node_mod','./shell_rete','./shell_search','./shell_string','./shell_graph_search','./shell_state_change'],function(_,shellJson,shellAddition,shellDeletion,shellMod,shellRete,shellSearch,shellString,shellGraphSearch,shellStateChange){
    "use strict";
    var shellPrototype = _.extend({},
                                  shellJson, shellAddition, shellDeletion,
                                  shellMod, shellRete, shellSearch, shellString,
                                  shellGraphSearch, shellStateChange);
    //console.log("Shell Prototype:",shellPrototype);

    return shellPrototype;
});

/**
   @file TotalShell
   @purpose Describes the top level Shell class, allowing authoring of a graph structure
   and integration with Rete based rule engine
 */


define('TotalShell',['../libs/Rete.min','underscore','./Node/GraphNode','./Node/Constructors','./utils','./ShellModules/shell_prototype_main'],function(Rete,_,GraphNode,getCtor,util,shell_prototype){
    "use strict";

    /**
       @class CompleteShell
       @constructor
       @purpose The Main Shell class, provides interfaces for interacting with nodes, rules, and rete
    */
    var CompleteShell = function(){
        this.nextId = 0;
        this.tags = {};
        this.tags.type = 'Shell';
        //the root node
        this.root = new GraphNode('__root');
        
        //disconnected nodes:
        this.disconnected = {
            noParents : new GraphNode('disconnectedFromParents'),
            noChildren : new GraphNode('disconnectedFromChildren'),
        };
        //All Nodes:
        this.allNodes = {};
        this.allNodes[this.root.id] = this.root;
        //AllRules:
        this.allRules = [];
        this.allRulesByName = {};

        //current node/rule, as an ACTUAL OBJECT, NOT AN ID
        this.cwd = this.root;

        //stashed locations:
        this._nodeStash = [];
        this.previousLocation = 0;

        //last search results:
        this.lastSearchResults = [];

        //Integrated Rete Net:
        this.reteNet = new Rete();
    };
    
    //Use the aggrgated shell prototype:
    CompleteShell.prototype = Object.create(shell_prototype);
    CompleteShell.prototype.constructor = CompleteShell;

    CompleteShell.prototype.getCtor = getCtor;
    
    /**
       @interface The interface of the TotalShell file
       @exports CompleteShell 
       @alias Shell for CompleteShell
     */
    var moduleInterface = {
        "CompleteShell": CompleteShell,
        "shell"        : CompleteShell,
    };
    return moduleInterface;
});


require(["TotalShell"]);
define('underscore',function() { return _; }); return require('TotalShell'); }));