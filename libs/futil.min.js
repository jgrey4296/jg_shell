// wrap-start.frag.js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        // change "myLib" to whatever your library is called
        root.futil = factory();
    }
}(this, function () {

    
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                //Lop off the last part of baseParts, so that . matches the
                //"directory" and not name of the baseName's module. For instance,
                //baseName of "one/two/three", maps to "one/two/three.js", but we
                //want the directory, "one/two" for this normalization.
                name = baseParts.slice(0, baseParts.length - 1).concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../node_modules/almond/almond", function(){});

define('core',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){

	ƒ.uniqId = function () {
		return Math.floor( Math.random() * 11 ) +''+ Math.floor( Math.random() * 1000000 );
	};

	ƒ.uuid = (function() {
		var s4 = function () {
			return Math.floor((1 + Math.random()) * 0x10000)
				.toString(16)
				.substring(1);
		}

		return function() {
			return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
			s4() + '-' + s4() + s4() + s4();
		};
	})();

	ƒ.forEach = ƒ.each = function ( o, fn, context ) {

		if( ƒ.is.Array( o ) ) {
			return ƒ.Array.each.apply( null, arguments );
		}

		if( ƒ.is.Object( o ) ) {
			return ƒ.Object.each.apply( null, arguments );
		}

		return false;
	};

	ƒ.map = function ( o, fn, context ) {

		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		if( ƒ.is.Array( o ) ) {
			return ƒ.Array.map.apply( null, arguments );
		}

		if( ƒ.is.Object( o ) ) {
			return ƒ.Object.map.apply( null, arguments );
		}

		return false;
	};

	ƒ.filter = function ( o, fn, context ) {

		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		if( ƒ.is.Array( o ) ) {
			return ƒ.Array.filter.apply( null, arguments );
		}

		if( ƒ.is.Object( o ) ) {
			return ƒ.Object.filter.apply( null, arguments );
		}

		return false;
	};

	ƒ.clone = function ( obj ) {
		var clone = {};
		clone.constructor = obj.constructor;
		clone.prototype = obj.prototype;
		return ƒ.extend( clone, obj );
	};

	ƒ.extend = function ( target ) {
		var srcs,
			r = false,
			i, j, len, src;

		if ( target === true){
			target = arguments[1];
			r = true;
			srcs = Array.prototype.slice.call(arguments, 2);
		} else {
			srcs = Array.prototype.slice.call(arguments, 1);
		}

		for ( j = 0, len = srcs.length; j < len; j++ ) {
			src = srcs[j];
			for ( i in src ) {
				if ( r && typeof target[i] == 'object' )
					this.extend( target[i], src[i] );
				else
					target[i] = src[i];
			}
		}
		return target;
	};

	ƒ.slice = function ( target, start, end ) {

		if ( ƒ.is.Function( target.slice ) ) {
			return target.slice( start, end );
		}

		if ( ƒ.is.Object( target ) ) {
			var keys = Object.keys( target ).slice( start, end );

			return ƒ.filter( target, function ( value, key ) {
				return keys.indexOf( key ) !== -1;
			});
		}

		return [];
	};

	ƒ.stamp = (function () {
		var last_id = 0;

		return function ( obj ) {
			obj._id = obj._id || ++last_id;
			return obj._id;
		};
	})();

	ƒ.log = console.log;

});

});

define('isisnt',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){

	// For internal API
	ƒ.isisnt = ƒ.IsIsnt = {};

	ƒ.is = ƒ.Is = {};
	ƒ.isnt = ƒ.Isnt = {};

	ƒ.is.instanceof = function ( ClassToEval, instance ) {
		return instance && instance.constructor ? instance.constructor === ClassToEval : instance instanceof ClassToEval;
	};
	ƒ.isnt.instanceof = function ( ClassToEval, instance ) {
		return instance && instance.constructor ? instance.constructor !== ClassToEval : ! ( instance instanceof ClassToEval );
	};

	var register = ƒ.IsIsnt.register = function ( ClassToEval, keys ) {
			if( ! ClassToEval ) return;

			var isFn = function ( instance ) {
					return ƒ.is.instanceof( ClassToEval, instance );
				},
				isntFn = function ( instance ) {
					return ƒ.isnt.instanceof( ClassToEval, instance );
				};

			if( typeof keys !== 'object' ) {
				keys = [ keys ];
			}

			keys.forEach(function ( key ) {
				ƒ.is[ key ] = isFn;
				ƒ.isnt[ key ] = isntFn;
			});
		},
		registerCustom = ƒ.IsIsnt.registerCustom = function ( keys, isFn, isntFn ) {

			if( ƒ.isnt.function( isFn ) ) {
				throw new TypeError("isFn must be a function");
			}

			if( ƒ.isnt.function( isntFn ) ) {
				isntFn = function ( instance ) {
					return ! isFn( instance );
				};
			}

			if( typeof keys !== 'object' ) {
				keys = [ keys ];
			}

			keys.forEach(function ( key ) {
				ƒ.is[ key ] = isFn;
				ƒ.isnt[ key ] = isntFn;
			});

		};

	// Default Javascript Classes
	register( Function, [ 'Function', 'function' ] );
	register( Array, [ 'Array', 'array' ] );
	register( Object, [ 'Object', 'object' ] );
	register( String, [ 'String', 'string' ] );
	register( Error, [ 'Error', 'error' ] );
	register( RegExp, [ 'RegExp', 'Regexp', 'regExp', 'regexp' ] );

	// Default Browser Classes
	if( typeof HTMLElement !== 'undefined' ) {
		register( HTMLElement, [ 'HTMLElement', 'HTMLelement' ] );
	}

	// Custom evaluators
	registerCustom( [ 'numeric', 'number', 'Number' ], function ( variable ) {

		// Parse it to a number if it isn't
		variable = typeof variable === 'number' ? variable : parseInt( variable );

		// We don't want to tell that "Not a Number" is a Number...
		return ! isNaN( variable );
	});
	registerCustom( [ 'undefined', 'Undefined', 'notDefined', 'notdefined' ], function ( variable ) {
		return typeof variable === 'undefined';
	});
	registerCustom( [ 'ok', 'true' ], function ( variable ) {
		return variable === true;
	});
	registerCustom( [ 'bad', 'false' ], function ( variable ) {
		return variable === false;
	});
	registerCustom( [ 'Null', 'null', 'NULL' ], function ( variable ) {
		return variable === null;
	});
	registerCustom( [ 'json', 'JSON', 'Json' ], function ( variable ) {
		if (/^[\],:{}\s]*$/
				.test( variable
					.replace( /\\["\\\/bfnrtu]/g, '@')
					.replace( /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']' )
					.replace( /(?:^|:|,)(?:\s*\[)+/g, '' )
				)
			) return true;

		return false;
	});

});

});

define('from',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var from = ƒ.from = {};

	from.string = from.String = function ( string ) {
		if( ƒ.isnt.string( string ) ) {
			throw new TypeError("string should be string");
		}

		if( string == 'undefined' ) return undefined;
		if( string == 'null' ) return null;
		if( string == 'true' ) return true;
		if( string == 'false' ) return false;
		if( ƒ.is.number( string ) ) return parseInt( string );
		if( ƒ.is.json( string ) ) return JSON.parse( string );

		return string;
	};

});

});

define('to',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var to = ƒ.to = {};

	to.String = function ( variable ) {
		return ( ƒ.is.string( variable ) ) ? variable : JSON.stringify( variable );
	};

});

});

define('type/array',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var $ = ƒ.Array = ƒ.array = {};

	// is and isnt
	$.is = ƒ.is.Array;
	$.isnt = ƒ.isnt.Array;

	$.forEach = $.each = function ( array, fn, context ) {

		if ( ƒ.isnt.Array( array ) ) {
			throw new TypeError("array must be an array");
		}
		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var i;

		for( i=0; i < array.length; i++ ) {
			fn.call( context || array, array[ i ], i, array );
		}

		return array;
	};

	$.map = function ( array, fn, context ) {

		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var res = [], i;

		ƒ.each( array, function ( v, k ) {
			res.push(
				fn.call( context || array, v, k, array ) || undefined
			);
		});

		return res;
	};

	$.filter = function ( array, fn, context ) {

		if ( ƒ.isnt.Array( array ) ) {
			throw new TypeError("array must be an array");
		}
		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var res = [];

		ƒ.each( array, function ( v, k ) {
			if( fn.call( context || array, v, k, array ) ) {
				res.push( array[ k ] );
			}
		});

		return res;
	};

	$.randomFilter = function ( array, limit ) {

		if ( ƒ.isnt.Array( array ) ) {
			throw new TypeError("array must be an array");
		}

		if( ! parseInt( limit ) > 0 || array.length <= limit ) {
			return array || false;
		}

		var newArray = [], i;

		// Copy all the options to target
		for( i in array ) {
			newArray[ i ] = array[ i ];
		}

		while ( newArray.length > limit ) {

			// Itenerator to decrement
			i = Math.floor( Math.random() * newArray.length );

			newArray.splice( i, 1 );

		}

		return newArray;
	};

	$.empty = function ( array ) {

		if ( ƒ.isnt.Array( array ) ) {
			throw new TypeError("array must be an array");
		}

		array.splice( 0, array.length );

		return array;
	};

});

});

define('type/function',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var fn = ƒ.Function = ƒ.function = {};

	// is and isnt
	fn.is = ƒ.is.Function;
	fn.isnt = ƒ.isnt.Function;

	// Function to be called with a fiven context
	fn.bind = function ( fn, context ) {
		var slice = Array.prototype.slice;

		if ( fn.bind ) {
			return fn.bind.apply( fn, slice.call( arguments, 1 ) );
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply( context, args.length ? args.concat(slice.call(arguments)) : arguments );
		};
	};

	// fn that logs all arguments passed to it
	fn.debug = function () { console.log( arguments ); };

	// fn that returns a value
	fn.return = function ( value ) { return function () { return value; }; };
	fn.falsify = fn.return( false );
	fn.truthify = fn.return( true );
	fn.nullify = fn.return( null );
	fn.undefinify = fn.return( undefined );

	// fn that returns parameters names
	// Based on @Jack Allan's response at stackoverflow.com
	// http://stackoverflow.com/questions/1007981/how-to-get-function-parameter-names-values-dynamically-from-javascript
	fn.getParamNames = (function () {

		// REGEX
		var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,
			ARGUMENT_NAMES = /([^\s,]+)/g;

		return function ( func ) {

			var fnStr = func.toString().replace(STRIP_COMMENTS, '');
			var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);

			if(result === null) {
				result = [];
			}

			return result;
		};

	})();

});

});

define('type/object',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var $ = ƒ.Object = ƒ.Object = {};

	// is and isnt
	$.is = ƒ.is.Object;
	$.isnt = ƒ.isnt.Object;

	$.forEach = $.each = function ( object, fn, context ) {

		if ( ƒ.isnt.Object( object ) ) {
			throw new TypeError("object must be an object");
		}
		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var i;

		for( i in object ) {
			if ( object.hasOwnProperty( i ) ) {
				fn.call( context || object, object[ i ], i, object );
			}
		}

		return object;
	};

	$.map = function ( object, fn, context ) {

		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var res = {}, i;

		ƒ.each( object, function ( v, k ) {
			res[ k ] = fn.call( context || object, v, k, object );
		});

		return res;
	};

	$.filter = function ( object, fn, context ) {

		if ( ƒ.isnt.Object( object ) ) {
			throw new TypeError("object must be an object");
		}
		if ( ƒ.isnt.Function( fn ) ) {
			throw new TypeError("fn must be a function");
		}

		var res = {}, i;

		ƒ.each( object, function ( v, k ) {
			if( fn.call( context || object, v, k, object ) ) {
				res[ k ] = object[ k ];
			}
		});

		return res;
	};

});

});

define('type/string',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){
	var st = ƒ.String = ƒ.string = {};

	// is and isnt
	st.is = ƒ.is.String;
	st.isnt = ƒ.isnt.String;

	st.trim = function ( str ) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	};

	st.splitWords = function ( str ) {
		return st.trim(str).replace(/,/g, ' ').split(/\s+/);
	};

	st.capitalize = function ( str ) {
		return str.slice(0,1).toUpperCase() + str.slice(1);
	};

	st.decapitalize = function ( str ) {
		return str.slice(0,1).toLowerCase() + str.slice(1);
	};

	st.smartTrim = function ( str ) {
		var CODEs = [];

		return str
			.replace( /(?:<pre[\s\S]*?<\/pre>|<code[\s\S]*?<\/code>)/gi, function ( code ) { CODEs.push( code ); return '__CODE_BLOCK__'; })
			.replace( /\>[\t\n]+/ig, '>' ).replace( /[\t\n]+\</ig, '<' )
			.replace( /\>\s+/ig, '> ' ).replace( /\s+\</ig, ' <' )
			.replace( /\s+/ig, ' ' ).replace( /\>\s+\</ig, '> <' )
			.trim()
			.replace( /__CODE_BLOCK__/g, function () { return CODEs.shift(); });
	};

	// Case conversions

		// from CamelCase to ...

		st.fromCamelToDash = function ( str ){
			return str
				.replace(/([A-Z])/g, function ( l ){return "-"+l.toLowerCase();})
				.replace(/^\-/g,'');
		};
		st.fromCamelToUnderscore = function ( str ){
			return str
				.replace(/([A-Z])/g, function ( l ){return "_"+l.toLowerCase();})
				.replace(/^\_/g,'');
		};
		st.fromCamelToSpaced = function ( str ){
			return str
				.replace(/([A-Z])/g, function ( l ){return " "+l;})
				.replace(/^ /g,'');
		};


		// from dash-case to ...

		st.fromDashToCamel = function ( str ){
			return str
				.replace(/(\-[a-z])/g, function ( l ){return l.toUpperCase().replace('-','');})
				.replace(/^[a-z]{1}/g,function ( l ){return l.toUpperCase();});
		};
		st.fromDashToUnderscore = function ( str ){
			return str
				.replace(/(\-[a-z])/g, function ( l ){return l.replace('-','_');})
				.replace(/^\_/g,'');
		};
		st.fromDashToSpaced = function ( str ){
			return str
				.replace(/(\-[a-z])/g, function ( l ){return l.toUpperCase().replace('-',' ');})
				.replace(/^\ /g,'')
				.replace(/^[a-z]{1}/g,function ( l ){return l.toUpperCase();});
		};


		// from underscore_case to ...

		st.fromUnderscoreToCamel = function ( str ){
			return str
				.replace(/(\_[a-z])/g, function ( l ){return l.toUpperCase().replace('_','');})
				.replace(/^[a-z]{1}/g,function ( l ){return l.toUpperCase();});
		};
		st.fromUnderscoreToDash = function ( str ){
			return str
				.replace(/(\_[a-z])/g, function ( l ){return l.replace('_','-');})
				.replace(/^\-/g,'');
		};
		st.fromUnderscoreToSpaced = function ( str ){
			return str
				.replace(/(\_[a-z])/g, function ( l ){return l.toUpperCase().replace('_',' ');})
				.replace(/^[a-z]{1}/g,function ( l ){return l.toUpperCase();});
		};
		st.toHtml = function( str ){
			return str
				.replace( new RegExp( '\n',  'g' ), '<br />' )
				.replace( new RegExp( '&quot;', 'g' ), '"' )
				.replace( new RegExp( '&lt;', 'g' ), '<' )
				.replace( new RegExp( '&gt;', 'g' ), '>' );
		};
		st.toText = function( str ){
			return str
				.replace( new RegExp( '<br />', 'g'), '\n' )
				.replace( new RegExp( '"', 'g'), '&quot;' )
				.replace( new RegExp( '<', 'g' ), '&lt;' )
				.replace( new RegExp( '>', 'g' ), '&gt;' );
		};
});
});

define('type/regexp/accents',['require','exports','module'],function (require, exports, module) {var _ = module.exports = {};

_.A = '[Aa\xaa\xc0-\xc5\xe0-\xe5\u0100-\u0105\u01cd\u01ce\u0200-\u0203\u0226\u0227\u1d2c\u1d43\u1e00\u1e01\u1e9a\u1ea0-\u1ea3\u2090\u2100\u2101\u213b\u249c\u24b6\u24d0\u3371-\u3374\u3380-\u3384\u3388\u3389\u33a9-\u33af\u33c2\u33ca\u33df\u33ff\uff21\uff41]';
_.B = '[Bb\u1d2e\u1d47\u1e02-\u1e07\u212c\u249d\u24b7\u24d1\u3374\u3385-\u3387\u33c3\u33c8\u33d4\u33dd\uff22\uff42]';
_.C = '[Cc\xc7\xe7\u0106-\u010d\u1d9c\u2100\u2102\u2103\u2105\u2106\u212d\u216d\u217d\u249e\u24b8\u24d2\u3376\u3388\u3389\u339d\u33a0\u33a4\u33c4-\u33c7\uff23\uff43]';
_.D = '[Dd\u010e\u010f\u01c4-\u01c6\u01f1-\u01f3\u1d30\u1d48\u1e0a-\u1e13\u2145\u2146\u216e\u217e\u249f\u24b9\u24d3\u32cf\u3372\u3377-\u3379\u3397\u33ad-\u33af\u33c5\u33c8\uff24\uff44]';
_.E = '[Ee\xc8-\xcb\xe8-\xeb\u0112-\u011b\u0204-\u0207\u0228\u0229\u1d31\u1d49\u1e18-\u1e1b\u1eb8-\u1ebd\u2091\u2121\u212f\u2130\u2147\u24a0\u24ba\u24d4\u3250\u32cd\u32ce\uff25\uff45]';
_.F = '[Ff\u1da0\u1e1e\u1e1f\u2109\u2131\u213b\u24a1\u24bb\u24d5\u338a-\u338c\u3399\ufb00-\ufb04\uff26\uff46]';
_.G = '[Gg\u011c-\u0123\u01e6\u01e7\u01f4\u01f5\u1d33\u1d4d\u1e20\u1e21\u210a\u24a2\u24bc\u24d6\u32cc\u32cd\u3387\u338d-\u338f\u3393\u33ac\u33c6\u33c9\u33d2\u33ff\uff27\uff47]';
_.H = '[Hh\u0124\u0125\u021e\u021f\u02b0\u1d34\u1e22-\u1e2b\u1e96\u210b-\u210e\u24a3\u24bd\u24d7\u32cc\u3371\u3390-\u3394\u33ca\u33cb\u33d7\uff28\uff48]';
_.I = '[Ii\xcc-\xcf\xec-\xef\u0128-\u0130\u0132\u0133\u01cf\u01d0\u0208-\u020b\u1d35\u1d62\u1e2c\u1e2d\u1ec8-\u1ecb\u2071\u2110\u2111\u2139\u2148\u2160-\u2163\u2165-\u2168\u216a\u216b\u2170-\u2173\u2175-\u2178\u217a\u217b\u24a4\u24be\u24d8\u337a\u33cc\u33d5\ufb01\ufb03\uff29\uff49]';
_.J = '[Jj\u0132-\u0135\u01c7-\u01cc\u01f0\u02b2\u1d36\u2149\u24a5\u24bf\u24d9\u2c7c\uff2a\uff4a]';
_.K = '[Kk\u0136\u0137\u01e8\u01e9\u1d37\u1d4f\u1e30-\u1e35\u212a\u24a6\u24c0\u24da\u3384\u3385\u3389\u338f\u3391\u3398\u339e\u33a2\u33a6\u33aa\u33b8\u33be\u33c0\u33c6\u33cd-\u33cf\uff2b\uff4b]';
_.L = '[Ll\u0139-\u0140\u01c7-\u01c9\u02e1\u1d38\u1e36\u1e37\u1e3a-\u1e3d\u2112\u2113\u2121\u216c\u217c\u24a7\u24c1\u24db\u32cf\u3388\u3389\u33d0-\u33d3\u33d5\u33d6\u33ff\ufb02\ufb04\uff2c\uff4c]';
_.M = '[Mm\u1d39\u1d50\u1e3e-\u1e43\u2120\u2122\u2133\u216f\u217f\u24a8\u24c2\u24dc\u3377-\u3379\u3383\u3386\u338e\u3392\u3396\u3399-\u33a8\u33ab\u33b3\u33b7\u33b9\u33bd\u33bf\u33c1\u33c2\u33ce\u33d0\u33d4-\u33d6\u33d8\u33d9\u33de\u33df\uff2d\uff4d]';
_.N = '[Nn\xd1\xf1\u0143-\u0149\u01ca-\u01cc\u01f8\u01f9\u1d3a\u1e44-\u1e4b\u207f\u2115\u2116\u24a9\u24c3\u24dd\u3381\u338b\u339a\u33b1\u33b5\u33bb\u33cc\u33d1\uff2e\uff4e]';
_.O = '[Oo\xba\xd2-\xd6\xf2-\xf6\u014c-\u0151\u01a0\u01a1\u01d1\u01d2\u01ea\u01eb\u020c-\u020f\u022e\u022f\u1d3c\u1d52\u1ecc-\u1ecf\u2092\u2105\u2116\u2134\u24aa\u24c4\u24de\u3375\u33c7\u33d2\u33d6\uff2f\uff4f]';
_.P = '[Pp\u1d3e\u1d56\u1e54-\u1e57\u2119\u24ab\u24c5\u24df\u3250\u3371\u3376\u3380\u338a\u33a9-\u33ac\u33b0\u33b4\u33ba\u33cb\u33d7-\u33da\uff30\uff50]';
_.Q = '[Qq\u211a\u24ac\u24c6\u24e0\u33c3\uff31\uff51]';
_.R = '[Rr\u0154-\u0159\u0210-\u0213\u02b3\u1d3f\u1d63\u1e58-\u1e5b\u1e5e\u1e5f\u20a8\u211b-\u211d\u24ad\u24c7\u24e1\u32cd\u3374\u33ad-\u33af\u33da\u33db\uff32\uff52]';
_.S = '[Ss\u015a-\u0161\u017f\u0218\u0219\u02e2\u1e60-\u1e63\u20a8\u2101\u2120\u24ae\u24c8\u24e2\u33a7\u33a8\u33ae-\u33b3\u33db\u33dc\ufb06\uff33\uff53]';
_.T = '[Tt\u0162-\u0165\u021a\u021b\u1d40\u1d57\u1e6a-\u1e71\u1e97\u2121\u2122\u24af\u24c9\u24e3\u3250\u32cf\u3394\u33cf\ufb05\ufb06\uff34\uff54]';
_.U = '[Uu\xd9-\xdc\xf9-\xfc\u0168-\u0173\u01af\u01b0\u01d3\u01d4\u0214-\u0217\u1d41\u1d58\u1d64\u1e72-\u1e77\u1ee4-\u1ee7\u2106\u24b0\u24ca\u24e4\u3373\u337a\uff35\uff55]';
_.V = '[Vv\u1d5b\u1d65\u1e7c-\u1e7f\u2163-\u2167\u2173-\u2177\u24b1\u24cb\u24e5\u2c7d\u32ce\u3375\u33b4-\u33b9\u33dc\u33de\uff36\uff56]';
_.W = '[Ww\u0174\u0175\u02b7\u1d42\u1e80-\u1e89\u1e98\u24b2\u24cc\u24e6\u33ba-\u33bf\u33dd\uff37\uff57]';
_.X = '[Xx\u02e3\u1e8a-\u1e8d\u2093\u213b\u2168-\u216b\u2178-\u217b\u24b3\u24cd\u24e7\u33d3\uff38\uff58]';
_.Y = '[Yy\xdd\xfd\xff\u0176-\u0178\u0232\u0233\u02b8\u1e8e\u1e8f\u1e99\u1ef2-\u1ef9\u24b4\u24ce\u24e8\u33c9\uff39\uff59]';
_.Z = '[Zz\u0179-\u017e\u01f1-\u01f3\u1dbb\u1e90-\u1e95\u2124\u2128\u24b5\u24cf\u24e9\u3390-\u3394\uff3a\uff5a]';

});

define('type/regexp/snippets',['require','exports','module','./accents'],function (require, exports, module) {var accents = require( './accents' );

var S = module.exports = {};

// Regex data types on strings
S.INT = '\\d+';
S.MD5 = '[0-9a-f]{32}';

// Filters
S.accented = (function() {
    var i, r = "";

    for( i in accents )
        r += accents[ i ].replace(/[\[\]]/ig, '');

    return new RegExp( r );
})();

S.alpha = /a-zA-Z/;
S.numeric = /0-9/;
S.spaced = / /;
S.doted = /./;

S.brackets = /{}[]()/;
S.punctuation = /,.!?/;
S.dividers = /-_\/\\/;
S.cotters = /\"\'/;
S.monetaries = /€£$/;
S.mathematical = /%*\/+-/;
S.extra = /#@&/;
S.breaklines = /\n/;

// Regex content types
S.url = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+(:[0-9]+)?|(?:ww‌​w.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?‌​(?:[\w]*))?)/;
S.email = /(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
S.subject_email = new RegExp( '([' + (S.accented+'').replace( /\//ig, '') + ']+ )+<' + (S.email+'').replace( /\//ig, '') + '>' );
S.ipv4 = /([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])/;

});

define('type/regexp/index',['require','exports','module','./accents','./snippets'],function (require, exports, module) {module.exports = (function ( ƒ ){
    var rg = ƒ.Regexp = ƒ.regexp = ƒ.RegExp = {};

    // is and isnt
    rg.is = ƒ.is.RegExp;
    rg.isnt = ƒ.isnt.RegExp;

    // Load snippets from snippets file
    rg.accents = require( './accents' );
    rg.snippets = require( './snippets' );

    rg.builder = function ( snippets, options ) {

        // Check snippets
        snippets =
        ƒ.is.Array( snippets ) && snippets ||
        ƒ.is.String( snippets ) && [ snippets ] ||
            [];

        // Get options
        options = ƒ.extend( {}, rg.builder.options, ƒ.is.Object( options ) && options || {} );

        // Get only snippets that are valid
        snippets = ƒ.filter( snippets, function ( snippet ) {
            return ƒ.isnt.undefined( rg.snippets[ snippet ] );
        });

        if( ! snippets.length ) {
            throw new TypeError("snippets must contain valid snippets, check docs");
        }

        var r = ƒ.map( snippets, function ( snippet ) {
            return rg.snippets[ snippet ].toString().replace( /^\//, '' ).replace( /\/$/, '' );
        }).join('');

        if( options.encapsulate ) r = ( options.negative && '[^' || '[' ) + r +']' + ( options.entire && '*' || '' );
        if( options.optional ) r = '?('+ r +')';
        if( options.allowEmpty ) r = '('+ r +'|)';
        if( options.entire ) r = '^'+ r +'$';

        return new RegExp( r, options.flags || 'gi' );
    };

        rg.builder.options = {
            entire: true,
            encapsulate: true,
            optional: false,
            allowEmpty: false,
            negative: false,
        };

    rg.test = function ( string, snippets, options ) {
        var reg = rg.builder( snippets, options );

        if( ! reg ) {
            return false;
        }

        return reg.test( string );
    };
    rg.match = function ( string, snippets, options ) {
        var reg = rg.builder( snippets, options );

        if( ! reg ) {
            return false;
        }

        return string.match( reg );
    };

    // TODO: Don't forget to mention on docs how fucking good this fn works!!1
    rg.querify = function ( string ) {

        // escape meta characters
        string = string.replace(/([|()[{.+*?^$\\])/g,"\\$1");

        // split into words
        var words = string.split(/\s+/);

        // sort by length
        words.sort(function ( a, b ) {
            return b.length - a.length;
        });

        // replace characters by their compositors
        var accent_replacer = function ( chr ) {
            return rg.accents[ chr.toUpperCase() ] || chr;
        };

        for ( var i = 0; i < words.length; i++ ) {
            words[i] = words[i].replace(/\S/g,accent_replacer);
        }

        // join as alternatives
        return new RegExp( words.join("|") );
    };

    rg.filter = function ( regexp, object ) {
        return ƒ.filter( object, function ( value ) {
            return ƒ.is.String( value ) && value.match( regexp );
        });
    };

});

});

define('type/date',['require','exports','module'],function (require, exports, module) {module.exports = (function ( ƒ ){

    var date = ƒ.Date = ƒ.date = {};

    date.format = function( dateToFormat, format ) {

        var returnStr = '',
            replace = date.format.chars;

        for (var i = 0; i < format.length; i++) {
            var curChar = format.charAt(i);

            if (i - 1 >= 0 && format.charAt(i - 1) == "\\")
                returnStr += curChar;

            else if (replace[curChar])
                returnStr += replace[curChar].call(dateToFormat);

            else if (curChar != "\\")
                returnStr += curChar;

        }

        return returnStr;
    };

    date.format.chars = {
		shortMonths: [
        'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		longMonths: [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'],
		shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		longDays: [
        'Sunday', 'Monday', 'Tuesday', 'Wednesday',
        'Thursday', 'Friday', 'Saturday'],

		// Day
		d: function() { return (this.getDate() < 10 ? '0' : '') + this.getDate(); },
		D: function() { return date.format.chars.shortDays[this.getDay()]; },
		j: function() { return this.getDate(); },
		l: function() { return date.format.chars.longDays[this.getDay()]; },
		N: function() { return this.getDay() + 1; },
		S: function() { return (this.getDate() % 10 == 1 && this.getDate() != 11 ? 'st' : (this.getDate() % 10 == 2 && this.getDate() != 12 ? 'nd' : (this.getDate() % 10 == 3 && this.getDate() != 13 ? 'rd' : 'th'))); },
		w: function() { return this.getDay(); },
		z: function() { var d = new Date(this.getFullYear(),0,1); return Math.ceil((this - d) / 86400000); }, // Fixed now
		// Week
		W: function() { var d = new Date(this.getFullYear(), 0, 1); return Math.ceil((((this - d) / 86400000) + d.getDay() + 1) / 7); }, // Fixed now
		// Month
		F: function() { return date.format.chars.longMonths[this.getMonth()]; },
		m: function() { return (this.getMonth() < 9 ? '0' : '') + (this.getMonth() + 1); },
		M: function() { return date.format.chars.shortMonths[this.getMonth()]; },
		n: function() { return this.getMonth() + 1; },
		t: function() { var d = new Date(); return new Date(d.getFullYear(), d.getMonth(), 0).getDate() }, // Fixed now, gets #days of date
		// Year
		L: function() { var year = this.getFullYear(); return (year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)); },   // Fixed now
		o: function() { var d  = new Date(this.valueOf());  d.setDate(d.getDate() - ((this.getDay() + 6) % 7) + 3); return d.getFullYear();}, //Fixed now
		Y: function() { return this.getFullYear(); },
		y: function() { return ('' + this.getFullYear()).substr(2); },
		// Time
		a: function() { return this.getHours() < 12 ? 'am' : 'pm'; },
		A: function() { return this.getHours() < 12 ? 'AM' : 'PM'; },
		B: function() { return Math.floor((((this.getUTCHours() + 1) % 24) + this.getUTCMinutes() / 60 + this.getUTCSeconds() / 3600) * 1000 / 24); }, // Fixed now
		g: function() { return this.getHours() % 12 || 12; },
		G: function() { return this.getHours(); },
		h: function() { return ((this.getHours() % 12 || 12) < 10 ? '0' : '') + (this.getHours() % 12 || 12); },
		H: function() { return (this.getHours() < 10 ? '0' : '') + this.getHours(); },
		i: function() { return (this.getMinutes() < 10 ? '0' : '') + this.getMinutes(); },
		s: function() { return (this.getSeconds() < 10 ? '0' : '') + this.getSeconds(); },
		u: function() { var m = this.getMilliseconds(); return (m < 10 ? '00' : (m < 100 ? '0' : '')) + m; },
		// Timezone
		e: function() { return "Not Yet Supported"; },
		I: function() {
			var DST = null;
				for (var i = 0; i < 12; ++i) {
						var d = new Date(this.getFullYear(), i, 1);
						var offset = d.getTimezoneOffset();

						if (DST === null) DST = offset;
						else if (offset < DST) { DST = offset; break; }                     else if (offset > DST) break;
				}
				return (this.getTimezoneOffset() == DST) | 0;
			},
		O: function() { return (-this.getTimezoneOffset() < 0 ? '-' : '+') + (Math.abs(this.getTimezoneOffset() / 60) < 10 ? '0' : '') + (Math.abs(this.getTimezoneOffset() / 60)) + '00'; },
		P: function() { return (-this.getTimezoneOffset() < 0 ? '-' : '+') + (Math.abs(this.getTimezoneOffset() / 60) < 10 ? '0' : '') + (Math.abs(this.getTimezoneOffset() / 60)) + ':00'; }, // Fixed now
		T: function() { var m = this.getMonth(); this.setMonth(0); var result = this.toTimeString().replace(/^.+ \(?([^\)]+)\)?$/, '$1'); this.setMonth(m); return result;},
		Z: function() { return -this.getTimezoneOffset() * 60; },
		// Full Date/Time
		c: function() { return this.format("Y-m-d\\TH:i:sP"); }, // Fixed now
		r: function() { return this.toString(); },
		U: function() { return this.getTime() / 1000; }
	};
});

});

define('index',['require','exports','module','./core','./isisnt','./from','./to','./type/array','./type/function','./type/object','./type/string','./type/regexp/index','./type/date'],function (require, exports, module) {/**
  The entry point.
  @module ƒ
**/


/**
 * To use it, you just need to import it:
 *
 * ```js
 * var ƒ = require('findhit-util');
 * // OR
 * var Util = require('findhit-util');
 * ```
 *
 *
 * @class ƒ
 */

var ƒ = {};

require('./core')( ƒ );
require('./isisnt')( ƒ );
require('./from')( ƒ );
require('./to')( ƒ );

// Load utils by type
require('./type/array')( ƒ );
require('./type/function')( ƒ );
require('./type/object')( ƒ );
require('./type/string')( ƒ );
require('./type/regexp/index')( ƒ );
require('./type/date')( ƒ );

// Export it
module.exports = ƒ;

// TODO: AMDify

});

return require('index'); }));