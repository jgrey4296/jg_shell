!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],n):"object"==typeof exports?exports.Rete=n(require("lodash")):e.Rete=n(e._)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE_lodash__){return function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./ReteClassInterface.js")}({"./ReteActionAssert.js":
/*!*****************************!*\
  !*** ./ReteActionAssert.js ***!
  \*****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/**\n   Defines the Assert Action\n   @module ReteActionAssert\n   @requires ReteArithmeticActions\n   @requires ReteUtilities\n   @requires ReteDataStructures\n   @requires lodash\n*/\n\n/**\n   @implements {module:ReteActionInterface}\n   @class AssertAction\n */\n\nvar AssertAction = {\n  "name": "assert",\n  propose: null,\n  perform: null\n};\n/* harmony default export */ __webpack_exports__["default"] = (AssertAction);\n/**\n   Propose the Assertion, will be bound to an action description @alias{RuleCtors:Action}\n   @param {module:ReteDataStructures.Token} token The token that is emitted by the network\n   @param {module:ReteClassInterface.ReteNet} reteNet The top level reteNet\n   @function\n */\n\nAssertAction.propose = function (token, reteNet) {\n  //create the data object:\n  var newWMEData = reteNet.utils.createNewWMEData(this, token);\n  reteNet.utils.applyArithmetic(this, newWMEData);\n  reteNet.utils.applyRegex(this, newWMEData); //Expand out to object structure\n  //ie: {values.a:5, tags.type: rule} -> {values:{a:5},tags:{type:rule}}\n\n  var complexFormData = reteNet.utils.objDescToObject(newWMEData); //To be returned to activateActionNode\n\n  var proposedAction = new reteNet.ProposedAction(reteNet, "assert", this.name, complexFormData, token, reteNet.currentTime, this.timing, this.priority);\n  return proposedAction;\n};\n/**\n   Perform the Assertion, after having been scheduled\n   @param {module:ReteDataStructures.ProposedAction} proposedAction\n   @param {module:ReteClassInterface.ReteNet} reteNet\n   @function\n   @return {Object}\n */\n\n\nAssertAction.perform = function (proposedAction, reteNet) {\n  //check the type matches\n  if (proposedAction.actionType !== \'assert\') {\n    throw new Error("Expected Assert");\n  } //Perform the action:\n\n\n  var newWMEID = reteNet.assertWME(proposedAction.payload, proposedAction.retractTime); //schedule the retraction:\n\n  if (proposedAction.timing.unperformOffset > 0) {\n    //schedule a retract, with no invalidate time (its not being proposed)\n    //and the perform time being the original actions unperformoffset\n    reteNet.addToSchedule(new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "retract", newWMEID, null, reteNet.currentTime, {\n      invalidateOffset: null,\n      performOffset: proposedAction.timing.unperformOffset,\n      unperformOffset: null\n    }));\n  }\n\n  return {\n    "asserted": newWMEID\n  };\n};\n\n//# sourceURL=webpack://Rete/./ReteActionAssert.js?')},"./ReteActionRetract.js":
/*!******************************!*\
  !*** ./ReteActionRetract.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/**\n   Defines the Retract Action\n   @module ReteActionRetract\n   @requires ReteArithmeticActions\n   @requires ReteUtilities\n   @requires ReteDataStructures\n   @requires lodash\n*/\n\n\n/**\n   @class RetractAction\n   @implements {ReteActionInterface}\n */\n\nvar RetractAction = {\n  "name": "retract",\n  propose: null,\n  perform: null\n};\n/* harmony default export */ __webpack_exports__["default"] = (RetractAction);\n/**\n   Propose the Retraction\n   @function\n */\n\nRetractAction.propose = function (token, reteNet) {\n  var _this = this;\n\n  //get all wmes the token touches:\n  var wmes = [],\n      currToken = token,\n      varRegex = /^\\${(\\w+)}/;\n\n  while (currToken && currToken.wme !== undefined) {\n    wmes.push(currToken.wme);\n    currToken = currToken.parentToken;\n  } //Get the keys of the action that have \'wme\' in them\n\n\n  var wmeKeys = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.values).filter(function (d) {\n    return /^wme([0-9]*)/.test(d);\n  }),\n      //get the ones of those that related to a binding in the token\n  wmeIdBindings = wmeKeys.map(function (d) {\n    return _this.values[d];\n  }).filter(function (d) {\n    return varRegex.test(d);\n  }),\n      //get the value for those bindings\n  wmeIds = wmeIdBindings.map(function (d) {\n    var match = varRegex.exec(d);\n    return token.bindings[match[1]];\n  }); //console.log("Token bindings :",token.bindings);\n  //console.log("Retrieved wme ids for retraction:",wmeIds);\n  // //filter the wmeList by the wmeIDs:\n  // let toRetract = _.filter(wmes,function(wme){\n  //     return _.contains(wmeIDs,wme.id);\n  // });\n  //Propose the list of all wmes to retract\n\n\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ProposedAction"](reteNet, "retract", this.name, wmeIds, token, reteNet.currentTime, this.timing);\n  return proposedAction;\n};\n/**\n   Perform the retraction\n   @function\n */\n\n\nRetractAction.perform = function (proposedAction, reteNet) {\n  if (proposedAction.actionType !== \'retract\') {\n    throw new Error("Expected retract");\n  } //console.log("Retracting:",proposedAction.payload);\n\n\n  if (proposedAction.payload instanceof Array) {\n    var retractedWMEs = proposedAction.payload.map(function (d) {\n      return reteNet.retractWME(d);\n    });\n    return {\n      "retracted": retractedWMEs\n    };\n  }\n\n  var retractedWME = reteNet.retractWME(proposedAction.payload);\n  return {\n    "retracted": [retractedWME]\n  }; //do anything with the retracted wme(s)?\n};\n\n//# sourceURL=webpack://Rete/./ReteActionRetract.js?')},"./ReteAction_addRule.js":
/*!*******************************!*\
  !*** ./ReteAction_addRule.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n\nvar AddRule = {\n  "name": "addRule",\n  propose: null,\n  perform: null\n};\n/* harmony default export */ __webpack_exports__["default"] = (AddRule); //Token + Action Description -> ProposedAction\n\nAddRule.propose = function (token, reteNet) {\n  //Propose the list of all wmes to retract\n  //TODO: Check this\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "NO-OP", this.name, token.wme, token, reteNet.currentTime, this.timing);\n  return proposedAction;\n}; //ProposedAction -> Performance\n\n\nAddRule.perform = function (proposedAction, reteNet) {\n  console.log("No-op");\n};\n\n//# sourceURL=webpack://Rete/./ReteAction_addRule.js?')},"./ReteAction_removeRule.js":
/*!**********************************!*\
  !*** ./ReteAction_removeRule.js ***!
  \**********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n\nvar RemoveRule = {\n  "name": "removeRule",\n  propose: null,\n  perform: null\n};\n/* harmony default export */ __webpack_exports__["default"] = (RemoveRule); //Token + Action Description -> ProposedAction\n\nRemoveRule.propose = function (token, reteNet) {\n  //Propose the list of all wmes to retract\n  var proposedAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_0__["ProposedAction"](reteNet, "NO-OP", this.name, token.wme, token, reteNet.currentTime, this.timing);\n  return proposedAction;\n}; //ProposedAction -> performance\n\n\nRemoveRule.perform = function (proposedAction, reteNet) {\n  console.log("No-op");\n};\n\n//# sourceURL=webpack://Rete/./ReteAction_removeRule.js?')},"./ReteActions.js":
/*!************************!*\
  !*** ./ReteActions.js ***!
  \************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReteActionAssert */ "./ReteActionAssert.js");\n/* harmony import */ var _ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteActionRetract */ "./ReteActionRetract.js");\n/* harmony import */ var _ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteAction_addRule */ "./ReteAction_addRule.js");\n/* harmony import */ var _ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteAction_removeRule */ "./ReteAction_removeRule.js");\n/**\n   Aggregates ReteNet Actions that implement {@link module:ReteAggregateActionDefinitions}\n   @module ReteActions\n*/\n\n\n\n //Action node possible actions:\n//Stores both performance functions and proposal functions\n//in the form: { name : {name: "", performFunc : func, propseFunc : func } }\n\nvar AggregateActionDefinitions = {};\n/* harmony default export */ __webpack_exports__["default"] = (AggregateActionDefinitions); //Performance functions take a retenet, and a payload\n//proposal functions are bound to an action description, and take a token and a retenet\n//eg: the action asserts a new wme, with an arithmetic action of +2,\n//the action has the information (+ 2), the incoming token as the base value to add to.\n//Proposal functions return an object of the form:\n//{ action: "", payload: {}, (timeData)? }\n//** @action assert\n\nAggregateActionDefinitions[_ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__["default"].name] = _ReteActionAssert__WEBPACK_IMPORTED_MODULE_0__["default"]; //** @action retract\n\nAggregateActionDefinitions[_ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__["default"].name] = _ReteActionRetract__WEBPACK_IMPORTED_MODULE_1__["default"]; //** @action AddRule\n\nAggregateActionDefinitions[_ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__["default"].name] = _ReteAction_addRule__WEBPACK_IMPORTED_MODULE_2__["default"]; //** @action removeRule\n\nAggregateActionDefinitions[_ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__["default"].name] = _ReteAction_removeRule__WEBPACK_IMPORTED_MODULE_3__["default"];\n\n//# sourceURL=webpack://Rete/./ReteActions.js?')},"./ReteActivationAndDeletion.js":
/*!**************************************!*\
  !*** ./ReteActivationAndDeletion.js ***!
  \**************************************/
/*! exports provided: deleteDescendentsOfToken, removeAlphaMemoryItemsForWME, deleteAllTokensForWME, deleteAllNegJoinResultsForWME, deleteNodeAndAnyUnusedAncestors, leftActivate, rightActivate, alphaNodeActivation, activateIfNegatedJRIsUnblocked */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteDescendentsOfToken", function() { return deleteDescendentsOfToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeAlphaMemoryItemsForWME", function() { return removeAlphaMemoryItemsForWME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteAllTokensForWME", function() { return deleteAllTokensForWME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteAllNegJoinResultsForWME", function() { return deleteAllNegJoinResultsForWME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteNodeAndAnyUnusedAncestors", function() { return deleteNodeAndAnyUnusedAncestors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftActivate", function() { return leftActivate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightActivate", function() { return rightActivate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alphaNodeActivation", function() { return alphaNodeActivation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activateIfNegatedJRIsUnblocked", function() { return activateIfNegatedJRIsUnblocked; });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\n/* harmony import */ var _ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReteTestExecution */ "./ReteTestExecution.js");\n/**\n   Functions that describe Activation of ReteNet nodes, and the removal of said nodes\n   @module ReteActivationAndDeletion\n   @requires ReteDataStructures\n   @requires ReteComparisonOperators\n   @requires ReteUtilities\n   @requires ReteTestExecution\n   @requires ReteActions\n   @requires lodash\n*/\n\n\n\n\n\n/**\n   Stores a wme in an alpha memory,\n   Trigger an alpha memory with a new wme to store\n   @param alphaMem\n   @param wme\n   @function alphaMemoryActivation\n*/\n\nvar alphaMemoryActivation = function alphaMemoryActivation(alphaMem, wme) {\n  var newItem = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemoryItem"](wme, alphaMem);\n  alphaMem.items.unshift(newItem);\n  wme.alphaMemoryItems.unshift(newItem);\n\n  var alphaMemChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(alphaMem.children);\n\n  alphaMemChildren.forEach(function (child) {\n    return rightActivate(child, wme);\n  });\n};\n/**\n   Tests a wme against the test in the given node\n   @param alphaNode\n   @param wme\n   @function constantTestNodeActivation\n*/\n\n\nvar constantTestNodeActivation = function constantTestNodeActivation(alphaNode, wme) {\n  //test the wme using the constant test in the node\n  var testResult = false;\n\n  if (alphaNode.passThrough) {\n    testResult = true;\n  } else {\n    var wmeFieldValue = _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["retrieveWMEValueFromDotString"](wme, alphaNode.testField),\n        value = alphaNode.testValue,\n        operator = alphaNode.operator;\n\n    if (wmeFieldValue === null) {\n      return false;\n    }\n\n    if (_ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator]) {\n      if (operator !== \'EQ\' && operator !== \'NE\') {\n        testResult = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator](Number(wmeFieldValue), Number(value));\n      } else {\n        testResult = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][operator](wmeFieldValue, value);\n      }\n    }\n  }\n\n  if (testResult) {\n    if (alphaNode.outputMemory) {\n      alphaNodeActivation(alphaNode.outputMemory, wme);\n    }\n\n    alphaNode.children.forEach(function (child) {\n      return alphaNodeActivation(child, wme);\n    });\n  }\n\n  return testResult;\n};\n/**\n   Selects whether to store a wme, or test the wme\n   @param alphaNode\n   @param wme\n   @function alphaNodeActivation\n*/\n//Switchable activation function for alpha network stuff\n\n\nvar alphaNodeActivation = function alphaNodeActivation(alphaNode, wme) {\n  if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"]) {\n    alphaMemoryActivation(alphaNode, wme);\n  } else if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"]) {\n    return constantTestNodeActivation(alphaNode, wme);\n  } else {\n    throw new Error("Unrecognised node:", alphaNode);\n  }\n};\n/**\n   Stores a token in the beta memory\n   @param betaMemory\n   @param token\n   @function betaMemoryActivation\n*/\n\n\nvar betaMemoryActivation = function betaMemoryActivation(betaMemory, token) {\n  //trigger a beta memory to store a new token\n  //bindings are from the join node, holding results of the NEW binding tests\n  //old bindings are still in the token, the constructor of Token will combine the two\n  //sets of bindings\n  var newToken = token;\n  betaMemory.items.unshift(newToken);\n\n  var betaMemoryChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(betaMemory.children);\n\n  betaMemoryChildren.forEach(function (child) {\n    return leftActivate(child, newToken);\n  });\n};\n/**\n   Given a new token, compares it to all wmes in the related alpha memory\n   @param node\n   @param token\n   @function joinNodeLeftActivation\n*/\n\n\nvar joinNodeLeftActivation = function joinNodeLeftActivation(node, token) {\n  //Trigger a join node with a new token\n  //will pull all wmes needed from the linked alphaMemory\n  //If necessary, relink or unlink the\n  //parent betamemory or alphamemory\n  if (node.parent.items && node.parent.items.length === 1) {\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToAlphaMemory"](node);\n\n    if (node.alphaMemory.items.length === 0) {\n      //unlink beta memory if alphamemory is empty\n      var index = node.parent.children.map(function (d) {\n        return d.id;\n      }).indexOf(node.id),\n          unlinked = node.parent.children.splice(index, 1);\n      node.parent.unlinkedChildren.push(unlinked[0]);\n    }\n  } //for each wme in the alpha memory,\n  //compare using join tests,\n  //and pass on successful combinations\n  //to beta memory /negative node children\n  //to be combined into tokens\n\n\n  node.alphaMemory.items.forEach(function (item) {\n    var currWME = item.wme,\n        joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, token, currWME);\n\n    if (joinTestResult !== undefined && joinTestResult !== false) {\n      var newToken = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](token, currWME, node, joinTestResult);\n      node.items.unshift(newToken);\n      node.children.forEach(function (child) {\n        return leftActivate(child, newToken);\n      });\n    }\n  }); //end of looping all wmes in alphamemory\n};\n/**\n   @function joinNodeRightActivation\n   @param node\n   @param wme\n   @purpose given a new wme, compares it against all tokens in the related beta memory\n*/\n//Trigger a join node with a new wme\n//pulling all necessary tokens from the parent as needed\n\n\nvar joinNodeRightActivation = function joinNodeRightActivation(node, wme) {\n  //relink or unlink as necessary\n  if (node.alphaMemory.items.length === 1) {\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToBetaMemory"](node);\n\n    if (node.parent.items.length === 0) {\n      var index = node.alphaMemory.children.map(function (d) {\n        return d.id;\n      }).indexOf(node.id),\n          unlinked = node.alphaMemory.children.splice(index, 1);\n      node.alphaMemory.unlinkedChildren.push(unlinked[0]);\n    }\n  } //For all tokens, compare to the new wme,\n  //pass on successful combinations to betamemory/negative node\n\n\n  node.parent.items.forEach(function (currToken) {\n    if (currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0) {\n      return false;\n    }\n\n    var joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, currToken, wme);\n\n    if (joinTestResult !== undefined && joinTestResult !== false) {\n      var newToken = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](currToken, wme, node, joinTestResult);\n      node.items.unshift(newToken);\n\n      var nodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(node.children);\n\n      nodeChildren.forEach(function (d) {\n        return leftActivate(d, newToken);\n      });\n    }\n  });\n};\n/**\n   Given a new token, proposes a set of actions\n   @param actionNode\n   @param token\n   @function activateActionNode\n*/\n\n\nvar actionNodeActivation = function actionNodeActivation(actionNode, token) {\n  //get the actions the node embodies:\n  var boundActionFunctions = actionNode.boundActions,\n      //apply the token to each of the actions\n  newProposedActions = boundActionFunctions.map(function (d) {\n    return d(token, actionNode.reteNet);\n  }),\n      newProposedActionIds = newProposedActions.map(function (d) {\n    return d.id;\n  }); //store the proposed actions in the reteNet.potential actions\n  //and also tie all the actions that fire together by their ids\n  //ie: {action:"assert",payload:wme}\n  //see RDS.ProposedAction for details\n\n  newProposedActions.forEach(function (d) {\n    newProposedActionIds.forEach(function (i) {\n      d.addParallelAction(i);\n    });\n    actionNode.reteNet.proposeAction(d);\n  });\n};\n/**\n   Selects what node to activate as appropriate, for a new token\n   @function leftActivate\n*/\n\n\nvar leftActivate = function leftActivate(node, token, wme, joinTestResults) {\n  //Utility leftActivation function to call\n  //whichever specific type is needed\n  //Construct a new token if supplied the correct\n  //parameters\n  if (!(node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"])) {\n    token = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"](token, wme, node, joinTestResults);\n  } //owning node is the node going into, rather than coming out of\n  //Activate the node:\n  //Essentially a switch of:\n  //betaMemory, JoinNode, NegativeNode, NCC, PartnerNode, and action\n\n\n  if (node.__isDummy) {//pass on, because this is a test\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\n    betaMemoryActivation(node, token);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n    joinNodeLeftActivation(node, token);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\n    negativeNodeLeftActivation(node, token);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\n    nccNodeLeftActivation(node, token);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"]) {\n    nccPartnerNodeLeftActivation(node, token);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"]) {\n    actionNodeActivation(node, token);\n  } else {\n    throw new Error("Unknown node type leftActivated");\n  }\n\n  return token;\n};\n/**\n   Selects what node to activate, given a new wme\n   @param node\n   @param wme\n   @function rightActivate\n*/\n\n\nvar rightActivate = function rightActivate(node, wme) {\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n    joinNodeRightActivation(node, wme);\n  } else if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\n    negativeNodeRightActivation(node, wme);\n  } else {\n    throw new Error("Tried to rightActivate Unrecognised node");\n  }\n};\n/**\n   Activate a negative node with a new token\n   @param node\n   @param newToken\n   @function negativeNodeLeftActivation\n*/\n\n\nvar negativeNodeLeftActivation = function negativeNodeLeftActivation(node, newToken) {\n  //Trigger a negative node from a new token\n  //brings in bindings, creates a new token as necessary,\n  //combining bindings too.\n  //Relink\n  if (node.items.length === 0) {\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["relinkToAlphaMemory"](node);\n  }\n\n  node.items.unshift(newToken);\n  node.alphaMemory.items.forEach(function (item) {\n    var currWme = item.wme,\n        joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, newToken, currWme);\n\n    if (joinTestResult) {\n      //adds itself to the token and\n      //wme as necessary to block the token\n      new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeJoinResult"](newToken, currWme);\n    }\n  }); //if no wmes block the token, pass it on down the network\n\n  if (newToken.negJoinResults.length === 0) {\n    var nodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(node.children);\n\n    nodeChildren.forEach(function (child) {\n      return leftActivate(child, newToken);\n    });\n  }\n};\n/**\n   Activate a negative node with a new wme\n   @param node\n   @param wme\n   @function negativeNodeRightActivation\n*/\n\n\nvar negativeNodeRightActivation = function negativeNodeRightActivation(node, wme) {\n  //trigger a negative node from a new wme,\n  //getting all tokens stored, comparing to the wme.\n  //any that the wme blocks, gets an additional negative Join result\n  //any that don\'t get blocked should already have been activated\n  node.items.forEach(function (currToken) {\n    if (currToken.negJoinResults.length > 0 || currToken.nccResults.length > 0) {\n      return false;\n    }\n\n    var joinTestResult = Object(_ReteTestExecution__WEBPACK_IMPORTED_MODULE_4__["default"])(node, currToken, wme);\n\n    if (joinTestResult !== undefined && joinTestResult !== false) {\n      if (currToken.negJoinResults.length === 0) {\n        //todo: fix this\n        var invalidatedActions = deleteDescendentsOfToken(currToken);\n        _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["cleanupInvalidatedActions"](invalidatedActions);\n      } //Adds itself to the currToken and wme as\n      //necessary\n\n\n      new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeJoinResult"](currToken, wme);\n    }\n  });\n};\n/**\n   Activate a Negated Conjunctive Condition with a new Token\n   @param nccNode\n   @param token\n   @function nccNodeLeftActivation\n*/\n\n\nvar nccNodeLeftActivation = function nccNodeLeftActivation(nccNode, token) {\n  //from a new token, trigger the subnetwork?\n  //Create and store the incoming token from prior join node\n  if (!(nccNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"])) {\n    throw new Error("nccNodeLeftActivation should be on an NCCNode");\n  }\n\n  if (!(token instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"])) {\n    throw new Error("nccNodeLeftActivation should be on a token");\n  }\n\n  var newToken = token;\n  nccNode.items.unshift(newToken); //the partner\'s network MUST fire before the nccnode\n  //hence this. all the new results\' in the partners new result buffer,\n  //are from the same origin as token\n  //if there are new results to process:\n\n  while (nccNode.partner && nccNode.partner.newResultBuffer.length > 0) {\n    var newResult = nccNode.partner.newResultBuffer.pop(); //add the subnetworks result as a blocking token\n\n    newToken.nccResults.unshift(newResult); //set the subnetwork result to have its parent as the new token\n\n    newResult.parentToken = newToken;\n  } //if the new token has no blocking tokens,\n  //continue on\n\n\n  if (newToken.nccResults.length === 0) {\n    var nccNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(nccNode.children);\n\n    nccNodeChildren.forEach(function (child) {\n      return leftActivate(child, newToken);\n    });\n  }\n};\n/**\n   Activate a Negated Conjunctive Condition\'s subnetwork with a new token\n   @param partner\n   @param token\n   @function nccPartnerNodeLeftActivation\n*/\n\n\nvar nccPartnerNodeLeftActivation = function nccPartnerNodeLeftActivation(partner, token) {\n  //the nccPartnerNode is activated by a new token from the subnetwork\n  //figure out who owns this new token from the main (positive) network\n  //the partner\'s ncc\n  var nccNode = partner.nccNode,\n      //the token created in left activate, with partner as owner\n  newToken = token,\n      ownersToken = token.parentToken,\n      //the prior token\n  ownersWme = token.wme,\n      //the prior wme\n  owner;\n\n  for (var i = 0; i < partner.numberOfConjuncts; i++) {\n    //go up the owner chain\n    ownersWme = ownersToken.wme;\n    ownersToken = ownersToken.parentToken;\n  } //find an owner in the ncc node\'s memory to link to\n\n\n  if (nccNode !== undefined && ownersToken && ownersWme) {\n    var possibleTokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccNode.items, function (d) {\n      return d.parentToken.id !== ownersToken.id || d.wme && d.wme.id !== ownersWme.id;\n    });\n\n    if (possibleTokens.length > 0) {\n      owner = possibleTokens[0];\n    }\n  } //link the owner and the new token\n\n\n  if (owner !== undefined) {\n    //the necessary owner exists in the nccNode,\n    //so update it:\n    owner.nccResults.unshift(newToken);\n    newToken.parentToken = owner;\n    var invalidatedActions = deleteDescendentsOfToken(owner);\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["cleanupInvalidatedActions"](invalidatedActions);\n  } else {\n    //else no owner: add to temp buffer to wait for the ncc node to be activated\n    partner.newResultBuffer.unshift(newToken);\n  }\n};\n/**\n   Utility function to activate based on lack of existence of negated join results\n   @param nJR\n   @function activateIfNegatedJRIsUnblocked\n*/\n\n\nvar activateIfNegatedJRIsUnblocked = function activateIfNegatedJRIsUnblocked(nJR) {\n  var currJoinResult = nJR; //if the negation clears, activate it\n\n  if (currJoinResult.owner.negJoinResults.length === 0) {\n    var owningNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(currJoinResult.owner.owningNode.children);\n\n    owningNodeChildren.forEach(function (child) {\n      return leftActivate(child, currJoinResult.owner);\n    });\n  }\n};\n/**\n   To remove a wme from all alpha memories it is stored in\n   postCondition wme.alphaMemoryItems is empty\n   @param wme\n   @function removeAlphaMemoryItemsForWME\n*/\n\n\nvar removeAlphaMemoryItemsForWME = function removeAlphaMemoryItemsForWME(wme) {\n  //remove alpha memory items\n  wme.alphaMemoryItems.forEach(function (item) {\n    //unlink the alphamemory from the item\n    item.alphaMemory.items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(item.alphaMemory.items, function (d) {\n      return d.id === item.id;\n    }); //unlink the alphaMemory itself if it is now empty\n    //will unlink if am.items.length === 0\n\n    _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["unlinkAlphaMemory"](item.alphaMemory); //clear the item\'s links\n\n    item.alphaMemory = undefined;\n    item.wme = undefined;\n  }); //completely clear am items:\n\n  wme.alphaMemoryItems = [];\n};\n/**\n   To cleanup all tokens a wme is part of\n   @param wme\n   @function deleteAllTokensForWME\n*/\n\n\nvar deleteAllTokensForWME = function deleteAllTokensForWME(wme) {\n  var invalidatedActions = new Set(); //For all tokens\n\n  while (wme.tokens.length > 0) {\n    deleteTokenAndDescendents(wme.tokens[0]).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n  }\n\n  return Array.from(invalidatedActions);\n};\n/**\n   For negative conditions, discount the wme as a block\n   @param wme\n   @function deleteAllNegJoinResultsForWME\n*/\n\n\nvar deleteAllNegJoinResultsForWME = function deleteAllNegJoinResultsForWME(wme) {\n  //unlink the negative Join results in the owning token\n  wme.negJoinResults.forEach(function (jr) {\n    jr.owner.negJoinResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(jr.owner.negJoinResults, function (d) {\n      return d.id === jr.id;\n    });\n    activateIfNegatedJRIsUnblocked(jr); //remove internal references:\n\n    jr.owner = undefined;\n    jr.wme = undefined;\n  }); //completely clear negjoinresults\n\n  wme.negJoinResults = [];\n};\n/**\n   To delete any blocked tokens in negative conditions\n   @param token\n   @function removeNegJoinResultsForToken\n*/\n\n\nvar removeNegJoinResultsForToken = function removeNegJoinResultsForToken(token) {\n  //remove Negative join results\n  token.negJoinResults.forEach(function (jr) {\n    jr.wme.negJoinResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(jr.wme.negJoinResults, function (d) {\n      return d.id === jr.id;\n    }); //clear the references\n\n    jr.wme = undefined;\n    jr.token = undefined;\n  });\n  token.negJoinResults = [];\n};\n/**\n   To remove a token from whatever node created it\n   @param token\n   @function removeTokenFromNode\n*/\n//Now the utility functions for deleteing token:\n\n\nvar removeTokenFromNode = function removeTokenFromNode(token) {\n  //Deal with if the owning node is NOT an NCC\n  if (token.owningNode && !(token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"])) {\n    //&& (token.owningNode instanceof RDS.AlphaMemory || token.owningNode instanceof RDS.BetaMemory)){\n    //by removing the token as an element in that node\n    token.owningNode.items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.owningNode.items, function (d) {\n      return d.id === token.id;\n    });\n  }\n};\n/**\n   To clean a token up, removing it from any WME references\n   @function removeTokenFromWME\n*/\n\n\nvar removeTokenFromWME = function removeTokenFromWME(token) {\n  //remove the token from the wme it is based on\n  if (token.wme && token.wme.tokens) {\n    token.wme.tokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.wme.tokens, function (d) {\n      return d.id === token.id;\n    });\n  }\n};\n/**\n   Cleanup the token from its parents list\n   @param token\n   @function removeTokenFromParentToken\n*/\n\n\nvar removeTokenFromParentToken = function removeTokenFromParentToken(token) {\n  //Remove the token from it\'s parent\'s child list\n  if (token && token.parentToken) {\n    token.parentToken.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.parentToken.children, function (d) {\n      return d.id === token.id;\n    });\n  }\n};\n/**\n   Cleanup an unused node and any parent nodes that are also unused once this node is gone.\n   @param node\n   @function deleteNodeAndAnyUnusedAncestors\n*/\n\n\nvar deleteNodeAndAnyUnusedAncestors = function deleteNodeAndAnyUnusedAncestors(node) {\n  /*\n    Do a number of things:\n    clean up tokens stored in a node\n    remove any reference to the node from a connected alpha\n    remove any reference to the node from a parent\n    \n    +: call recursively on any parent that has no children\n  */\n  var invalidatedActions = new Set();\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"]) {\n    node.reteNet = null;\n  } //if NCC, delete partner too\n\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\n    var tempPartner = node.partner;\n    node.partner = null;\n    deleteNodeAndAnyUnusedAncestors(tempPartner).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n  } //clean up tokens\n\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] && node.dummy === undefined || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n    while (node.items.length > 0) {\n      var curr = node.items.pop();\n      deleteTokenAndDescendents(curr).forEach(function (d) {\n        return invalidatedActions.add(d);\n      });\n    }\n  }\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"]) {\n    while (node.newResultBuffer.length > 0) {\n      var _curr = node.newResultBuffer.pop();\n\n      deleteTokenAndDescendents(_curr).forEach(function (d) {\n        return invalidatedActions.add(d);\n      });\n    }\n  } //clean up any associated alphamemory\n\n\n  if (node.alphaMemory && (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"])) {\n    node.alphaMemory.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.alphaMemory.children, function (d) {\n      return d.id === node.id;\n    });\n    node.alphaMemory.unlinkedChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.alphaMemory.unlinkedChildren, function (d) {\n      return d.id === node.id;\n    });\n    node.alphaMemory.referenceCount--;\n\n    if (node.alphaMemory.referenceCount < 1) {\n      var tempAlphaMemory = node.alphaMemory;\n      node.alphaMemory = null;\n      deleteAlphaNode(tempAlphaMemory).forEach(function (d) {\n        return invalidatedActions.add(d);\n      });\n    }\n  } //remove the node from its parent\n\n\n  if (node.parent) {\n    //check the child list:\n    node.parent.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.parent.children, function (d) {\n      return d.id === node.id;\n    });\n    node.parent.unlinkedChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(node.parent.unlinkedChildren, function (d) {\n      return d.id === node.id;\n    });\n  } //delete parent node if its got no children\n\n\n  if (node.parent && node.parent.children.length === 0 && node.parent.unlinkedChildren && node.parent.unlinkedChildren.length === 0 && node.parent.dummy === undefined) {\n    var tempParent = node.parent;\n    node.parent = null;\n    deleteNodeAndAnyUnusedAncestors(tempParent).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n  } //delete any children to be sure\n\n\n  node.children.forEach(function (d) {\n    return deleteNodeAndAnyUnusedAncestors(d).forEach(function (e) {\n      return invalidatedActions.add(e);\n    });\n  });\n  node.unlinkedChildren.forEach(function (d) {\n    return deleteNodeAndAnyUnusedAncestors(d).forEach(function (e) {\n      return invalidatedActions.add(e);\n    });\n  }); //deallocate memory for none\n\n  node.cleanup = true; //schedule for cleanup in the retenet\n\n  return Array.from(invalidatedActions);\n};\n/**\n   Simplification of removing children of a token, but not the token itself\n   @param token\n   @function deleteDescendentsOfToken\n*/\n//utility function to delete all descendents without deleting the token\n\n\nvar deleteDescendentsOfToken = function deleteDescendentsOfToken(token) {\n  var invalidatedActions = new Set();\n\n  while (token.children.length > 0) {\n    var curr = token.children.pop();\n    deleteTokenAndDescendents(curr).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n  }\n\n  token.proposedActions.forEach(function (d) {\n    return invalidatedActions.add(d);\n  });\n  return Array.from(invalidatedActions);\n};\n/**\n   @param token\n   @function deleteTokenAndDescendents\n*/\n\n\nvar deleteTokenAndDescendents = function deleteTokenAndDescendents(token) {\n  /* purpose To remove a token and clean it\n  delete a token and all the tokens that rely on it\n  a bit of a frankenstein. Deletes the token,\n  deletes descendents, but also sets and cleans up\n  left unlinking of join nodes, AND\n  activates NCC\'s that are no longer blocked\n  */\n  var invalidatedActions = new Set(); //Recursive call:\n\n  while (token.children.length > 0) {\n    var curr = token.children.pop();\n    deleteTokenAndDescendents(curr).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n  } //Base Cases:\n  //remove memory items\n\n\n  removeTokenFromNode(token);\n  removeTokenFromWME(token);\n  removeTokenFromParentToken(token);\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["ifEmptyBetaMemoryUnlink"](token.owningNode);\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_3__["ifEmptyNegNodeUnlink"](token.owningNode, token.id);\n  removeNegJoinResultsForToken(token);\n  cleanupNCCResultsInToken(token);\n  cleanupNCCPartnerOwnedToken(token);\n\n  if (token && token.owningNode && token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] && token.parentToken.nccResults.length === 0) {\n    //Activate newly unblocked Token\n    //todo: should this be nccnode AND/OR negNode?\n    var nccNodeChildren = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(token.owningNode.nccNode.children);\n\n    nccNodeChildren.forEach(function (d) {\n      return leftActivate(d, token.parentToken);\n    });\n  } //get the queued actions linked with the token, and return them for cleanup\n\n\n  token.proposedActions.forEach(function (d) {\n    return invalidatedActions.add(d);\n  });\n  return Array.from(invalidatedActions);\n};\n/**\n   @param token\n   @function cleanupNCCResultsInToken\n*/\n\n\nvar cleanupNCCResultsInToken = function cleanupNCCResultsInToken(token) {\n  //NCCNODE\n  //for all the nccResult tokens, delete them\n  token.nccResults.forEach(function (nccR) {\n    //remove the nccR token from its linked wme\n    if (nccR.wme) {\n      nccR.wme.tokens = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccR.wme.tokens, function (d) {\n        return d.id === nccR.id;\n      });\n    }\n\n    if (nccR.parentToken) {\n      //remove the token from it\'s parent\n      nccR.parentToken.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(nccR.parentToken.children, function (d) {\n        return d.id === nccR.id;\n      });\n    }\n  }); //clear the nccResults\n\n  token.nccResults = [];\n};\n/**\n   @param token\n   @function cleanupNCCPartnerOwnedToken\n*/\n\n\nvar cleanupNCCPartnerOwnedToken = function cleanupNCCPartnerOwnedToken(token) {\n  //NCCPARTNERNODE\n  if (token.owningNode && token.owningNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] && token.parentToken) {\n    //remove from owner.nccResults:\n    token.parentToken.nccResults = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.parentToken.nccResults, function (d) {\n      return d.id === token.id;\n    });\n    token.owningNode.newResultBuffer = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(token.owningNode.newResultBuffer, function (d) {\n      return d.id === token.id;\n    });\n    return true;\n  }\n\n  return false;\n};\n\nvar deleteAlphaNode = function deleteAlphaNode(alphaNode) {\n  var invalidatedActions = new Set();\n\n  if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"] && alphaNode.children.length === 0 && alphaNode.outputMemory === null && alphaNode.passThrough === undefined) {\n    alphaNode.testField = null;\n    alphaNode.testValue = null;\n    alphaNode.operator = null;\n    alphaNode.parent.children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(alphaNode.parent.children, function (d) {\n      return d.id === alphaNode.id;\n    });\n    var oldParent = alphaNode.parent;\n    alphaNode.parent = null;\n    deleteAlphaNode(oldParent).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n    alphaNode.cleanup = true;\n  } else if (alphaNode instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"]) {\n    alphaNode.children.forEach(function (d) {\n      return deleteNodeAndAnyUnusedAncestors(d);\n    });\n    alphaNode.unlinkedChildren.forEach(function (d) {\n      return deleteNodeAndAnyUnusedAncestors(d);\n    });\n    alphaNode.children = [];\n    alphaNode.unlinkedChildren = [];\n    var itemIds = alphaNode.items.map(function (d) {\n      return d.id;\n    }),\n        itemWMEs = alphaNode.items.map(function (d) {\n      return d.wme;\n    });\n    itemWMEs.forEach(function (d) {\n      d.alphaMemoryItems = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(d.alphaMemoryItems, function (e) {\n        return itemIds.indexOf(e.id) > -1;\n      });\n    });\n    alphaNode.items = [];\n    var _oldParent = alphaNode.parent;\n    _oldParent.outputMemory = null;\n    alphaNode.parent = null;\n    deleteAlphaNode(_oldParent).forEach(function (d) {\n      return invalidatedActions.add(d);\n    });\n    alphaNode.cleanup = true;\n  }\n\n  return Array.from(invalidatedActions);\n};\n\n\n\n//# sourceURL=webpack://Rete/./ReteActivationAndDeletion.js?')},"./ReteArithmeticActions.js":
/*!**********************************!*\
  !*** ./ReteArithmeticActions.js ***!
  \**********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/**\n   Defines Arithmetic Actions that the retenet can perform\n   @module\n*/\n\n/** Add two values */\nvar plus = function plus(a, b) {\n  return a + b;\n},\n\n/** Subtract two values */\nminus = function minus(a, b) {\n  return a - b;\n},\n\n/** Multiply two values */\nmult = function mult(a, b) {\n  return a * b;\n},\n\n/** Divide two values */\ndiv = function div(a, b) {\n  return a / b;\n};\n\nvar ArithmeticOperators = {\n  '+': plus,\n  '-': minus,\n  '*': mult,\n  '/': div\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ArithmeticOperators);\n\n//# sourceURL=webpack://Rete/./ReteArithmeticActions.js?")},"./ReteClassInterface.js":
/*!*******************************!*\
  !*** ./ReteClassInterface.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/* harmony import */ var _ReteNetworkBuilding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteNetworkBuilding */ "./ReteNetworkBuilding.js");\n/* harmony import */ var _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteActivationAndDeletion */ "./ReteActivationAndDeletion.js");\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\n/* harmony import */ var _RuleCtors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RuleCtors */ "./RuleCtors.js");\n/* harmony import */ var _ReteActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReteActions */ "./ReteActions.js");\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\n/* harmony import */ var _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReteArithmeticActions */ "./ReteArithmeticActions.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n   Defines a class based ReteNet interface\n   @module ReteClassInterface\n   @requires ReteDataStructures\n   @requires ReteNetworkBuilding\n   @requires ReteActivationAndDeletion\n   @requires ReteUtilities\n   @requires RuleCtors\n   @requires ReteActions\n   @requires ReteComparisonOperators\n   @requires ReteArithmeticActions\n*/\n\n\n\n\n\n\n\n\n\n/**\n   The General controller for a retenet\n   @constructor\n   @param actionsToRegister\n*/\n\nvar ReteNet = function ReteNet(actionsToRegister) {\n  _classCallCheck(this, ReteNet);\n\n  if (actionsToRegister === undefined) {\n    actionsToRegister = [];\n  }\n  /**\n     The starting BetaMemory of the retenet\n     @member {module:ReteDataStructures.BetaMemory} dummyBetaMemory\n     @private\n  */\n\n\n  this.dummyBetaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]();\n  /**\n     The starting alpha node of the retenet\n     @member {module:ReteDataStructures.AlphaNode} rootAlpha\n     @private\n  */\n\n  this.rootAlpha = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"]();\n  /**\n     The available actions the retenet can perform\n     {name: string ,perform : function, propose : function };\n     @member {Object}\n     @see {@link module:ReteActions}\n  */\n\n  this.actionFunctions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.clone(_ReteActions__WEBPACK_IMPORTED_MODULE_6__["default"]);\n  /** @alias {module:RuleCtors.Rule} */\n\n  this.Rule = _RuleCtors__WEBPACK_IMPORTED_MODULE_5__["Rule"];\n  /** @see {module:ReteComparisonOperators} */\n\n  this.ComparisonOperators = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_7__["default"];\n  /** @see {module:ReteArithmeticActions} */\n\n  this.ArithmeticOperators = _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_8__["default"];\n  /** @see {module:ReteDataStructures.ProposedAction} */\n\n  this.ProposedAction = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ProposedAction"];\n  /** @see {module:ReteDataStructures.WME} */\n\n  this.WME = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"];\n  /** @see {module:ReteDataStructures.Token} */\n\n  this.Token = _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["Token"];\n  /** @see {module:ReteUtilities} */\n\n  this.utils = _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__;\n  /**\n     All rules loaded into the ReteNet\n     @member {Object}\n     @see {@link module:RuleCtors.Rule}\n  */\n\n  this.allRules = {};\n  /**\n     Constructed ActionNodes of the ReteNet\n     @member {Object}\n     @see {@link module:ReteDataStructures.ActionNode}\n  */\n\n  this.actions = {};\n  /**\n     All WMEs that exist in the ReteNet\n     @member {Object}\n     @see {@link module:ReteDataStructures.WME}\n  */\n\n  this.allWMEs = {};\n  /**\n     All Proposed Actions, from ActionNodes that have fired, indexed by id\n     could otherwise be known as the conflict set.\n     @member {Object}\n     @see {@link module:ReteDataStructure.ProposedActions}\n  */\n\n  this.proposedActions = {};\n  /**\n     All Actions that were schedule and then performed\n     @member {Array}\n     @see {@link module:ReteDataStructures.ProposedActions}\n  */\n\n  this.enactedActions = [];\n  /**\n     All nodes of the ReteNet, enabling inspection\n     @member {Object}\n  */\n\n  this.allReteNodes = {};\n  /**\n     All ReteNodes, indexed by type\n     todo: make this a weak map?\n     @member {Object}\n  */\n\n  this.allReteNodesByType = {};\n  /**\n     The current time step of the retenet\n     @member {Int}\n  */\n\n  this.currentTime = 1;\n  /**\n     The Actions that have been scheduled\n     @member {Object}\n  */\n\n  this.schedule = {\n    assert: [],\n    retract: [],\n    modify: []\n  };\n  /**\n     Listeners that have been registered for various occurences\n     @member {Object}\n  */\n\n  this.listeners = {\n    "propose": [],\n    "assert": [],\n    "retract": [],\n    "addRule": [],\n    "removeRule": [],\n    "schedule": [],\n    "stepTimeActions": [],\n    "registerAction": []\n  }; //Register actions passed in:\n\n  actionsToRegister.forEach(function (d) {\n    this.registerAction(d);\n  }, this);\n}; //--------------------\n//METHODS:\n//--------------------\n//Utility to register listeners:\n\n/**\n   Register a function for a retenet occurent\n   @param {string} name The occurrence type to listen for\n   @param {function} fn The function to trigger when the occurrence happens\n   @method\n*/\n\n\nReteNet.prototype.registerListener = function (name, fn) {\n  if (this.listeners[name] !== undefined) {\n    this.listeners[name].push(fn);\n  }\n};\n/**\n   Trigger all registered listeners for an occurence\n   @param {string} name The name of the occurrence that happened\n   @param ...vals The parameters to pass to the listener functions\n   @method\n*/\n\n\nReteNet.prototype.fireListener = function (name) {\n  for (var _len = arguments.length, vals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    vals[_key - 1] = arguments[_key];\n  }\n\n  if (this.listeners[name] === undefined) {\n    throw new Error("Unrecognised listener fired: ".concat(name));\n  } //call the registered functions\n\n\n  this.listeners[name].forEach(function (d) {\n    return d.apply(void 0, vals);\n  });\n};\n/**\n   Stores a wme in the retenet, without asserting it.\n   @param {WME} wme\n   @private\n*/\n\n\nReteNet.prototype.storeWME = function (wme) {\n  this.allWMEs[wme.id] = wme;\n};\n/**\n   Clears the history of actions that have been performed\n   @method\n*/\n\n\nReteNet.prototype.clearHistory = function () {\n  this.enactedActions = [];\n};\n/**\n   Clear the proposed actions list\n   @method\n*/\n\n\nReteNet.prototype.clearProposedActions = function () {\n  this.proposedActions = {};\n};\n/**\n   Assert a wme immediately\n   @param {WME/Object} wme The wme or data to assert\n   @return {Int} WME.id\n   @method\n*/\n\n\nReteNet.prototype.assertWME = function (wme) {\n  this.fireListener("assert", wme);\n\n  if (!(wme instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"])) {\n    wme = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"](wme, this.currentTime);\n    this.storeWME(wme);\n  } //Actually push the wme into the net\n\n\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["alphaNodeActivation"](this.rootAlpha, wme);\n  return wme.id;\n};\n/**\n   Retract a wme immediately\n   @param {wme/id} wme The wme object or id to retract\n   @method\n*/\n\n\nReteNet.prototype.retractWME = function (wme) {\n  this.fireListener("retract", wme); //if not given the wme directly\n\n  if (!(wme instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["WME"])) {\n    //if given a wme id\n    if (Number.isInteger(wme) && this.allWMEs[wme] !== undefined) {\n      wme = this.allWMEs[wme]; //if given a graph node with a related wme\n    } else if (wme.wmeId !== undefined && this.allWMEs[wme.wmeId] !== undefined) {\n      wme = this.allWMEs[wme.wmeId];\n    } else {\n      console.log("Unknown:", wme);\n      throw new Error("Unknown wme to retract");\n    }\n  } //Alpha Network retraction:\n\n\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["removeAlphaMemoryItemsForWME"](wme); //Beta Network retraction:\n\n  var invalidatedActions = _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteAllTokensForWME"](wme); //Resulting proposed action retraction:\n\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__["cleanupInvalidatedActions"](invalidatedActions); //Negative Node updates\n\n  _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteAllNegJoinResultsForWME"](wme); //Record when the wme was retracted\n\n  wme.lifeTime[1] = this.currentTime; //Remove it from the fact base\n\n  delete this.allWMEs[wme.id]; //And give it to the user if they want it\n\n  return wme;\n};\n/**\n   Retract, change, and then assert some data\n   @param {WME/id} wme The wme to retract\n   @param {function} modifyFunction The function that changes the data of the wme\n   @method\n*/\n\n\nReteNet.prototype.modifyWME = function (wme, modifyFunction) {\n  var retractedWME = this.retractWME(wme),\n      data = retractedWME.data,\n      modifiedData = modifyFunction(data);\n\n  if (modifiedData === undefined || modifiedData === null) {\n    throw new Error("Modify function must return the new data");\n  }\n\n  return this.assertWME(modifiedData);\n};\n/**\n   Propose an action, typically from an action node\n   @param {module:ReteDataStructures.ProposedAction} action\n   @method\n*/\n\n\nReteNet.prototype.proposeAction = function (action) {\n  var _this = this;\n\n  this.fireListener("propose", action);\n\n  if (action instanceof Array) {\n    action.forEach(function (d) {\n      return _this.proposeAction(d);\n    });\n    return;\n  }\n\n  if (this.proposedActions[action.id] !== undefined) {\n    throw new Error("Proposing a duplicate action");\n  }\n\n  this.proposedActions[action.id] = action;\n};\n\nReteNet.prototype.unproposeAction = function (actionId) {\n  if (this.proposedActions[actionId] !== undefined) {\n    this.proposedActions[actionId].removeFromParentToken();\n    delete this.proposedActions[actionId];\n  }\n};\n/**\n   Schedule an action by it\'s ID, ALSO scheduling any parallel actions\n   @param  {module:ReteDataStructures.ProposedAction|Int} actionId The action to propose\n   @method\n*/\n\n\nReteNet.prototype.scheduleAction = function (actionId) {\n  var _this2 = this;\n\n  this.fireListener("schedule", actionId);\n\n  if (actionId instanceof this.ProposedAction) {\n    this.scheduleAction(actionId.id);\n    return;\n  }\n\n  if (this.proposedActions[actionId] === undefined) {\n    throw new Error("Invalid action specified: " + actionId);\n  }\n\n  var action = this.proposedActions[actionId],\n      parallelActions = action.getParallelActions().map(function (d) {\n    return _this2.proposedActions[d];\n  });\n  this.addToSchedule(action);\n  parallelActions.forEach(function (d) {\n    return _this2.addToSchedule(d);\n  });\n  return this;\n};\n/**\n   Internal method to add to the schedule\n   @param {module:ReteDataStructures.ProposedAction} action\n   @method\n   @private\n*/\n\n\nReteNet.prototype.addToSchedule = function (action) {\n  if (action.actionType === undefined || action.payload === undefined || action.timing === undefined) {\n    throw new Error("Scheduling action failure");\n  }\n\n  if (this.schedule[action.actionType] === undefined) {\n    this.schedule[action.actionType] = [];\n  }\n\n  var performTime = this.currentTime + action.timing.performOffset;\n\n  if (this.schedule[action.actionType][performTime] === undefined) {\n    this.schedule[action.actionType][performTime] = [];\n  }\n\n  this.schedule[action.actionType][performTime].push(action); //Remove it from retenet\'s proposed actions:\n\n  this.unproposeAction(action.id);\n};\n/**\n   Step Time forward. actions should be scheduled BEFORE CALLING STEP TIME.\n   @method\n   @returns {Array} An array of the effects of this timestep\n*/\n\n\nReteNet.prototype.stepTime = function () {\n  var _this3 = this;\n\n  //get all actions scheduled at the current timepoint\n  var actions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.schedule),\n      actionsForTimePoint = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(actions.map(function (d) {\n    return d[_this3.currentTime];\n  })), function (d) {\n    return d === undefined;\n  }); //todo : group by tags:\n  //Sort by priority\n\n\n  actionsForTimePoint.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  this.fireListener(\'stepTimeActions\', actionsForTimePoint); //perform those actions, storing objects describing the changes\n\n  var changes = actionsForTimePoint.map(function (d) {\n    var performanceFunction = this.actionFunctions[d.actionType].perform,\n        effects = performanceFunction(d, this);\n    this.enactedActions.push(d);\n    return effects;\n  }, this); //cleanup invalidated actions\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.proposedActions).forEach(function (d) {\n    if (d.timing.invalidateTime <= this.currentTime) {\n      this.unproposeAction(d.id);\n    }\n  }, this);\n\n  this.currentTime++;\n  return changes;\n};\n/**\n   Add a rule to the retenet, auto converting to correct format if necessary, returning [ReteNet,{@link{module:ReteDataStructures.ActionNode}]\n   @param {Array | int | module:RuleCtors.Rule} ruleId The rule/rules to add\n   @param {Object} components An object to lookup components of rules in\n   @method\n   @returns {Array}\n   \n*/\n\n\nReteNet.prototype.addRule = function (ruleId, components) {\n  var _this4 = this;\n\n  this.fireListener("addRule", components);\n\n  if (ruleId instanceof Array) {\n    return ruleId.map(function (d) {\n      return _this4.addRule(d, components);\n    });\n  }\n\n  if (ruleId instanceof this.Rule) {\n    var convertedComponents = this.convertRulesToComponents(ruleId);\n    return this.addRule(ruleId.id, convertedComponents);\n  }\n\n  if (!Number.isInteger(ruleId) || components[ruleId] === undefined) {\n    throw new Error("Unrecognised rule id specified");\n  } //-----------\n  //Add a single rule:\n\n\n  var rule = components[ruleId],\n      ruleLinks = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(rule.linkedNodes),\n      //TODO: support rules as conditions by flattening the conditions repeatedly\n  conditions = ruleLinks.filter(function (d) {\n    return /^condition/.test(d[1]);\n  }).map(function (d) {\n    return components[d[0]];\n  }),\n      //build network with a dummy node for the parent\n  finalMemoryNode = Object(_ReteNetworkBuilding__WEBPACK_IMPORTED_MODULE_2__["default"])(this.dummyBetaMemory, conditions, this.rootAlpha, components, this),\n      //Get the action descriptions that are triggered by the rule:\n  //TODO: support rules as actions by repeatedly flattening\n  actionDescriptions = ruleLinks.filter(function (d) {\n    return /^action/.test(d[1]);\n  }).map(function (d) {\n    return components[d[0]];\n  }),\n      //Bind proposalFuncs with actionDescriptions\n  boundActionDescriptions = actionDescriptions.map(function (d) {\n    if (this.actionFunctions[d.tags.actionType] === undefined) {\n      throw new Error("Unrecognised action type");\n    }\n\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.bind(this.actionFunctions[d.tags.actionType].propose, d);\n  }, this),\n      //Create the action, with the bound action functions\n  ruleAction = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"](finalMemoryNode, actionDescriptions, boundActionDescriptions, rule.name, this); //Add the bound actions into the action node:\n\n\n  ruleAction.ruleId = rule.id;\n  ruleAction.boundActions = boundActionDescriptions;\n  this.actions[ruleAction.ruleId] = ruleAction;\n  this.allRules[ruleAction.ruleId] = rule;\n  return [this, ruleAction];\n};\n/**\n   Remove rule(s) from the retenet, bottom up from {@link:module.ReteDataStructures.ActionNode}\n   @param {module:ReteDataStructures.ActionNode | Array} rule The rule(s) to remove from the net\n   @method\n*/\n\n\nReteNet.prototype.removeRule = function (rule) {\n  var _this5 = this;\n\n  this.fireListener("removeRule", rule);\n\n  if (rule instanceof Array) {\n    rule.forEach(function (d) {\n      return _this5.removeRule(d);\n    });\n    return;\n  } //delete from bottom up\n\n\n  var action = rule instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["ActionNode"] ? rule : this.actions[rule.id],\n      invalidatedActions = _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["deleteNodeAndAnyUnusedAncestors"](action);\n  _ReteUtilities__WEBPACK_IMPORTED_MODULE_4__["cleanupInvalidatedActions"](invalidatedActions); //delete from the allrules record\n\n  if (this.allRules[action.ruleId] !== undefined) {\n    delete this.allRules[action.ruleId];\n  } //Remove all nodes scheduled for cleanup\n\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.allReteNodes).forEach(function (d) {\n    if (this.allReteNodes[d].cleanup === true) {\n      var currNode = this.allReteNodes[d];\n      delete this.allReteNodesByType[currNode.type][currNode.id];\n      delete this.allReteNodes[d];\n    }\n  }, this);\n\n  if (this.actions[rule.id] !== undefined) {\n    delete this.actions[rule.id];\n  }\n};\n/**\n   register a join action proposal and performance function\n   @param {{name : string, propose : function, perform : function}} actionObj\n   @method\n   @see module:ReteActions\n*/\n\n\nReteNet.prototype.registerAction = function (actionObj) {\n  this.fireListener(\'registerAction\', actionObj);\n\n  if (actionObj.name === undefined || actionObj.perform === undefined || actionObj.propose === undefined) {\n    throw new Error("Action Registration Failure");\n  }\n\n  if (this.actionFunctions[actionObj.name] !== undefined) {\n    throw new Error("Registration Attempt for existing Action");\n  }\n\n  this.actionFunctions[actionObj.name] = actionObj;\n};\n/**\n   Store a node in the appropriate members of the ReteNet\n   @param {module:ReteDataStructures.ReteNode} node\n   @method\n   @private\n*/\n\n\nReteNet.prototype.storeNode = function (node) {\n  this.allReteNodes[node.id] = node;\n\n  if (this.allReteNodesByType[node.type] === undefined) {\n    this.allReteNodesByType[node.type] = {};\n  }\n\n  this.allReteNodesByType[node.type][node.id] = node;\n};\n/**\n   Converts rules to an object of their components for easy addition\n   @param {module:RuleCtors.Rule | Array} rules\n   @method\n   @return {Object}\n*/\n\n\nReteNet.prototype.convertRulesToComponents = function (rules) {\n  if (!(rules instanceof Array)) {\n    rules = [rules];\n  }\n\n  var actions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(rules.map(function (d) {\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(d.actions);\n  })),\n      conditions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.flatten(rules.map(function (d) {\n    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(d.conditions);\n  })),\n      all = actions.concat(conditions).concat(rules),\n      components = all.reduce(function (m, v) {\n    m[v.id] = v;\n    return m;\n  }, {}); //convert to linkednode style for every component:\n\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(components).forEach(function (d) {\n    d.linkedNodes = {}; //add actions\n\n    d.linkedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(d.actions).reduce(function (m, v) {\n      m[v] = "action";\n      return m;\n    }, d.linkedNodes); //add conditions\n\n    d.linkedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(d.conditions).reduce(function (m, v) {\n      m[v] = \'condition\';\n      return m;\n    }, d.linkedNodes);\n  });\n\n  return components;\n};\n/**\n   Clean up\n*/\n\n\nReteNet.prototype.cleanup = function () {\n  var _this6 = this;\n\n  //retract all wmes\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.allWMEs).forEach(function (d) {\n    return _this6.retractWME(d);\n  });\n\n  this.allWMEs = {}; //remove all rules\n\n  this.removeRule(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(this.allRules));\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (ReteNet);\n\n//# sourceURL=webpack://Rete/./ReteClassInterface.js?')},"./ReteComparisonOperators.js":
/*!************************************!*\
  !*** ./ReteComparisonOperators.js ***!
  \************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/**\n   To define the possible operators available for constant test nodes\n   @module ReteComparisonOperators\n*/\n//Define an object of comparisons able to\n//be used in constant tests\n//See general utils file for converting to string\n//TODO: These can be changed to their actual representations, similar to reteArithActions\nvar ConstantTestOperators = {\n  "EQ": function EQ(a, b) {\n    return a === b;\n  },\n  "LT": function LT(a, b) {\n    return a < b;\n  },\n  "GT": function GT(a, b) {\n    return a > b;\n  },\n  "LTE": function LTE(a, b) {\n    return a <= b;\n  },\n  "GTE": function GTE(a, b) {\n    return a >= b;\n  },\n  "NE": function NE(a, b) {\n    return a !== b;\n  },\n  "MATCH": function MATCH(a, b) {\n    var regex = new RegExp(b);\n    return regex.test(a);\n  }\n};\nConstantTestOperators[\'===\'] = ConstantTestOperators.EQ;\nConstantTestOperators[\'<\'] = ConstantTestOperators.LT;\nConstantTestOperators[\'>\'] = ConstantTestOperators.GT;\nConstantTestOperators[\'<=\'] = ConstantTestOperators.LTE;\nConstantTestOperators[\'>=\'] = ConstantTestOperators.GTE;\nConstantTestOperators[\'!==\'] = ConstantTestOperators.NE;\nConstantTestOperators[\'~=\'] = ConstantTestOperators.MATCH;\n/* harmony default export */ __webpack_exports__["default"] = (ConstantTestOperators);\n\n//# sourceURL=webpack://Rete/./ReteComparisonOperators.js?')},"./ReteDataStructures.js":
/*!*******************************!*\
  !*** ./ReteDataStructures.js ***!
  \*******************************/
/*! exports provided: WME, Token, AlphaMemory, AlphaMemoryItem, AlphaNode, ReteNode, BetaMemory, JoinNode, NegativeJoinResult, NegativeNode, NCCNode, NCCPartnerNode, ActionNode, ProposedAction */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WME", function() { return WME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaMemory", function() { return AlphaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaMemoryItem", function() { return AlphaMemoryItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaNode", function() { return AlphaNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReteNode", function() { return ReteNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BetaMemory", function() { return BetaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JoinNode", function() { return JoinNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NegativeJoinResult", function() { return NegativeJoinResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NegativeNode", function() { return NegativeNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NCCNode", function() { return NCCNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NCCPartnerNode", function() { return NCCPartnerNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionNode", function() { return ActionNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProposedAction", function() { return ProposedAction; });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n   Defines the data structures required for the Net\n   @module ReteDataStructures\n   @requires lodash\n*/\n\nvar nextId = 0;\n/**\n   Describes a queued, but not yet performed, action\n   @param reteNet\n   @param type\n   @param strId The \'name\' of the action, Rule.newAction(type,name...)\n   @param payload\n   @param token\n   @param proposeTime\n   @param timingObj\n   @param priority\n   @param tags\n   @class ProposedAction\n   queue/invalidate time absolute,\n   assertTime/retractTime relative to when action is enacted\n*/\n\nvar ProposedAction =\n/*#__PURE__*/\nfunction () {\n  function ProposedAction(reteNet, type, strId, payload, token, proposeTime, timingObj, priority, tags) {\n    _classCallCheck(this, ProposedAction);\n\n    this.id = nextId++;\n    this.actionStringIdentifier = strId;\n    this.type = "ProposedAction";\n    this.reteNet = reteNet;\n    this.actionType = type; //ie: "assert","retract","perform"...\n\n    this.payload = payload; //ie" : {a:3,b:4}...\n\n    this.token = token; //Source Token that spawned this action\n\n    this.timing = {\n      //when PA is created\n      proposeTime: proposeTime || 0,\n      //when it is invalidated and removed from the proposal set\n      invalidateTime: proposeTime + (timingObj ? timingObj.invalidateOffset : 0),\n      //When the happens after it is scheduled (currentTime + pOffset)\n      performOffset: timingObj ? timingObj.performOffset : 0,\n      //When the action is scheduled to reverse( currentTime+pOffset+upOffset)\n      unperformOffset: timingObj ? timingObj.unperformOffset : 0\n    };\n    this.priority = priority || 0;\n    this.tags = tags || {};\n    this.parallelActions = new Set(); //todo: possibly include metrics for selection of actions?\n    //todo: check for circular reference cleanup\n    //update Token:\n\n    if (this.token && this.token.proposedActions) {\n      this.token.proposedActions.push(this);\n    }\n  }\n\n  _createClass(ProposedAction, [{\n    key: "addParallelAction",\n    value: function addParallelAction(anActionId) {\n      if (anActionId !== this.id && this.parallelActions.indexOf(anActionId) === -1) {\n        this.parallelActions.add(anActionId);\n      }\n    }\n  }, {\n    key: "getParallelActions",\n    value: function getParallelActions() {\n      return Array.from(this.parallelActions);\n    }\n  }, {\n    key: "removeFromParentToken",\n    value: function removeFromParentToken() {\n      var _this = this;\n\n      if (this.token !== undefined && this.token !== null) {\n        this.token.proposedActions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reject(this.token.proposedActions, function (d) {\n          return d.id === _this.id;\n        });\n      }\n    }\n  }]);\n\n  return ProposedAction;\n}();\n/**\n   Stores facts in the rete net\n   @param data\n   @param assertTime\n   @class WME\n*/\n\n\nvar WME = function WME(data, assertTime) {\n  _classCallCheck(this, WME);\n\n  this.id = nextId++;\n  this.type = "WME";\n  this.data = data; //The lifetime of the wme. Asserted at time lifeTime[0],\n  //retracted at time lifeTime[1]:\n\n  if (assertTime === undefined) {\n    assertTime = 0;\n  }\n\n  this.lifeTime = [assertTime]; //Alpha memories the wme is part of\n\n  this.alphaMemoryItems = []; //Tokens the wme is part of\n\n  this.tokens = []; //Tokens this wme is blocking\n\n  this.negJoinResults = [];\n};\n/**\n   Represents intermediate results in the beta network\n   @param parentToken\n   @param wme\n   @param owningNode\n   @param bindings\n   @class Token\n*/\n\n\nvar Token = function Token(parentToken, wme, owningNode, bindings) {\n  _classCallCheck(this, Token);\n\n  this.id = nextId++;\n  this.type = "Token"; //bindings are updated as the token progresses\n\n  this.parentToken = parentToken; //ie:owner\n\n  this.wme = wme;\n  this.owningNode = owningNode;\n  this.children = []; //list of tokens\n\n  this.negJoinResults = []; //list of blocking NegativeJoinResults\n\n  this.nccResults = []; //list of blocking Tokens\n\n  this.proposedActions = []; //current proposed actions\n\n  if (this.parentToken) {\n    this.parentToken.children.unshift(this);\n  }\n\n  if (this.wme && this.wme.tokens) {\n    this.wme.tokens.unshift(this);\n  } //copy over bindings from parent,\n  //then copy in new bindings\n\n\n  this.bindings = {};\n\n  if (this.parentToken && this.parentToken.bindings) {\n    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(this.parentToken.bindings).forEach(function (d) {\n      this.bindings[d] = this.parentToken.bindings[d];\n    }, this);\n  }\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(bindings).forEach(function (d) {\n    this.bindings[d] = bindings[d];\n  }, this);\n}; //------------------------------\n\n/**\n   A Pairing of a wme with an alpha memory it resides in\n   @param wme\n   @param alphaMem\n   @class AlphaMemoryItem\n*/\n//Utility storage of wme and its alphaMemory together\n//used in alphamemory and WME\n\n\nvar AlphaMemoryItem = function AlphaMemoryItem(wme, alphaMem) {\n  _classCallCheck(this, AlphaMemoryItem);\n\n  this.id = nextId++;\n  this.type = "AlphaMemoryItem";\n  this.wme = wme;\n  this.alphaMemory = alphaMem;\n};\n/**\n   A node to perform constant tests on newly asserted WMEs\n   constantTest = {field: string, value: string ,operator: string};\n   @param parent\n   @param constantTestSpec\n   @class AlphaNode\n*/\n\n\nvar AlphaNode = function AlphaNode(parent, constantTestSpec) {\n  _classCallCheck(this, AlphaNode);\n\n  this.id = nextId++;\n  this.type = "AlphaNode";\n  this.parent = parent;\n\n  if (this.parent && this.parent.children) {\n    this.parent.children.unshift(this);\n  }\n\n  this.children = [];\n  this.outputMemory = undefined;\n\n  if (constantTestSpec) {\n    this.testField = constantTestSpec.field;\n    this.testValue = constantTestSpec.value;\n    this.operator = constantTestSpec.operator;\n  } else {\n    this.passThrough = true;\n  }\n};\n/**\n   To store wmes that have passed through constant tests\n   @param parent\n   @class AlphaMemory\n*/\n\n\nvar AlphaMemory = function AlphaMemory(parent) {\n  _classCallCheck(this, AlphaMemory);\n\n  this.id = nextId++;\n  this.type = "AlphaMemory";\n  this.items = [];\n  this.parent = parent; //If adding to a node other than a test node,\n\n  if (this.parent && !(this.parent instanceof AlphaNode)) {\n    //add to children\n    throw new Error("Adding alpha memory as child of not a test");\n  } else if (this.parent && this.parent instanceof AlphaNode && this.parent.outputMemory === undefined) {\n    //if an alphanode, set the ouputmemory field\n    this.parent.outputMemory = this;\n  } else {\n    throw new Error("trying to create an alpha memory for a node that already has one");\n  }\n\n  this.children = [];\n  this.unlinkedChildren = [];\n  this.referenceCount = 0;\n};\n/**\n   Provides a base definition of a node in the rete network\n   @class ReteNode\n\n*/\n//Base node for the beta network\n\n\nvar ReteNode = function ReteNode(parent) {\n  _classCallCheck(this, ReteNode);\n\n  this.id = nextId++;\n  this.type = "ReteNode";\n  this.children = [];\n  this.unlinkedChildren = [];\n  this.parent = parent;\n\n  if (this.parent && this.parent.children) {\n    this.parent.children.unshift(this);\n  }\n};\n/**\n   A Node to store tokens in the rete network\n   @param parent\n   @class BetaMemory\n   @augments ReteNode\n*/\n\n\nvar BetaMemory =\n/*#__PURE__*/\nfunction (_ReteNode) {\n  _inherits(BetaMemory, _ReteNode);\n\n  function BetaMemory(parent) {\n    var _this2;\n\n    _classCallCheck(this, BetaMemory);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BetaMemory).call(this, parent));\n    _this2.type = "BetaMemory";\n    _this2.items = [];\n\n    if (parent === undefined) {\n      _this2.dummy = true;\n\n      _this2.items.push(new Token());\n\n      _this2.items[0].owningNode = _assertThisInitialized(_assertThisInitialized(_this2));\n    }\n\n    return _this2;\n  }\n\n  return BetaMemory;\n}(ReteNode);\n/**\n   To combine tokens and wmes, according to binding tests\n   @class JoinNode\n   @augments ReteNode\n*/\n\n\nvar JoinNode =\n/*#__PURE__*/\nfunction (_ReteNode2) {\n  _inherits(JoinNode, _ReteNode2);\n\n  function JoinNode(parent, alphaMemory, tests) {\n    var _this3;\n\n    _classCallCheck(this, JoinNode);\n\n    //Join Node combines tokens with wmes\n    //tests are the binding tuples from a condition\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(JoinNode).call(this, parent));\n    _this3.type = "JoinNode";\n    _this3.alphaMemory = alphaMemory;\n\n    if (tests) {\n      _this3.tests = tests;\n    } else {\n      _this3.tests = [];\n    }\n\n    if (_this3.alphaMemory && _this3.alphaMemory.children) {\n      _this3.alphaMemory.children.unshift(_assertThisInitialized(_assertThisInitialized(_this3)));\n\n      _this3.alphaMemory.referenceCount += 1;\n    }\n\n    _this3.nearestAncestor = null;\n    _this3.items = [];\n    return _this3;\n  }\n\n  return JoinNode;\n}(ReteNode);\n/**\n   A Node which, when activated, will cause the effects a rule describes\n   @param parent\n   @param actionDescriptions\n   @param boundActions\n   @param ruleName\n   @param reteNet\n   @augments ReteNode\n   @class ActionNode\n*/\n\n\nvar ActionNode =\n/*#__PURE__*/\nfunction (_ReteNode3) {\n  _inherits(ActionNode, _ReteNode3);\n\n  function ActionNode(parent, actionDescriptions, boundActions, ruleName, reteNet) {\n    var _this4;\n\n    _classCallCheck(this, ActionNode);\n\n    //Container object for a general graphnode action description\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ActionNode).call(this, parent));\n    _this4.type = "ActionNode";\n    _this4.name = ruleName;\n    _this4.actionDescriptions = actionDescriptions; //All of the effects this action node triggers together:\n\n    _this4.boundActions = boundActions; //reference to retenet, to allow storage of results of firing:\n\n    _this4.reteNet = reteNet;\n    return _this4;\n  }\n\n  return ActionNode;\n}(ReteNode);\n/**\n   To Store the combination of a token and a wme that blocks it from progressing through the network\n   @param owner the token\n   @param wme the wme\n   @class NegativeJoinResult\n*/\n\n\nvar NegativeJoinResult = function NegativeJoinResult(owner, wme) {\n  _classCallCheck(this, NegativeJoinResult);\n\n  //Storage for a token blocked by a wme\n  //Updates the owner token and wme as part of its construction\n  this.id = nextId++;\n  this.type = "Negative Join Result";\n  this.owner = owner;\n\n  if (this.owner) {\n    this.owner.negJoinResults.unshift(this);\n  }\n\n  this.wme = wme;\n\n  if (this.wme) {\n    this.wme.negJoinResults.unshift(this);\n  }\n};\n/**\n   A Node that tests for the abscence of particular wmes\n   @param parent\n   @param alphaMemory\n   @param tests\n   @class NegativeNode\n   @augments ReteNode\n*/\n\n\nvar NegativeNode =\n/*#__PURE__*/\nfunction (_ReteNode4) {\n  _inherits(NegativeNode, _ReteNode4);\n\n  function NegativeNode(parent, alphaMemory, tests) {\n    var _this5;\n\n    _classCallCheck(this, NegativeNode);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(NegativeNode).call(this, parent));\n    _this5.type = "Negative Node";\n    _this5.items = [];\n    _this5.alphaMemory = alphaMemory;\n\n    if (_this5.alphaMemory) {\n      _this5.alphaMemory.referenceCount++;\n\n      _this5.alphaMemory.children.unshift(_assertThisInitialized(_assertThisInitialized(_this5)));\n    }\n\n    _this5.tests = tests || [];\n    _this5.nearestAncestor = null;\n    return _this5;\n  }\n\n  return NegativeNode;\n}(ReteNode);\n/**\n   The generalisation of the negative node to multiple conditions, forms the leaf of a subnetwork\n   @param parent\n   @class NCCNode\n   @augments ReteNode\n   @see {@link NCCondition}\n*/\n\n\nvar NCCNode =\n/*#__PURE__*/\nfunction (_ReteNode5) {\n  _inherits(NCCNode, _ReteNode5);\n\n  function NCCNode(parent) {\n    var _this6;\n\n    _classCallCheck(this, NCCNode);\n\n    //NCC : gates token progression based on a subnetwork\n    //don\'t pass parent in so you can PUSH instead of SHIFT\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(NCCNode).call(this));\n    _this6.type = "NCCNode";\n    _this6.parent = parent;\n\n    if (_this6.parent && _this6.parent.children) {\n      _this6.parent.children.push(_assertThisInitialized(_assertThisInitialized(_this6)));\n    }\n    /**\n       @type {Array.<RDS.Token>}\n    */\n\n\n    _this6.items = [];\n    _this6.partner = null;\n    return _this6;\n  }\n\n  return NCCNode;\n}(ReteNode);\n/**\n   To store potential partial matches in the subnetwork for a NCCNode.\n   @param parent\n   @param num\n   @class NCCPartnerNode\n*/\n\n\nvar NCCPartnerNode =\n/*#__PURE__*/\nfunction (_ReteNode6) {\n  _inherits(NCCPartnerNode, _ReteNode6);\n\n  function NCCPartnerNode(parent, num) {\n    var _this7;\n\n    _classCallCheck(this, NCCPartnerNode);\n\n    //get the parent if parent is a beta memory to stop redundant node usage\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(NCCPartnerNode).call(this, parent));\n    _this7.type = "NCCPartnerNode";\n    _this7.nccNode = null;\n    _this7.numberOfConjuncts = num;\n    _this7.newResultBuffer = [];\n    return _this7;\n  }\n\n  return NCCPartnerNode;\n}(ReteNode); //--------------------\n\n\n\n\n//# sourceURL=webpack://Rete/./ReteDataStructures.js?')},"./ReteNetworkBuilding.js":
/*!********************************!*\
  !*** ./ReteNetworkBuilding.js ***!
  \********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\n/* harmony import */ var _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReteActivationAndDeletion */ "./ReteActivationAndDeletion.js");\n/**\n   Functions to create the actual Alpha and Beta Networks of the ReteNet\n   @module ReteNetworkBuilding\n   @requires ReteDataStructures\n   @requires ReteUtilities\n   @requires ReteActivationAndDeletion\n   @requires lodash\n*/\n\n\n\n\n/**\n   To add all given conditions to the network\n   @param parent\n   @param conditions\n   @param rootAlpha\n   @param allNodes\n   @param reteNet\n   @function buildOrShareNetworkForConditions\n\n*/\n\nvar buildOrShareNetworkForConditions = function buildOrShareNetworkForConditions(parent, conditions, rootAlpha, allNodes, reteNet) {\n  var currentNode = parent,\n      alphaMemory; //for each condition\n\n  conditions.forEach(function (condition) {\n    if (condition.tags.type !== \'rule\' && condition.tags.type !== \'condition\') {\n      throw new Error("trying to add something that isnt a condition");\n    }\n\n    if (condition.tags.type === \'condition\' && condition.tags.conditionType === undefined) {\n      throw new Error("Trying to add a condition without a conditionType");\n    } //get the binding tests for join nodes\n\n\n    var tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.bindings);\n\n    if (condition.tags.conditionType === \'positive\') {\n      //Build a positive condition:\n      //currentNode = buildOrShareBetaMemoryNode(currentNode,reteNet);\n      alphaMemory = buildOrShareAlphaMemory(condition, rootAlpha, allNodes, reteNet);\n      currentNode = buildOrShareJoinNode(currentNode, alphaMemory, tests, reteNet);\n    } else if (condition.tags.conditionType === \'negative\') {\n      //Build a negative condition:\n      alphaMemory = buildOrShareAlphaMemory(condition, rootAlpha, allNodes, reteNet);\n      currentNode = buildOrShareNegativeNode(currentNode, alphaMemory, tests, reteNet);\n    } else if (condition.tags.conditionType === \'negConjCondition\') {\n      //Build a Negated Conjunctive Condition\n      currentNode = buildOrShareNCCNodes(currentNode, condition, rootAlpha, allNodes, reteNet);\n    } else if (condition.tags.type === \'rule\') {\n      //for using other rules as composable conditions\n      var ruleConditions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.linkedNodes).filter(function (d) {\n        return /^condition/.test(d[1]);\n      }).map(function (d) {\n        return allNodes[d[0]];\n      });\n\n      currentNode = buildOrShareNetworkForConditions(currentNode, ruleConditions, rootAlpha, allNodes, reteNet);\n    } else {\n      console.error("Problematic Condition:", condition);\n      throw new Error("Unrecognised condition type");\n    }\n  }); //build a final memory node if current isn\'t one\n\n  return buildOrShareBetaMemoryNode(currentNode, reteNet);\n};\n/**\n   Reuse, or create a new, constant test node, for the given test\n   @param parent\n   @param constantTestSped\n   @param reteNet\n   @function buildOrShareConstantTestNode\n*/\n\n\nvar buildOrShareConstantTestNode = function buildOrShareConstantTestNode(parent, constantTestSpec, reteNet) {\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\n\n  for (var i = 0; i < children.length; i++) {\n    var node = children[i];\n\n    if (_ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareConstantNodeToTest"](node, constantTestSpec)) {\n      return node;\n    }\n  } //No existing, create a new node:\n\n\n  var newAlphaNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaNode"](parent, constantTestSpec);\n  reteNet.storeNode(newAlphaNode);\n  return newAlphaNode;\n};\n/**\n   Create alpha network as necessary, stick an alpha memory on the end\n   @param condition\n   @param root\n   @param allNodes\n   @param reteNet\n   @function buildOrShareAlphaMemory\n*/\n\n\nvar buildOrShareAlphaMemory = function buildOrShareAlphaMemory(condition, root, allNodes, reteNet) {\n  //Rule{Conditions[]}, Condition{constantTests:[],bindings:[[]]}\n  var currentNode = root,\n      constantTests = condition.constantTests; //[{field:,op:,value:}]\n\n  currentNode = constantTests.reduce(function (m, v) {\n    return buildOrShareConstantTestNode(m, v, reteNet);\n  }, currentNode); //see if there is an existing memory for this condition.\n  //if so, return existing alphamemory\n\n  if (currentNode.outputMemory !== undefined) {\n    return currentNode.outputMemory;\n  } //else: create the alpha memory\n  //ctor will update the current node\'s outputMemory field\n\n\n  var newAlphaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["AlphaMemory"](currentNode); //run wmes in working memory against the alpha network\n\n  reteNet.storeNode(newAlphaMemory);\n  return newAlphaMemory;\n};\n/**\n   Given a node (ie: join), stick a betamemory on it as a child\n   @param parent\n   @param reteNet\n   @function buildOrShareBetaMemoryNode\n*/\n\n\nvar buildOrShareBetaMemoryNode = function buildOrShareBetaMemoryNode(parent, reteNet) {\n  //if passed in the dummy top node, OR any sort of memory node,\n  //be it NCC,Negative,NCCPartner\n  if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] || parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n    return parent;\n  } //if theres an available beta memory to use,\n  //return that\n\n\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\n      return child;\n    }\n  } //else: create a new beta memory\n  //ctor should update  parent\'s children\n\n\n  var newBetaMemory = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"](parent); //update it with matches\n\n  updateNewNodeWithMatchesFromAbove(newBetaMemory);\n  reteNet.storeNode(newBetaMemory); //return new beta memory\n\n  return newBetaMemory;\n};\n/**\n   To reuse, or create a new, join node linking an alpha memory and betamemory\n   @param parent\n   @param alphaMemory\n   @param tests\n   @param reteNet\n   @function buildOrShareJoinNode\n*/\n\n\nvar buildOrShareJoinNode = function buildOrShareJoinNode(parent, alphaMemory, tests, reteNet) {\n  //convert tests if necessary:\n  if (!(tests instanceof Array)) {\n    tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(tests);\n  } //see if theres a join node to use already\n\n\n  var allChildren = parent.children.concat(parent.unlinkedChildren);\n\n  for (var i = 0; i < allChildren.length; i++) {\n    var child = allChildren[i];\n\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] && child.alphaMemory && child.alphaMemory.id === alphaMemory.id && _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareJoinTests"](child.tests, tests)) {\n      //return it\n      return child;\n    }\n  } //else: create a new join node\n  //increment alphamemories reference count in the constructor\n\n\n  var newJoinNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"](parent, alphaMemory, tests); //set the nearest ancestor\n\n  newJoinNode.nearestAncestor = _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["findNearestAncestorWithAlphaMemory"](parent, alphaMemory); //if either parent memory is empty, unlink\n\n  if (parent.items.length === 0) {\n    //BETA IS EMPTY: UNLINK RIGHT\n    var index = alphaMemory.children.map(function (d) {\n      return d.id;\n    }).indexOf(newJoinNode.id),\n        removed = alphaMemory.children.splice(index, 1);\n    alphaMemory.unlinkedChildren.unshift(removed[0]);\n  } else if (alphaMemory.items.length === 0) {\n    //ALPHA IS EMPTY: UNLINK LEFT\n    var newNodeIndex = parent.children.map(function (d) {\n      return d.id;\n    }).indexOf(newJoinNode.id),\n        removedNode = parent.children.splice(newNodeIndex, 1);\n    parent.unlinkedChildren.unshift(removedNode[0]);\n  } //return new join node\n\n\n  reteNet.storeNode(newJoinNode);\n  return newJoinNode;\n};\n/**\n   To reuse, or build a new, negative node\n   @param parent\n   @param alphaMemory\n   @param tests\n   @param reteNet\n   @function buildOrShareNegativeNode\n*/\n\n\nvar buildOrShareNegativeNode = function buildOrShareNegativeNode(parent, alphaMemory, tests, reteNet) {\n  if (!(tests instanceof Array)) {\n    tests = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(tests);\n  } //see if theres an existing negative node to use\n\n\n  var children = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.children);\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"] && child.alphaMemory && child.alphaMemory.id === alphaMemory.id && _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["compareJoinTests"](child.tests, tests)) {\n      return child;\n    }\n  }\n\n  var newNegativeNode = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"](parent, alphaMemory, tests);\n  newNegativeNode.nearestAncestor = _ReteUtilities__WEBPACK_IMPORTED_MODULE_2__["findNearestAncestorWithAlphaMemory"](parent, alphaMemory); //update with matches\n\n  updateNewNodeWithMatchesFromAbove(newNegativeNode); //unlink if it has no tokens\n\n  if (newNegativeNode.items.length === 0) {\n    var index = alphaMemory.children.map(function (d) {\n      return d.id;\n    }).indexOf(newNegativeNode.id),\n        removed = alphaMemory.children.splice(index, 1);\n    alphaMemory.unlinkedChildren.push(removed[0]);\n  } //return new negative node\n\n\n  reteNet.storeNode(newNegativeNode);\n  return newNegativeNode;\n};\n/**\n   Construction of NCCConditions\n   @param parent\n   @param condition\n   @param rootAlpha\n   @param allNodes\n   @param reteNet\n   @function buildOrShareNCCNodes\n\n*/\n\n\nvar buildOrShareNCCNodes = function buildOrShareNCCNodes(parent, condition, rootAlpha, allNodes, reteNet) {\n  if (condition.tags.conditionType !== \'negConjCondition\') {\n    throw new Error("BuildOrShareNCCNodes only takes NCCCondition");\n  } //build a network for the conditions\n\n\n  var conditionIdPairs = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.toPairs(condition.linkedNodes).filter(function (d) {\n    return /condition/.test(d[1]);\n  }),\n      conditions = conditionIdPairs.map(function (d) {\n    return allNodes[d[0]];\n  }),\n      //build the subnetwork\n  bottomOfSubNetwork = buildOrShareNetworkForConditions(parent, conditions, rootAlpha, allNodes, reteNet); //find an existing NCCNode with partner to use\n\n\n  for (var i = 0; i < parent.children.length; i++) {\n    var child = parent.children[i];\n\n    if (child instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"] && child.partner.parent && child.partner.parent.id === bottomOfSubNetwork.id) {\n      return child;\n    }\n  } //else: build NCC and Partner nodes\n\n\n  var newNCC = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"](parent),\n      newNCCPartner = new _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCPartnerNode"](bottomOfSubNetwork, conditionIdPairs.length);\n  newNCC.partner = newNCCPartner;\n  newNCCPartner.nccNode = newNCC; //update NCC\n\n  updateNewNodeWithMatchesFromAbove(newNCC); //update partner\n\n  updateNewNodeWithMatchesFromAbove(newNCCPartner);\n  reteNet.storeNode(newNCC);\n  reteNet.storeNode(newNCCPartner);\n  return newNCC;\n};\n/**\n   Pulls tokens down from parent upon new creation\n   @note Possible race conditions?\n   @param newNode\n   @function updateNewNodeWithMatchesFromAbove\n*/\n\n\nvar updateNewNodeWithMatchesFromAbove = function updateNewNodeWithMatchesFromAbove(newNode) {\n  //essentially a 4 state switch:\n  //betaMemory, joinNode, negativeNode, NCC\n  var parent = newNode.parent;\n\n  if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"]) {\n    for (var i = 0; i < parent.items.length; i++) {\n      _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, parent.items[i]);\n    }\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n    var savedChildren = parent.children,\n        items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.alphaMemory.items);\n\n    parent.children = [newNode];\n\n    for (var _i = 0; _i < items.length; _i++) {\n      var item = items[_i];\n      _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["rightActivate"](parent, item.wme);\n    }\n\n    parent.children = savedChildren;\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\n    var _items = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.items);\n\n    for (var _i2 = 0; _i2 < _items.length; _i2++) {\n      var token = _items[_i2];\n\n      if (token.negJoinResults.length === 0) {\n        _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, token);\n      }\n    }\n  } else if (parent instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\n    var _items2 = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.values(parent.items);\n\n    for (var _i3 = 0; _i3 < _items2.length; _i3++) {\n      var _token = parent.items[_i3];\n\n      if (_token.nccResults.length === 0) {\n        _ReteActivationAndDeletion__WEBPACK_IMPORTED_MODULE_3__["leftActivate"](newNode, _token);\n      }\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (buildOrShareNetworkForConditions);\n\n//# sourceURL=webpack://Rete/./ReteNetworkBuilding.js?')},"./ReteTestExecution.js":
/*!******************************!*\
  !*** ./ReteTestExecution.js ***!
  \******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteUtilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteUtilities */ "./ReteUtilities.js");\n/* harmony import */ var _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteComparisonOperators */ "./ReteComparisonOperators.js");\n/**\n   @module ReteTestExecution\n   @requires ReteDataStructures\n   @requires lodash\n   @requires ReteUtilities\n   @requires ReteComparisonOperators\n*/\n\n\n\n/**\n   Compare a token and wme, using defined bindings from a joinNode\n   @param joinNode\n   @param token\n   @param wme\n   @function performJoinTests\n   @returns {False | Object}\n*/\n\nvar performJoinTests = function performJoinTests(joinNode, token, wme) {\n  //returns False if no match, dict of all updated bindings otherwise\n  var newBindings = {},\n      successState = true,\n      varRegex = new RegExp(/^\\${(\\w+)}/); //Populate with current bindings from token\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(token.bindings).forEach(function (key) {\n    newBindings[key] = token.bindings[key];\n  });\n\n  try {\n    //add new bindings:\n    joinNode.tests.forEach(function (test) {\n      var newValue = null; //retrieve the value\n\n      if (/^[#$]id$/.test(test[1][0])) {\n        newValue = wme.id;\n      } else {\n        newValue = _ReteUtilities__WEBPACK_IMPORTED_MODULE_1__["retrieveWMEValueFromDotString"](wme, test[1][0]);\n      } //compare the value for each specified binding test\n\n\n      var bindingComparisons = test[1][1]; //Compare using any defined binding tests\n\n      bindingComparisons.forEach(function (d) {\n        var comparator = _ReteComparisonOperators__WEBPACK_IMPORTED_MODULE_2__["default"][d[0]],\n            varName = d[1],\n            match = varRegex.exec(varName); //if it fails, fail the test\n        //use the value in the test, minus the $ at the beginning:\n\n        if (match === null) {\n          throw new Error("No bound let name");\n        } //if (!varRegex.test(varName)) { throw new Error("Non-bound let name"); }\n\n\n        if (!comparator(newValue, newBindings[match[1]])) {\n          throw new Error("Test failed");\n        }\n      });\n\n      if (newBindings[test[0]] === undefined) {\n        newBindings[test[0]] = newValue;\n      }\n\n      if (newBindings[test[0]] !== newValue) {\n        throw new Error("Test failed");\n      }\n    });\n\n    if (successState) {\n      return newBindings;\n    }\n\n    throw new Error("Test failed");\n  } catch (e) {\n    return false;\n  }\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (performJoinTests);\n\n//# sourceURL=webpack://Rete/./ReteTestExecution.js?')},"./ReteUtilities.js":
/*!**************************!*\
  !*** ./ReteUtilities.js ***!
  \**************************/
/*! exports provided: unlinkAlphaMemory, relinkToAlphaMemory, ifEmptyBetaMemoryUnlink, ifEmptyNegNodeUnlink, relinkToBetaMemory, compareJoinTests, compareConstantNodeToTest, findNearestAncestorWithAlphaMemory, retrieveWMEValueFromDotString, cleanupInvalidatedActions, objDescToObject, createNewWMEData, applyArithmetic, applyRegex */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlinkAlphaMemory", function() { return unlinkAlphaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relinkToAlphaMemory", function() { return relinkToAlphaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifEmptyBetaMemoryUnlink", function() { return ifEmptyBetaMemoryUnlink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifEmptyNegNodeUnlink", function() { return ifEmptyNegNodeUnlink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relinkToBetaMemory", function() { return relinkToBetaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareJoinTests", function() { return compareJoinTests; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareConstantNodeToTest", function() { return compareConstantNodeToTest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNearestAncestorWithAlphaMemory", function() { return findNearestAncestorWithAlphaMemory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "retrieveWMEValueFromDotString", function() { return retrieveWMEValueFromDotString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanupInvalidatedActions", function() { return cleanupInvalidatedActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objDescToObject", function() { return objDescToObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNewWMEData", function() { return createNewWMEData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyArithmetic", function() { return applyArithmetic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyRegex", function() { return applyRegex; });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReteDataStructures */ "./ReteDataStructures.js");\n/* harmony import */ var _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReteArithmeticActions */ "./ReteArithmeticActions.js");\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n   @module ReteUtilities\n   @requires lodash\n*/\n\n\n\n/**\n   Reconnects a joinnode with its alpha memory, once the beta memory is populated\n   @param node\n   @function relinkToAlphaMemory\n*/\n\nvar relinkToAlphaMemory = function relinkToAlphaMemory(node) {\n  //reconnect an unlinked join node to its alpha memory when there are\n  //wmes in said alpha memory\n  if (!(node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"])) {\n    throw new Error("trying to relink alpha on something other than a join node or negative node");\n  }\n\n  var ancestor = node.nearestAncestor,\n      indices = node.alphaMemory.children.map(function (d) {\n    return d.id;\n  }); //While the ancestor is a child of the alpha memory\n\n  while (ancestor && indices.indexOf(ancestor.id) === -1) {\n    //go up an ancestor if it is unlinked to\n    ancestor = findNearestAncestorWithAlphaMemory(ancestor, node.alphaMemory.id);\n  } //When finished, if the ancestor exists:\n\n\n  if (ancestor !== null) {\n    var index = node.alphaMemory.children.map(function (d) {\n      return d.id;\n    }).indexOf(ancestor.id); //add the node into the child list in front of the ancestor\n\n    node.alphaMemory.children.splice(index, 0, node);\n  } else {\n    //otherwise just add at the end\n    node.alphaMemory.children.push(node);\n  } //remove from the unlinkedChildren Field\n\n\n  var nodeIndex = node.alphaMemory.unlinkedChildren.map(function (d) {\n    return d.id;\n  }).indexOf(node.id);\n  node.alphaMemory.unlinkedChildren.splice(nodeIndex, 1);\n};\n/**\n   Reconnects a join node to its beta memory, once the alpha memory is populated\n   @param node\n   @function relinkToBetaMemory\n*/\n\n\nvar relinkToBetaMemory = function relinkToBetaMemory(node) {\n  //relink an unlinked join node to its betamemory when there are tokens\n  //in said memory\n  //remove from the unlinked children list\n  //and add it into the children\n  if (node.parent.unlinkedChildren.length === 0) {\n    return;\n  }\n\n  var index = node.parent.unlinkedChildren.map(function (d) {\n    return d.id;\n  }).indexOf(node.id);\n\n  if (index > -1) {\n    node.parent.unlinkedChildren.splice(index, 1);\n    node.parent.children.unshift(node);\n  }\n};\n/**\n   If an alpha memory becomes empty, displace all its children temporarily\n   @param alphaMemory\n   @function unlinkAlphaMemory\n*/\n\n\nvar unlinkAlphaMemory = function unlinkAlphaMemory(alphaMemory) {\n  //if the alphaMem has no items: UNLINK\n  if (alphaMemory.items.length === 0) {\n    alphaMemory.children.forEach(function (amChild) {\n      if (amChild instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"]) {\n        var index = amChild.parent.children.map(function (d) {\n          return d.id;\n        }).indexOf(amChild.id); //splice out\n\n        var removed = amChild.parent.children.splice(index, 1); //and store\n\n        amChild.parent.unlinkedChildren.push(removed[0]);\n      }\n    });\n  }\n};\n/**\n   If a beta memory becomes empty, displace all its children temporarily\n   @param node\n   @function ifEmptyBetaMemoryUnlink\n*/\n\n\nvar ifEmptyBetaMemoryUnlink = function ifEmptyBetaMemoryUnlink(node) {\n  //Now Essentially switch on: BetaMemory, NegativeNode,\n  //NCCNode, and NCCPartnerNode\n  //BETAMEMORY\n  if (node && (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["BetaMemory"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"])) {\n    //and that betaMemory has no other items\n    if (node.items.length === 0) {\n      //for all the node\'s children\n      node.children.forEach(function (jn) {\n        if (!(jn instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"])) {\n          return;\n        }\n\n        var index = jn.alphaMemory.children.map(function (d) {\n          return d.id;\n        }).indexOf(jn.id);\n\n        if (index !== -1) {\n          var removed = jn.alphaMemory.children.splice(index, 1); //push it in the unlinked children list\n\n          jn.alphaMemory.unlinkedChildren.push(removed[0]);\n        }\n      });\n    }\n\n    return true;\n  }\n\n  return false;\n};\n/**\n   If a negative node becomes empty, displace its alpha memory\'s children\n   @param node\n   @function ifEmptyNegNodeUnlink\n*/\n\n\nvar ifEmptyNegNodeUnlink = function ifEmptyNegNodeUnlink(node) {\n  if (node && node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\n    //with elements\n    if (node.items.length === 0) {\n      //unlink alpha memory\n      var index = node.alphaMemory.children.map(function (d) {\n        return d.id;\n      }).indexOf(node.id);\n      var removed = node.alphaMemory.children.splice(index, 1);\n      node.alphaMemory.unlinkedChildren.push(removed[0]);\n    }\n  }\n};\n/**\n   Compare an existing constant test node to a constant test that wants to be built\n   @param node\n   @param constantTestSpec\n   @function compareConstantNodeToTest\n*/\n//taking an alpha node and a ConstantTest\n\n\nvar compareConstantNodeToTest = function compareConstantNodeToTest(node, constantTestSpec) {\n  if (node.testField !== constantTestSpec.field || node.testValue !== constantTestSpec.value) {\n    return false;\n  }\n\n  if (node.operator !== constantTestSpec.operator) {\n    return false;\n  }\n\n  return true;\n};\n/**\n   Compare specified join tests, to see if a join node is the same as one needed\n   @param firstTestSet\n   @param secondTestSet\n   @function compareJoinTests\n*/\n\n\nvar compareJoinTests = function compareJoinTests(firstTestSet, secondTestSet) {\n  try {\n    //compare lengths\n    if (firstTestSet.length !== secondTestSet.length) {\n      throw "unequal lengths";\n    }\n\n    for (var i = 0; i < firstTestSet.length; i++) {\n      var fTest = firstTestSet[i],\n          sTest = secondTestSet[i]; //compare the bound names\n\n      if (fTest[0] !== sTest[0]) {\n        throw "different bound names";\n      } //compare the source names\n\n\n      if (fTest[1][0] !== sTest[1][0]) {\n        throw "different source names";\n      } //compare the bind tests\n\n\n      if (fTest[1][1].length !== sTest[1][1].length) {\n        throw "different binding tests length";\n      }\n\n      for (var j = 0; fTest[1][1].length; j++) {\n        if (fTest[1][1][j][0] !== sTest[1][1][j][0]) {\n          throw "different comp operator";\n        }\n\n        if (fTest[1][1][j][1] !== sTest[1][1][j][1]) {\n          throw "different comp value";\n        }\n      }\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n/**\n   To go up the network, to find appropriate beta network elements linked to the alphamemory\n   @param node\n   @param alphaMemory\n   @function findNearestAncestorWithAlphaMemory\n*/\n\n\nvar findNearestAncestorWithAlphaMemory = function findNearestAncestorWithAlphaMemory(node, alphaMemory) {\n  //recursive\n  //base conditions:\n  if (node.dummy) {\n    return null;\n  }\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["JoinNode"] || node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NegativeNode"]) {\n    if (node.alphaMemory.id === alphaMemory.id) {\n      return node;\n    }\n  } //switch recursion into the partner clause\n\n\n  if (node instanceof _ReteDataStructures__WEBPACK_IMPORTED_MODULE_1__["NCCNode"]) {\n    return findNearestAncestorWithAlphaMemory(node.partner.parent, alphaMemory);\n  } //recurse:\n\n\n  return findNearestAncestorWithAlphaMemory(node.parent, alphaMemory);\n}; //--------------------\n\n/**\n   Retrieves a value from an object based on a dot style strings\n   eg: "values.object.a" will get { values : { object { a : 5 } } }\n   @param wme\n   @param dotString\n   @function\n */\n\n\nvar retrieveWMEValueFromDotString = function retrieveWMEValueFromDotString(wme, dotString) {\n  //get from the node stored in wme.data the value\n  //that the dotString address specifies\n  var address = dotString.split("."),\n      currLocation = wme.data;\n\n  while (address.length > 0) {\n    var curr = address.shift();\n\n    if (currLocation[curr] !== undefined) {\n      currLocation = currLocation[curr];\n    } else {\n      return null;\n    }\n  } //return the final location arrived at\n\n\n  return currLocation;\n};\n/**\n   Remove proposed actions from the retenet, and from their owning tokens\n   @param invalidatedActions\n   @function\n*/\n\n\nvar cleanupInvalidatedActions = function cleanupInvalidatedActions(invalidatedActions) {\n  if (invalidatedActions.length === 0 || invalidatedActions[0].reteNet === undefined) {\n    return;\n  }\n\n  var reteNet = invalidatedActions[0].reteNet,\n      idList = invalidatedActions.map(function (d) {\n    return d.id;\n  }); //filter out the ids from the proposedActions list\n  //also removing them from the owning tokens\n\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forEach(idList, function (d) {\n    return reteNet.unproposeAction(d);\n  });\n};\n/**\n   Take a single object that describes a more complex object, and convert it to that more complex object\n   @param objDesc\n   @param baseObject\n   @function objDescToObject\n*/\n\n\nvar objDescToObject = function objDescToObject(objDesc, baseObject) {\n  /* can work on arbitrary depths, will overwrite primitives if later an object is needed\n     \n     ie: {"values.a" : 5, "values.b" : 10,\n     "tags.type" : "rule", "tags.character" : "bob"}\n     ---\x3e\n     {"values": {"a": 5, "b": 10},\n     "tags" : {"type" : "rule", "character": "bob"}}\n  */\n  var newObj = baseObject || {},\n      //take the starting object and for all keys\n  finalObj = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(objDesc).reduce(function (m, v) {\n    //split the keys apart\n    var keys = v.split(/\\./),\n        currObj = m,\n        currKey; //add an object for each key\n\n    while (keys.length > 1) {\n      currKey = keys.shift();\n\n      if (currObj[currKey] === undefined || _typeof(currObj[currKey]) !== \'object\') {\n        currObj[currKey] = {};\n      }\n\n      currObj = currObj[currKey];\n    }\n\n    currKey = keys.shift();\n    currObj[currKey] = objDesc[v];\n    return m;\n  }, newObj);\n\n  return finalObj;\n};\n/**\n   Create new wme data from an action description and a token\'s bindings\n   @param {Action} action\n   @param {Token} token\n */\n\n\nvar createNewWMEData = function createNewWMEData(action, token) {\n  //initialise from the action\'s \'values\' object\n  var newWMEData = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reduce(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.values), function (memo, key) {\n    var v = action.values[key]; //splice in bindings into the values\n\n    memo[key] = spliceInValues(v, token.bindings);\n    return memo;\n  }, {\n    bindings: {}\n  }),\n      //copy in the bindings\n  dataPlusBindings = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.reduce(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(token.bindings), function (m, v) {\n    m.bindings[v] = token.bindings[v];\n    return m;\n  }, newWMEData);\n\n  return dataPlusBindings;\n};\n/**\n   Apply arithmetic actions to a data object, in place\n   @param {Action} action\n   @param {Object} data\n */\n\n\nvar applyArithmetic = function applyArithmetic(action, data) {\n  //perform arithmetic:\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.arithmeticActions).forEach(function (key) {\n    var arithDesc = action.arithmeticActions[key],\n        currVal = Number(data[key]),\n        //look up the function:\n    //because the representation form is: a : ["+", 5]\n    arithFunc = _ReteArithmeticActions__WEBPACK_IMPORTED_MODULE_2__["default"][arithDesc[0]],\n        //Get the value if its a binding\n    applyVal = typeof arithDesc[1] === \'number\' ? arithDesc[1] : arithDesc[1].match(/\\$/) ? parseInt(data.bindings[arithDesc[1].slice(1)], 10) : parseInt(arithDesc[1], 10);\n\n    if (arithFunc === undefined) {\n      throw new Error("Undefined arithmetic function");\n    }\n\n    if (isNaN(currVal) || isNaN(applyVal)) {\n      throw new Error("Arithmetic value should be convertable to a number: " + currVal + " " + applyVal);\n    }\n\n    data[key] = arithFunc(currVal, applyVal);\n  });\n};\n/**\n   Apply an actions Regex transforms to some data, in place\n   @param {Action} action\n   @param {Object} data\n */\n\n\nvar applyRegex = function applyRegex(action, data) {\n  lodash__WEBPACK_IMPORTED_MODULE_0___default.a.keys(action.regexActions).forEach(function (key) {\n    var regexAction = action.regexActions[key],\n        regex = new RegExp(regexAction[0], regexAction[1]),\n        replaceValue = spliceInValues(regexAction[2], data.bindings);\n    data[key] = data[key].replace(regex, replaceValue);\n  });\n};\n/**\n   Repeatedly splice in values into a string\n   @param {String} baseString\n   @param {Object} valueObject\n */\n\n\nvar spliceInValues = function spliceInValues(baseString, valueObject) {\n  var match = /\\${(\\w+)}/g.exec(baseString);\n\n  while (match !== null) {\n    if (valueObject[match[1]] !== undefined) {\n      baseString = spliceStr(baseString, match.index, valueObject[match[1]], match[0].length);\n    } else {\n      throw new Error("Unrecognised binding: " + match[1]);\n    }\n\n    match = /\\${(\\w+)}/g.exec(baseString);\n  }\n\n  return baseString;\n};\n/**\n   Utility function to splice a string, from\n   http://stackoverflow.com/questions/20817618/is-there-a-splice-method-for-strings\n   @param {String} orig the original string\n   @param {Int} index the start point to splice from\n   @param {String} addition The string to splce in\n   @param {Int} cutLength The amount after the index to ignore before using the remaining string\n */\n\n\nvar spliceStr = function spliceStr(orig, index, addition, cutLength) {\n  return orig.slice(0, index) + addition + orig.slice(index + cutLength);\n}; //------------------------------\n\n\n\n\n//# sourceURL=webpack://Rete/./ReteUtilities.js?')},"./RuleCtors.js":
/*!**********************!*\
  !*** ./RuleCtors.js ***!
  \**********************/
/*! exports provided: Rule, Condition, Action */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rule", function() { return Rule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Condition", function() { return Condition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Action", function() { return Action; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n   Constructors for in-library creation of rules\n   @module RuleCtors\n*/\nvar nextId = 0;\n/**\n   Rule Ctor. Holds conditions and actions\n   @class\n*/\n\nvar Rule = function Rule(name) {\n  _classCallCheck(this, Rule);\n\n  this.id = nextId++;\n  this.name = name || "anon";\n  this.tags = {\n    type: "rule"\n  };\n  this.conditions = {};\n  this.actions = {};\n};\n/**\n   Creates a condition and adds it to the rule\n   @param type\n   @param testsAndBindings\n   @method\n   @returns this\n*/\n\n\nRule.prototype.newCondition = function (type, testsAndBindings) {\n  //testsAndBindings = { tests : [ [var,op,val]...], bindings : [ [var,val,[op,var]]] }\n  var newCondition = new Condition(type); //Add all tests\n\n  if (testsAndBindings.tests !== undefined) {\n    testsAndBindings.tests.forEach(function (d) {\n      return newCondition.addTest.apply(newCondition, _toConsumableArray(d));\n    });\n  }\n\n  if (testsAndBindings.bindings !== undefined) {\n    testsAndBindings.bindings.forEach(function (d) {\n      return newCondition.addBinding.apply(newCondition, _toConsumableArray(d));\n    });\n  }\n\n  this.addCondition(newCondition);\n  return this;\n};\n/**\n   Creates and adds an action to the rule\n   @param type\n   @param name\n   @param valuesArithRegexsAndTiming\n   @method\n   @returns this\n*/\n\n\nRule.prototype.newAction = function (type, name, valuesArithRegexsAndTiming) {\n  //valuesArithRegexsAndTiming = { values : [], arith : [], regexs : [], timing : [], priority : n}\n  var newAction = new Action(type, name);\n\n  if (valuesArithRegexsAndTiming.values !== undefined) {\n    valuesArithRegexsAndTiming.values.forEach(function (d) {\n      return newAction.addValue.apply(newAction, _toConsumableArray(d));\n    });\n  }\n\n  if (valuesArithRegexsAndTiming.arith !== undefined) {\n    valuesArithRegexsAndTiming.arith.forEach(function (d) {\n      return newAction.addArithmetic.apply(newAction, _toConsumableArray(d));\n    });\n  }\n\n  if (valuesArithRegexsAndTiming.regexs !== undefined) {\n    valuesArithRegexsAndTiming.regexs.forEach(function (d) {\n      return newAction.addRegex.apply(newAction, _toConsumableArray(d));\n    });\n  }\n\n  if (valuesArithRegexsAndTiming.priority !== undefined) {\n    newAction.priority = valuesArithRegexsAndTiming.priority;\n  }\n\n  if (valuesArithRegexsAndTiming.timing !== undefined) {\n    newAction.addTiming.apply(newAction, _toConsumableArray(valuesArithRegexsAndTiming.timing));\n  }\n\n  this.addAction(newAction);\n  return this;\n};\n\nRule.prototype.addCondition = function (condition) {\n  this.conditions[condition.id] = condition;\n  return this;\n};\n\nRule.prototype.addAction = function (action) {\n  this.actions[action.id] = action;\n  return this;\n};\n/**\n   Condition Ctor. Holds tests, bindings, and other conditions\n   @param type\n   @class\n*/\n\n\nvar Condition = function Condition(type) {\n  _classCallCheck(this, Condition);\n\n  this.id = nextId++;\n  this.name = "conditon";\n  type = type === undefined ? "positive" : type;\n\n  switch (type) {\n    case "positive":\n      this.tags = {\n        type: "condition",\n        conditionType: \'positive\'\n      };\n      break;\n\n    case "negative":\n      this.tags = {\n        type: "condition",\n        conditionType: \'negative\'\n      };\n      break;\n\n    case "ncc":\n      this.tags = {\n        type: \'condition\',\n        conditionType: "negConjCondition"\n      };\n      break;\n\n    default:\n      throw new Error("Unrecognised condition");\n  }\n\n  this.constantTests = [];\n  this.bindings = {};\n  this.conditions = {};\n};\n/**\n   Adds a test to the condition\n   @param field\n   @param op\n   @param val\n   @method\n*/\n\n\nCondition.prototype.addTest = function (field, op, val) {\n  this.constantTests.push({\n    field: field,\n    operator: op,\n    value: val\n  });\n  return this;\n};\n/**\n   Adds a binding to the condition\n   @param boundName\n   @param dataName\n   @param tests\n   @method\n*/\n\n\nCondition.prototype.addBinding = function (boundName, dataName, tests) {\n  //tests as pairs of op and value/boundName\n  this.bindings[boundName] = [dataName, tests];\n};\n/**\n   Adds a new subcondiiton to the condition\n   @param type\n   @param testsAndBindings\n   @method\n*/\n\n\nCondition.prototype.newCondition = function (type, testsAndBindings) {\n  if (this.type !== \'negConjCondition\') {\n    throw new Error("Only NCC\'s can have sub conditions");\n  }\n\n  var newCondition = new Condition(type);\n  testsAndBindings.tests.forEach(function (d) {\n    return newCondition.addTest.apply(newCondition, _toConsumableArray(d));\n  });\n  testsAndBindings.bindings.forEach(function (d) {\n    return newCondition.addBinding.apply(newCondition, _toConsumableArray(d));\n  });\n  this.conditions[newCondition.id] = newCondition;\n};\n/**\n   Action constructor, defines data/values to put in a new wme,\n   arithmetic and regex actions to apply to those values\n   @param actionType\n   @param name\n   @class\n*/\n\n\nvar Action = function Action(actionType, name) {\n  _classCallCheck(this, Action);\n\n  this.id = nextId++;\n  this.name = name || "anon";\n  this.tags = {\n    actionType: actionType || "assert"\n  };\n  this.values = {};\n  this.arithmeticActions = {};\n  this.regexActions = {}; //Specify the timing of the proposed action to create:\n\n  this.timing = {\n    invalidateOffset: 0,\n    performOffset: 0,\n    unperformOffset: 0\n  };\n  this.priority = 0;\n};\n/**\n   Add a value to the action\n   @param varName\n   @param value\n   @method\n*/\n\n\nAction.prototype.addValue = function (varName, value) {\n  this.values[varName] = value;\n  return this;\n};\n/**\n   Add an arithmetic modification to the action\n   @param varName\n   @param op\n   @param value\n   @method\n*/\n\n\nAction.prototype.addArithmetic = function (varName, op, value) {\n  this.arithmeticActions[varName] = [op, value];\n  return this;\n};\n/**\n   Add a regular expression modification to the action\n   @param varName\n   @param regex\n   @param options\n   @param replaceValue\n   @method\n*/\n\n\nAction.prototype.addRegex = function (varName, regex, options, replaceValue) {\n  this.regexActions[varName] = [regex, options, replaceValue];\n  return this;\n};\n/**\n   Add timing information to the action\n   @param invalid\n   @param perform\n   @param unperform\n   @method\n*/\n\n\nAction.prototype.addTiming = function (invalid, perform, unperform) {\n  this.timing = {\n    invalidateOffset: invalid,\n    performOffset: perform,\n    unperformOffset: unperform\n  };\n  return this;\n};\n\n\n\n//# sourceURL=webpack://Rete/./RuleCtors.js?')},lodash:
/*!*************************************************************************************!*\
  !*** external {"commonjs":"lodash","commonjs2":"lodash","amd":"lodash","root":"_"} ***!
  \*************************************************************************************/
/*! no static exports found */function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;\n\n//# sourceURL=webpack://Rete/external_%7B%22commonjs%22:%22lodash%22,%22commonjs2%22:%22lodash%22,%22amd%22:%22lodash%22,%22root%22:%22_%22%7D?")}})});