<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ShellModules/shell_node_mod.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ShellModules/shell_node_mod.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>if(typeof define !== 'function'){
    var define = require('amdefine')(module);
}

define(['underscore'],function(_){
    "use strict";
    /**
       Defines shell prototype methods for changing a node
       @exports ShellModules/shell_node_mod
    */

    var ShellPrototype = {};

    /**
       Rename the current nodes name
       @method
       @param name The name to rename to
       @param sourceId
     */
    ShellPrototype.rename = function(name,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        source.name = name;
    };

    /**
       Set a key:value pair in the node[field] to value
       @method
       @param field
       @param parameter
       @param value
       @param sourceId
     */
    ShellPrototype.setParameter = function(field,parameter,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        //if(!source[field]) throw new Error("Unrecognised field");
        //if(field !== 'values' &amp;&amp; field !== 'tags' &amp;&amp; field !== 'annotations'){
        //    throw new Error("Bad field");
        //}
        if(source[field] === undefined &amp;&amp; field !== undefined){
            source[field] = {};
        }
        if(parameter === undefined &amp;&amp; field !== 'values' &amp;&amp; field !== 'tags' &amp;&amp; field !== 'children' &amp;&amp; field !== 'parents' &amp;&amp; field !== 'name' &amp;&amp; field !== 'id'){
            delete source[field];
        }else if(value !== undefined){
            source[field][parameter] = value;
        }else{
            //if no value is specified, remove the entry
            delete source[field][parameter];
        }
        
    };


    /**
       Interface method to add a link to the cwd. can be reciprocal
       @method
       @param target The field of the node to add the link to
       @param id The id of the node being linked towards
       @param reciprocal Whether the node of id will have a link back
       @param sourceId
     */
    ShellPrototype.link = function(target,id,reciprocal,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;

        //validate:
        if(isNaN(Number(id))) { throw new Error("id should be a global id number"); }
        if(this.allNodes[id] === undefined){
            throw new Error("Node for id " + id + " does not exist");
        }
        if(!source[target]) { throw new Error("Unrecognised target"); }

        //perform the link:
        var nodeToLink = this.getNode(id);
        this.addLink(source,target,nodeToLink.id,nodeToLink.name);
        //this.cwd[target][nodeToLink.id] = true; //this.allNodes[id];
        if(reciprocal){
            var rTarget = 'parents';
            if(target === 'parents') { rTarget = 'children'; }
            this.addLink(nodeToLink,rTarget,source.id,source.name);
            //nodeToLink[rtarget][this.cwd.id] = true; //this.cwd;
        }
    };


    /**
       Set/Add a binding pair to a condition in a rule
       @method
       @param conditionNum The condition to add the binding to
       @param toVar The variable name to use as the bound name
       @param fromVar the wme field to bind
       @param sourceId
       @example toVar = wme.fromVar
     */
    ShellPrototype.setBinding = function(conditionId,toVar,fromVar,testPairs,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Add binding to:",conditionId,toVar,fromVar);
        if(source.tags.type !== 'rule' &amp;&amp; source.tags.type !== 'negConjCondition'){
            throw new Error("Trying to modify a rule when not located at a rule");
        }
        if(source.conditions[conditionId] === undefined){
            throw new Error("Can't add binding to non=existent condition");
        }
        var condition = this.getNode(conditionId);
        //condition.bindings.push([toVar,fromVar]);
        condition.setBinding(toVar,fromVar,testPairs);
        console.log(condition,condition.bindings);
    };

    /**
       set an arithmetic operation for an action
       @method
       @param actionNum The action to add the operation to
       @param varName the variable to change
       @param op the operator to use. ie: + - * / ....
       @param value The value to apply to the varName

       @TODO allow bindings in the rhs/value field
     */
    ShellPrototype.setArithmetic = function(actionId,varName,op,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Setting arithmetic of:",actionId,varName,op,value);
        console.log(_.keys(source.actions));
        if(source.tags.type !== 'rule'){
            throw new Error("Arithmetic can only be applied to actions of rules");
        }
        if(source.actions[actionId] === undefined){
            throw new Error("Cannot add arithmetic to non-existent action");
        }
        var action = this.getNode(actionId);

        if(action === undefined){
            throw new Error("Could not find action");
        }
        action.setArith(varName,op,value);

    };

    /**
       Store a regex transform for an action, in a similar way to arithmetic actions
       @method
       @param actionId
       @param varName
       @param regex
       @param sourceId
    */
    ShellPrototype.setRegex = function(actionId,varName,regex,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        console.log("Setting regex transform of:",actionId,varName,regex);
        //if it includes the opening and closing /'s, remove them?

        //get the action
        var action = this.getNode(actionId);
        action.setRegex(varName,regex);

    };

    /**
       Modify the timing of an action
       @method
       @param actionId
       @param timeVar
       @param value
       @param sourceId
    */
    ShellPrototype.setTiming = function(actionId,timeVar,value,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd,
            action = this.getNode(actionId);
        action.setTiming(timeVar,value);

    };
    
    /**
       Set an internal value of an action, without going into that node itself
       @method
       @param actionNum The action to target
       @param a The parameter name
       @param b The parameter value
       @param sourceId
       @note If only a is supplied, sets the action's actionType tag
     */
    ShellPrototype.setActionValue = function(actionId,a,b,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule'){
            throw new Error("Can't set action values on non-actions");
        }
        if(source.actions[actionId] !== undefined){
            var action = this.getNode(actionId);
            action.setValue(b,'values',a);
        }else{
            throw new Error("Unrecognised action");
        }
    };

    /**
       Set the actiontype of an (Action) node
       @method
       @param actionNum
       @param a the type
       @param sourceId
     */
    ShellPrototype.setActionType = function(actionId,a,sourceId){
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule'){
            throw new Error("Can't set action type for non-rules");
        }
        if(source.actions[actionId] !== undefined){
            var action = this.allNodes[actionId];
            action.setValue(a,'tags','actionType');
        }else{
            throw new Error("Unrecognised action");
        }
    };
    
    /**
       Add/modify a constant test of a condition
       @method
       @param conNum the condition to target
       @param testNum the test to target
       @param field the wme field to test
       @param op The operator to test using
       @param val the value to test against
       @param sourceId
     */
    ShellPrototype.setTest = function(conditionId,testId,field,op,value,sourceId){
        console.log(conditionId,testId,field,op,value,sourceId);
        var source = sourceId ? this.getNode(sourceId) : this.cwd;
        if(source.tags.type !== 'rule' &amp;&amp; source.tags.type !== 'negConjCondition'){
            throw new Error("Trying to set test on a non-rule node");
        }
        if(source.conditions[conditionId] === undefined || this.getNode(conditionId).constantTests[testId] === undefined){
            throw new Error("trying to set non-existent test");
        }

        var condition = this.getNode(conditionId);
        condition.setTest(testId,field,op,value);
    };


    return ShellPrototype;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Browser_WebMain.html">Browser/WebMain</a></li><li><a href="module-CLI_HelpCLI.html">CLI/HelpCLI</a></li><li><a href="module-CLI_MainCommandCLI.html">CLI/MainCommandCLI</a></li><li><a href="module-Commands_BookMarkCommands.html">Commands/BookMarkCommands</a></li><li><a href="module-Commands_Command_Aggregate.html">Commands/Command_Aggregate</a></li><li><a href="module-Commands_CommandTemplate.html">Commands/CommandTemplate</a></li><li><a href="module-Commands_GeneralCommands.html">Commands/GeneralCommands</a></li><li><a href="module-Commands_NodeCommands.html">Commands/NodeCommands</a></li><li><a href="module-Commands_ReteCommands.html">Commands/ReteCommands</a></li><li><a href="module-Commands_RuleCommands.html">Commands/RuleCommands</a></li><li><a href="module-Commands_SimulationCommands.html">Commands/SimulationCommands</a></li><li><a href="module-Commands_TraceCommands.html">Commands/TraceCommands</a></li><li><a href="module-Drawing_DrawUtils.html">Drawing/DrawUtils</a></li><li><a href="module-Drawing_GeneralDrawing.html">Drawing/GeneralDrawing</a></li><li><a href="module-Drawing_NodeDrawing.html">Drawing/NodeDrawing</a></li><li><a href="module-Drawing_ReteDrawing.html">Drawing/ReteDrawing</a></li><li><a href="module-Drawing_RuleDrawing.html">Drawing/RuleDrawing</a></li><li><a href="module-Drawing_TraceDrawing.html">Drawing/TraceDrawing</a></li><li><a href="module-globalData.html">globalData</a></li><li><a href="module-Node_Action.html">Node/Action</a></li><li><a href="module-Node_Bookmark.html">Node/Bookmark</a></li><li><a href="module-Node_Condition.html">Node/Condition</a></li><li><a href="module-Node_Constructors.html">Node/Constructors</a></li><li><a href="module-Node_GraphNode.html">Node/GraphNode</a></li><li><a href="module-Node_Institution.html">Node/Institution</a></li><li><a href="module-Node_Rule.html">Node/Rule</a></li><li><a href="module-Parse.html">Parse</a></li><li><a href="module-Shell.html">Shell</a></li><li><a href="module-ShellModules_shell_graph_search.html">ShellModules/shell_graph_search</a></li><li><a href="module-ShellModules_shell_json.html">ShellModules/shell_json</a></li><li><a href="module-ShellModules_shell_node_addition.html">ShellModules/shell_node_addition</a></li><li><a href="module-ShellModules_shell_node_deletion.html">ShellModules/shell_node_deletion</a></li><li><a href="module-ShellModules_shell_node_mod.html">ShellModules/shell_node_mod</a></li><li><a href="module-ShellModules_shell_prototype_extraction.html">ShellModules/shell_prototype_extraction</a></li><li><a href="module-ShellModules_shell_prototype_main.html">ShellModules/shell_prototype_main</a></li><li><a href="module-ShellModules_shell_rete.html">ShellModules/shell_rete</a></li><li><a href="module-ShellModules_shell_search.html">ShellModules/shell_search</a></li><li><a href="module-ShellModules_shell_state_change.html">ShellModules/shell_state_change</a></li><li><a href="module-ShellModules_shell_string.html">ShellModules/shell_string</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="GraphNode.html">GraphNode</a></li><li><a href="module-Node_Action-Action.html">Action</a></li><li><a href="Node_Bookmark.html">Node/Bookmark</a></li><li><a href="Node_Condition.html">Node/Condition</a></li><li><a href="Node_Institution.html">Node/Institution</a></li><li><a href="Node_Rule.html">Node/Rule</a></li><li><a href="Shell.html">Shell</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Mar 02 2016 23:18:25 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
