<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
   @file utils
   @purpose defines general utilities to use across projects
*/
if(typeof define !== 'function'){
    var define = require('amdefine')(module);
}

define(['underscore'],function(_){
    "use strict";
    var util = {};
    
    util.randomChoice = function(array){
        var randIndex = Math.floor(Math.random() * array.length);
        return array[randIndex];
    };

    
    // util.textAlignPairs = function(arrayOfPairs){
    //     console.log("Aligning:",arrayOfPairs);
    //     //Get the largest strings on each side
    //     var maxStringLengthLHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //         return d[0].length;
    //     })),
    //         maxStringLengthRHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //             return d[1].length;
    //         })),
    //         totalStringLength = Math.max(maxStringLengthLHS,maxStringLengthRHS),
    //     //Align each side
    //         alignedPairs = arrayOfPairs.map(function(d){
    //             var lhsDifference = d[1].length - d[0].length,
    //                 rhsDifference = d[0].length - d[1].length,
    //                 lhs = "",
    //                 rhs = "";
                
    //             if(lhsDifference > 0){
    //                 lhs = new Array(lhsDifference).join("_") + d[0];
    //             }else{
    //                 lhs = d[0];
    //             }
    //             if(rhsDifference > 0){
    //                 rhs = new Array(rhsDifference).join("_") + d[1];
    //             }else{
    //                 rhs = d[1];
    //             }
    //             return [lhs,rhs];
    //         });
        
    //     return alignedPairs;
    // };


    // //Generic draw group function, modes will typically create their own version
    // util.drawGroup = function(globalData,container,className,data,xLocation,groupWidth){
    //     console.log("drawing:",data);
    //     var heightOfNode = util.calculateNodeHeight((globalData.usableHeight - 100),
    //                                                 20,
    //                                                 data.length),
    //         animationLength = 100,
    //         boundGroup = container.selectAll("."+className)
    //         .data(data,function(d,i){ return d.id; });

    //     //exit selection
    //     boundGroup.exit().selectAll("rect")
    //         .transition()
    //         .duration(animationLength)
    //         .style("fill","red");

    //     boundGroup.exit().selectAll("text").transition()
    //         .style("opacity",0);
        
    //     boundGroup.exit().transition().delay(animationLength).remove();

    //     //entry selection
    //     var entryGroup = boundGroup.enter().append("g")
    //         .classed(className, true)
    //         .attr("transform","translate(" + xLocation + ",100)");


    //     //create
    //     entryGroup.append("rect")
    //         .attr("width",0)
    //         .attr("height",0)
    //         .style("fill",globalData.colours.lightBlue)
    //         .style("opacity",0)
    //         .attr("rx",0)
    //         .attr("ry",0);
        

    //     entryGroup.append("text")
    //         .style("text-anchor","middle")
    //         .style("fill","white")
    //         .style("opacity",0);


    //     //update selection
    //     //transition to updated sizes etc
    //     boundGroup.transition().delay(animationLength).attr("transform",function(d,i){
    //         return "translate(" + xLocation + "," + (100 + (i * (heightOfNode + 20))) + ")";
    //     })
    //         .selectAll("text")
    //         .attr("transform","translate(" + (groupWidth * 0.5) + "," +
    //               (heightOfNode * 0.5) + ")");

        
    //     boundGroup.selectAll("rect")
    //         .transition().delay(animationLength*3).duration(animationLength)
    //         .attr("width",groupWidth)
    //         .attr("height",heightOfNode)
    //         .attr("rx",10)
    //         .attr("ry",10)
    //         .style("opacity",1);

    //     boundGroup.selectAll("text").transition().delay(animationLength*3).duration(animationLength)
    //         .text(function(d){ return d.id + " : " + d.name; })
    //         .style("opacity",1);
        
    //     return boundGroup;
    // };

    //calculate, given an size of an area, how far apart node are,
    // and the number of items: the size of each individual node
    // util.calculateNodeHeight = function(amtOfSpace,separatorSpace,dataLength){
    //     if(dataLength > 0){
    //         return (amtOfSpace - (dataLength * separatorSpace)) / dataLength;
    //     }else{
    //         return (amtOfSpace - separatorSpace);
    //     }
    // };

    util.operatorToString = function(operatorName){
        var conversion = {
            "EQ" : "==",
            "LT" : "&lt;",
            "GT" : ">",
            "LTE" : "&lt;=",
            "GTE" : ">=",
            "NE" : "!=="
        };

        if(conversion[operatorName]){
            return conversion[operatorName];
        }else{
            console.warn("No conversion for operator:",operatorName);
            return operatorName;
        }
    };

    //Take a selection, append a wrapping classname,
    //offset by a global, and invidual amount, set a colour,
    //and use a passed in function to fill the texts
    //returning the resulting texts
    util.annotate = function(boundDom,className,
                             verticalOffset,nodeHeight,verticalSeparator,
                             horizontalOffset,nodeWidth,colour,textFunction,textColour){

        //Exit Selection:
        boundDom.exit().remove();

        //enter selection:
        var enter = boundDom.enter().append("g").classed(className,true);

        //create new
        enter.append("rect")
            .classed(className + "rect", true);
        enter.append("text")
            .classed(className + "text", true)
            .attr("dy","1.4em");
        

        //update:
        boundDom.attr("transform",function(e,i){
            return "translate(" + horizontalOffset + ","
                + ((verticalOffset + (i * (nodeHeight + verticalSeparator)))) + ")";
        });
        boundDom.selectAll("."+className+"rect")
            .attr("width",nodeWidth - (horizontalOffset * 2))
            .attr("height",nodeHeight)
            .style("fill",colour)
            .attr("rx",10).attr("ry",10);

        
        var texts = boundDom.selectAll("."+className+"text")
            .attr("transform","translate(" + horizontalOffset + "," + (nodeHeight * 0.2) + ")")
            .text(textFunction)
        //todo: parameterise this:
            .style("fill",textColour || "white");

        return texts;
    };

    //repeatedly truncate text until it fits in a certain amount of space;
    //TODO: customise
    util.truncateDrawnText = function(d){
        var bbox = this.getBBox();
        var maxLength = d.name.length - 4;
        while( bbox.wdith > 10 &amp;&amp; maxLength > 10){
            d.shortName = d.name.slice(0,maxLength) + "...";
            //d3.select(this).text(d.shortName);
            bbox = this.getBBox();
            maxLength -= 2;
        }
    };

    // //Take a text, and wrap it onto multiple 'lines'
    // util.wrapText = function(textSelection,width,d3){
    //     //console.log("Wrapping selection:",textSelection);
    //     //TODO: check that the selection IS of texts?
    //     textSelection.each(function(){
    //             var text = d3.select(this),
    //                 words = text.text().split(/\s+/),
    //                 word,//current word
    //                 line = [],//current line
    //                 y = text.attr("y"),
    //                 dy = parseFloat(text.attr("dy")) || parseFloat("1.4em"),
    //                 tspan = text.text(null).append("tspan")
    //                 .attr("x",0)
    //                 .attr("y",y)
    //                 .attr("dy",dy);

    //         //console.log("Wrapping:",text,text.text());
    //         while(!_.isEmpty(words)){
    //             word = words.shift();
    //             line.push(word);
    //             tspan.text(line.join(" "));
    //             if(tspan.node().getComputedTextLength() > width){
    //                 line.pop();
    //                 tspan.text(line.join(" "));
    //                 line = [word];
    //                 tspan = text.append("tspan").attr("x",20)
    //                     .attr("dy",dy +"em").text(word);
    //             }
    //         }
    //     });
    // };
    
    return util;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-The.html">The</a></li></ul><h3>Classes</h3><ul><li><a href="GraphNode.html">GraphNode</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addAction">addAction</a></li><li><a href="global.html#addLink">addLink</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#addNodeFromJson">addNodeFromJson</a></li><li><a href="global.html#addTest">addTest</a></li><li><a href="global.html#assertChildren">assertChildren</a></li><li><a href="global.html#assertWMEList">assertWMEList</a></li><li><a href="global.html#bfs">bfs</a></li><li><a href="global.html#cd">cd</a></li><li><a href="global.html#cdNode">cdNode</a></li><li><a href="global.html#cleanup">cleanup</a></li><li><a href="global.html#cleanupNode">cleanupNode</a></li><li><a href="global.html#clearActivatedRules">clearActivatedRules</a></li><li><a href="global.html#clearRete">clearRete</a></li><li><a href="global.html#compileRete">compileRete</a></li><li><a href="global.html#convertObject">convertObject</a></li><li><a href="global.html#copyFile">copyFile</a></li><li><a href="global.html#dealWithGet">dealWithGet</a></li><li><a href="global.html#dealWithPost">dealWithPost</a></li><li><a href="global.html#deleteNode">deleteNode</a></li><li><a href="global.html#dfs">dfs</a></li><li><a href="global.html#drawInspectResults">drawInspectResults</a></li><li><a href="global.html#drawNode">drawNode</a></li><li><a href="global.html#drawRule">drawRule</a></li><li><a href="global.html#drawSearchResults">drawSearchResults</a></li><li><a href="global.html#drawSingleNode">drawSingleNode</a></li><li><a href="global.html#drawStash">drawStash</a></li><li><a href="global.html#exportJson">exportJson</a></li><li><a href="global.html#extractFactPrototypes">extractFactPrototypes</a></li><li><a href="global.html#getNode">getNode</a></li><li><a href="global.html#getNodeListByIds">getNodeListByIds</a></li><li><a href="global.html#importJson">importJson</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#nodeToShortString">nodeToShortString</a></li><li><a href="global.html#nodeToStringList">nodeToStringList</a></li><li><a href="global.html#pathExtraction">pathExtraction</a></li><li><a href="global.html#removeAction">removeAction</a></li><li><a href="global.html#removeBinding">removeBinding</a></li><li><a href="global.html#removeCondition">removeCondition</a></li><li><a href="global.html#removeNumericId">removeNumericId</a></li><li><a href="global.html#removeTest">removeTest</a></li><li><a href="global.html#rename">rename</a></li><li><a href="global.html#rm">rm</a></li><li><a href="global.html#ruleToStringList">ruleToStringList</a></li><li><a href="global.html#selectOrShare">selectOrShare</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#setActionnValue">setActionnValue</a></li><li><a href="global.html#setActionType">setActionType</a></li><li><a href="global.html#setArithmetic">setArithmetic</a></li><li><a href="global.html#setBinding">setBinding</a></li><li><a href="global.html#setParameter">setParameter</a></li><li><a href="global.html#setTest">setTest</a></li><li><a href="global.html#stash">stash</a></li><li><a href="global.html#top">top</a></li><li><a href="global.html#traceNode">traceNode</a></li><li><a href="global.html#unstash">unstash</a></li><li><a href="global.html#wrapText">wrapText</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Feb 27 2016 22:45:54 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
