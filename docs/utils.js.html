<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
   Defines general utilities to use across projects
   @module utils
*/
if(typeof define !== 'function'){
    var define = require('amdefine')(module);
}

define(['underscore'],function(_){
    "use strict";
    /**
       @alias module:utils
     */
    var util = {};

    /**
       Make a random choice from the passed in array
       @deprecated
       @function
     */
    util.randomChoice = function(array){
        var randIndex = Math.floor(Math.random() * array.length);
        return array[randIndex];
    };

    
    // util.textAlignPairs = function(arrayOfPairs){
    //     console.log("Aligning:",arrayOfPairs);
    //     //Get the largest strings on each side
    //     var maxStringLengthLHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //         return d[0].length;
    //     })),
    //         maxStringLengthRHS = Math.max.apply(null,arrayOfPairs.map(function(d){
    //             return d[1].length;
    //         })),
    //         totalStringLength = Math.max(maxStringLengthLHS,maxStringLengthRHS),
    //     //Align each side
    //         alignedPairs = arrayOfPairs.map(function(d){
    //             var lhsDifference = d[1].length - d[0].length,
    //                 rhsDifference = d[0].length - d[1].length,
    //                 lhs = "",
    //                 rhs = "";
                
    //             if(lhsDifference > 0){
    //                 lhs = new Array(lhsDifference).join("_") + d[0];
    //             }else{
    //                 lhs = d[0];
    //             }
    //             if(rhsDifference > 0){
    //                 rhs = new Array(rhsDifference).join("_") + d[1];
    //             }else{
    //                 rhs = d[1];
    //             }
    //             return [lhs,rhs];
    //         });
        
    //     return alignedPairs;
    // };


    // //Generic draw group function, modes will typically create their own version
    // util.drawGroup = function(globalData,container,className,data,xLocation,groupWidth){
    //     console.log("drawing:",data);
    //     var heightOfNode = util.calculateNodeHeight((globalData.usableHeight - 100),
    //                                                 20,
    //                                                 data.length),
    //         animationLength = 100,
    //         boundGroup = container.selectAll("."+className)
    //         .data(data,function(d,i){ return d.id; });

    //     //exit selection
    //     boundGroup.exit().selectAll("rect")
    //         .transition()
    //         .duration(animationLength)
    //         .style("fill","red");

    //     boundGroup.exit().selectAll("text").transition()
    //         .style("opacity",0);
        
    //     boundGroup.exit().transition().delay(animationLength).remove();

    //     //entry selection
    //     var entryGroup = boundGroup.enter().append("g")
    //         .classed(className, true)
    //         .attr("transform","translate(" + xLocation + ",100)");


    //     //create
    //     entryGroup.append("rect")
    //         .attr("width",0)
    //         .attr("height",0)
    //         .style("fill",globalData.colours.lightBlue)
    //         .style("opacity",0)
    //         .attr("rx",0)
    //         .attr("ry",0);
        

    //     entryGroup.append("text")
    //         .style("text-anchor","middle")
    //         .style("fill","white")
    //         .style("opacity",0);


    //     //update selection
    //     //transition to updated sizes etc
    //     boundGroup.transition().delay(animationLength).attr("transform",function(d,i){
    //         return "translate(" + xLocation + "," + (100 + (i * (heightOfNode + 20))) + ")";
    //     })
    //         .selectAll("text")
    //         .attr("transform","translate(" + (groupWidth * 0.5) + "," +
    //               (heightOfNode * 0.5) + ")");

        
    //     boundGroup.selectAll("rect")
    //         .transition().delay(animationLength*3).duration(animationLength)
    //         .attr("width",groupWidth)
    //         .attr("height",heightOfNode)
    //         .attr("rx",10)
    //         .attr("ry",10)
    //         .style("opacity",1);

    //     boundGroup.selectAll("text").transition().delay(animationLength*3).duration(animationLength)
    //         .text(function(d){ return d.id + " : " + d.name; })
    //         .style("opacity",1);
        
    //     return boundGroup;
    // };

    //calculate, given an size of an area, how far apart node are,
    // and the number of items: the size of each individual node
    // util.calculateNodeHeight = function(amtOfSpace,separatorSpace,dataLength){
    //     if(dataLength > 0){
    //         return (amtOfSpace - (dataLength * separatorSpace)) / dataLength;
    //     }else{
    //         return (amtOfSpace - separatorSpace);
    //     }
    // };

    /**
       convert a string representation of an operator to its normal form
       @deprecated
       @function
     */
    util.operatorToString = function(operatorName){
        var conversion = {
            "EQ" : "==",
            "LT" : "&lt;",
            "GT" : ">",
            "LTE" : "&lt;=",
            "GTE" : ">=",
            "NE" : "!=="
        };

        if(conversion[operatorName]){
            return conversion[operatorName];
        }else{
            console.warn("No conversion for operator:",operatorName);
            return operatorName;
        }
    };

    /**
       Take a selection, append a wrapping classname,
       offset by a global, and invidual amount, set a colour,
       and use a passed in function to fill the texts
       returning the resulting texts
       @function
    */
    util.annotate = function(boundDom,className,
                             verticalOffset,nodeHeight,verticalSeparator,
                             horizontalOffset,nodeWidth,colour,textFunction,textColour){

        //Exit Selection:
        boundDom.exit().remove();

        //enter selection:
        var enter = boundDom.enter().append("g").classed(className,true);

        //create new
        enter.append("rect")
            .classed(className + "rect", true);
        enter.append("text")
            .classed(className + "text", true)
            .attr("dy","1.4em");
        

        //update:
        boundDom.attr("transform",function(e,i){
            return "translate(" + horizontalOffset + ","
                + ((verticalOffset + (i * (nodeHeight + verticalSeparator)))) + ")";
        });
        boundDom.selectAll("."+className+"rect")
            .attr("width",nodeWidth - (horizontalOffset * 2))
            .attr("height",nodeHeight)
            .style("fill",colour)
            .attr("rx",10).attr("ry",10);

        
        var texts = boundDom.selectAll("."+className+"text")
            .attr("transform","translate(" + horizontalOffset + "," + (nodeHeight * 0.2) + ")")
            .text(textFunction)
        //todo: parameterise this:
            .style("fill",textColour || "white");

        return texts;
    };


    /**
       repeatedly truncate text until it fits in a certain amount of space;
       @function
       TODO: customise
    */
    util.truncateDrawnText = function(d){
        var bbox = this.getBBox();
        var maxLength = d.name.length - 4;
        while( bbox.wdith > 10 &amp;&amp; maxLength > 10){
            d.shortName = d.name.slice(0,maxLength) + "...";
            //d3.select(this).text(d.shortName);
            bbox = this.getBBox();
            maxLength -= 2;
        }
    };

    // //Take a text, and wrap it onto multiple 'lines'
    // util.wrapText = function(textSelection,width,d3){
    //     //console.log("Wrapping selection:",textSelection);
    //     //TODO: check that the selection IS of texts?
    //     textSelection.each(function(){
    //             var text = d3.select(this),
    //                 words = text.text().split(/\s+/),
    //                 word,//current word
    //                 line = [],//current line
    //                 y = text.attr("y"),
    //                 dy = parseFloat(text.attr("dy")) || parseFloat("1.4em"),
    //                 tspan = text.text(null).append("tspan")
    //                 .attr("x",0)
    //                 .attr("y",y)
    //                 .attr("dy",dy);

    //         //console.log("Wrapping:",text,text.text());
    //         while(!_.isEmpty(words)){
    //             word = words.shift();
    //             line.push(word);
    //             tspan.text(line.join(" "));
    //             if(tspan.node().getComputedTextLength() > width){
    //                 line.pop();
    //                 tspan.text(line.join(" "));
    //                 line = [word];
    //                 tspan = text.append("tspan").attr("x",20)
    //                     .attr("dy",dy +"em").text(word);
    //             }
    //         }
    //     });
    // };
    
    return util;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Browser_WebMain.html">Browser/WebMain</a></li><li><a href="module-CLI_HelpCLI.html">CLI/HelpCLI</a></li><li><a href="module-CLI_MainCommandCLI.html">CLI/MainCommandCLI</a></li><li><a href="module-Commands_BookMarkCommands.html">Commands/BookMarkCommands</a></li><li><a href="module-Commands_Command_Aggregate.html">Commands/Command_Aggregate</a></li><li><a href="module-Commands_CommandTemplate.html">Commands/CommandTemplate</a></li><li><a href="module-Commands_GeneralCommands.html">Commands/GeneralCommands</a></li><li><a href="module-Commands_NodeCommands.html">Commands/NodeCommands</a></li><li><a href="module-Commands_ReteCommands.html">Commands/ReteCommands</a></li><li><a href="module-Commands_RuleCommands.html">Commands/RuleCommands</a></li><li><a href="module-Commands_SimulationCommands.html">Commands/SimulationCommands</a></li><li><a href="module-Commands_TraceCommands.html">Commands/TraceCommands</a></li><li><a href="module-Drawing_DrawUtils.html">Drawing/DrawUtils</a></li><li><a href="module-Drawing_GeneralDrawing.html">Drawing/GeneralDrawing</a></li><li><a href="module-Drawing_NodeDrawing.html">Drawing/NodeDrawing</a></li><li><a href="module-Drawing_RuleDrawing.html">Drawing/RuleDrawing</a></li><li><a href="module-Drawing_TraceDrawing.html">Drawing/TraceDrawing</a></li><li><a href="module-Node_Action.html">Node/Action</a></li><li><a href="module-Node_Bookmark.html">Node/Bookmark</a></li><li><a href="module-Node_Condition.html">Node/Condition</a></li><li><a href="module-Node_Constructors.html">Node/Constructors</a></li><li><a href="module-Node_GraphNode.html">Node/GraphNode</a></li><li><a href="module-Node_Institution.html">Node/Institution</a></li><li><a href="module-Node_Rule.html">Node/Rule</a></li><li><a href="module-Parse.html">Parse</a></li><li><a href="module-Shell.html">Shell</a></li><li><a href="module-ShellModule_shell_node_mod.html">ShellModule/shell_node_mod</a></li><li><a href="module-ShellModules_shell_graph_search.html">ShellModules/shell_graph_search</a></li><li><a href="module-ShellModules_shell_json.html">ShellModules/shell_json</a></li><li><a href="module-ShellModules_shell_node_addition.html">ShellModules/shell_node_addition</a></li><li><a href="module-ShellModules_shell_node_deletion.html">ShellModules/shell_node_deletion</a></li><li><a href="module-ShellModules_shell_prototype_extraction.html">ShellModules/shell_prototype_extraction</a></li><li><a href="module-ShellModules_shell_prototype_main.html">ShellModules/shell_prototype_main</a></li><li><a href="module-ShellModules_shell_rete.html">ShellModules/shell_rete</a></li><li><a href="module-ShellModules_shell_search.html">ShellModules/shell_search</a></li><li><a href="module-ShellModules_shell_state_change.html">ShellModules/shell_state_change</a></li><li><a href="module-ShellModules_shell_string.html">ShellModules/shell_string</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="module-Node_Rule.html">Node/Rule</a></li><li><a href="module-Shell.html">Shell</a></li><li><a href="Node_Action.html">Node/Action</a></li><li><a href="Node_Bookmark.html">Node/Bookmark</a></li><li><a href="Node_Condition.html">Node/Condition</a></li><li><a href="Node_GraphNode.html">Node/GraphNode</a></li><li><a href="Node_Institution.html">Node/Institution</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Feb 28 2016 05:31:58 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
